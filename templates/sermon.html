<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
  <title>BIBLE LAB</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
    }
    .page-wrap {
      display: flex;
      gap: 1rem;
      padding: 1rem;
      height: 100vh;
    }
    .left-col {
      width: 280px;
      display: flex;
      flex-direction: column;
      gap: .75rem;
      overflow-y: auto;
      background: linear-gradient(135deg, #fafbfc 0%, #f3f4f6 100%);
      padding: .75rem;
      border-radius: 12px;
    }
    .right-col {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0;
      min-width: 0;
      overflow: hidden;
    }

    /* Top 영역: 고정 */
    .top-section {
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      gap: .5rem;
      padding-bottom: .5rem;
      border-bottom: 2px solid #e0e0e0;
      background: #f5f5f5;
    }

    /* Content 영역: 스크롤 가능 */
    .content-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: .75rem;
      overflow-y: auto;
      padding-top: .75rem;
      min-height: 0;
    }
    .box {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: .6rem;
    }
    .label-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: .5rem;
      margin-bottom: .35rem;
    }
    .label { font-weight: 600; }
    .label-hint {
      font-size: .7rem;
      font-weight: 400;
      color: #0066cc;
      background: #e6f2ff;
      padding: .15rem .4rem;
      border-radius: 9999px;
      margin-left: .35rem;
      white-space: nowrap;
    }
    input[type="text"],
    input[type="date"],
    select {
      width: 100%;
      padding: .35rem .5rem;
    }
    textarea {
      width: 100%;
      min-height: 80px;
      resize: vertical;
      font-family: inherit;
      line-height: 1.4;
    }
    .btn-row {
      display: flex;
      gap: .5rem;
      flex-wrap: wrap;
    }
    button {
      padding: .35rem .6rem;
      border: 1px solid #ccc;
      background: #f0f0f0;
      border-radius: 6px;
      cursor: pointer;
    }
    button:hover { background: #e0e0e0; }
    button.primary {
      background: #4a90e2;
      color: white;
      border-color: #4a90e2;
    }
    button.primary:hover { background: #357abd; }
    button.danger {
      background: #e74c3c;
      color: white;
      border-color: #e74c3c;
    }
    button.step-btn {
      width: 100%;
      margin-bottom: .5rem;
      text-align: left;
      padding-left: .8rem;
    }

    .style-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: .4rem .6rem;
      margin-bottom: .3rem;
      background: #f8f9fa;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      border: 2px solid transparent;
    }
    .style-item:hover { background: #e9ecef; }
    .style-item.active {
      background: #dfe6ff;
      border: 2px solid #4a90e2;
    }
    .style-desc {
      font-size: .65rem;
      color: #999;
      margin-top: .15rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .title-option-label {
      display: block;
      margin-bottom: .5rem;
      padding: .4rem;
      background: #f8f9fa;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .title-option-label:hover {
      background: #e9ecef;
    }
    .title-option-label input[type="radio"]:checked + span {
      font-weight: 600;
      color: #4a90e2;
    }

    .toggle-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .status-bar {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 12px;
      padding: 1rem 2rem;
      font-size: 1rem;
      font-weight: 600;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25);
      display: none;
      text-align: center;
      z-index: 3000;
      animation: pulse 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* GPT 로딩 오버레이 */
    #gpt-loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .gpt-loading-content {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 3rem 4rem;
      border-radius: 24px;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4), 0 0 100px rgba(102, 126, 234, 0.3);
      animation: slideUp 0.5s ease;
      position: relative;
      overflow: hidden;
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .gpt-loading-content::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      animation: shimmer 3s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
      100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
    }

    .gpt-loading-spinner {
      width: 64px;
      height: 64px;
      margin: 0 auto 1.5rem;
      border: 5px solid rgba(255, 255, 255, 0.2);
      border-top: 5px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      position: relative;
      z-index: 1;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .gpt-loading-text {
      font-size: 1.4rem;
      font-weight: 700;
      color: white;
      margin-bottom: 0.5rem;
      letter-spacing: 0.5px;
      position: relative;
      z-index: 1;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .gpt-loading-subtext {
      font-size: 0.95rem;
      color: rgba(255, 255, 255, 0.9);
      position: relative;
      z-index: 1;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.6;
      }
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }
    .modal.show { display: flex; }

    /* 가이드 모달 - 오른쪽 하단에 배치, 뒤 클릭 가능 */
    #modal-guide {
      background: transparent;
      pointer-events: none;
      align-items: flex-end;
      justify-content: flex-end;
      padding: 1.5rem;
    }
    #modal-guide .modal-content {
      pointer-events: auto;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      animation: slideIn 0.3s ease-out;
    }
    @keyframes slideIn {
      from {
        transform: translateY(20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    .modal-content {
      background: white;
      border-radius: 12px;
      padding: 1.5rem;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }
    .modal-title {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 1rem;
    }
    .modal-buttons {
      display: flex;
      gap: .5rem;
      margin-top: 1rem;
    }
    .modal-buttons button { flex: 1; }

    .storage-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: .4rem .6rem;
      margin-bottom: .3rem;
      background: #f8f9fa;
      border-radius: 6px;
    }

    textarea.autosize { overflow: hidden; }

    /* GPT PRO 결과 박스 스타일 */
    .gpt-pro-result-box {
      background: linear-gradient(135deg, #ff6b9d 0%, #c06c84 100%);
      border: none;
      padding: 1rem;
      border-radius: 8px;
      margin-top: .75rem;
    }
    .gpt-pro-result-box .label {
      color: white;
      font-size: 1.1rem;
      margin-bottom: .5rem;
    }
    .gpt-pro-result-box textarea {
      background: white;
      border: none;
      border-radius: 6px;
      padding: .75rem;
      min-height: 300px;
    }

    /* 버튼 컨테이너 */
    .top-buttons-container {
      display: flex;
      gap: .75rem;
    }
    .top-buttons-container .box {
      flex: 1;
      padding: .7rem;
      border: none;
    }
    .copy-all-box {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    .gpt-pro-box {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }
    .top-buttons-container button {
      background: white;
      font-weight: 600;
      padding: .6rem 1.2rem;
      border: none;
      font-size: .95rem;
      width: 100%;
    }
    .copy-all-box button {
      color: #667eea;
    }
    .gpt-pro-box button {
      color: #f5576c;
    }
    .top-buttons-container .box-title {
      color: white;
      font-weight: 600;
      font-size: .95rem;
      margin-bottom: .25rem;
    }
    .top-buttons-container .box-desc {
      color: rgba(255,255,255,0.9);
      font-size: .8rem;
      margin-bottom: .5rem;
    }

    /* Auth header */
    .auth-header {
      background: white;
      border-bottom: 2px solid #e0e0e0;
      padding: .75rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .auth-header h1 {
      font-size: 1.2rem;
      margin: 0;
      color: #333;
    }
    .auth-links {
      display: flex;
      gap: .75rem;
      align-items: center;
    }
    .auth-links .user-info {
      font-size: .9rem;
      color: #555;
      font-weight: 500;
    }
    .auth-links a {
      padding: .4rem .8rem;
      text-decoration: none;
      border-radius: 6px;
      font-size: .85rem;
      font-weight: 600;
      transition: all 0.2s;
    }
    .auth-links .btn-login {
      background: white;
      color: #4a90e2;
      border: 2px solid #4a90e2;
    }
    .auth-links .btn-login:hover {
      background: #4a90e2;
      color: white;
    }
    .auth-links .btn-signup {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
    }
    .auth-links .btn-signup:hover {
      opacity: 0.9;
    }
    .auth-links .btn-logout {
      background: #e74c3c;
      color: white;
      border: none;
    }
    .auth-links .btn-logout:hover {
      background: #c0392b;
    }
    .auth-links .btn-home {
      background: #95a5a6;
      color: white;
      border: none;
    }
    .auth-links .btn-home:hover {
      background: #7f8c8d;
    }

    /* 관리자 공간 50:50 분할 */
    .guide-row-container {
      display: flex;
      gap: .75rem;
    }
    .guide-row-container .box {
      flex: 1;
    }

    /* 관리자 공간 스크롤 */
    #master-guide-content,
    #guide-content {
      max-height: 300px;
      overflow-y: auto;
    }

    /* 처리 단계 + Q&A 70:30 분할 */
    .processing-qa-container {
      display: flex;
      gap: .75rem;
      flex: 1;
      min-height: 0;
    }
    .processing-steps-panel {
      flex: 7;
      display: flex;
      flex-direction: column;
      gap: .75rem;
      overflow-y: auto;
    }
    .qa-panel {
      flex: 3;
      display: flex;
      flex-direction: column;
      gap: .75rem;
      overflow-y: auto;
    }

    /* Q&A 인터페이스 스타일 */
    .qa-interface {
      background: #fff;
      border: 2px solid #8e9aaf;
      border-radius: 8px;
      padding: .75rem;
      display: flex;
      flex-direction: column;
      height: 100%;
      box-shadow: 0 2px 8px rgba(142, 154, 175, 0.15);
    }
    .qa-prompt {
      font-size: .9rem;
      color: #666;
      margin-bottom: .75rem;
      padding: .5rem;
      background: #f8f9fa;
      border-radius: 6px;
      text-align: center;
    }
    .qa-history {
      flex: 1;
      overflow-y: auto;
      margin-bottom: .75rem;
      padding: .5rem;
      background: #fafafa;
      border-radius: 6px;
      min-height: 200px;
    }
    .qa-message {
      margin-bottom: .75rem;
      padding: .5rem;
      border-radius: 6px;
    }
    .qa-message.user {
      background: #e3f2fd;
      margin-left: 2rem;
    }
    .qa-message.assistant {
      background: #f1f8e9;
      margin-right: 2rem;
    }
    .qa-message-label {
      font-size: .75rem;
      font-weight: 600;
      margin-bottom: .25rem;
      color: #555;
    }
    .qa-message-content {
      font-size: .85rem;
      line-height: 1.4;
      white-space: pre-wrap;
    }
    .qa-input-area {
      display: flex;
      gap: .5rem;
    }
    .qa-input-area textarea {
      flex: 1;
      min-height: 60px;
      resize: vertical;
    }
    .qa-input-area button {
      align-self: flex-end;
      height: fit-content;
    }
    .qa-empty-state {
      text-align: center;
      color: #999;
      font-size: .85rem;
      padding: 2rem;
    }

    /* ===== 모바일 반응형 디자인 ===== */
    @media screen and (max-width: 768px) {
      .page-wrap {
        flex-direction: column;
        height: auto;
        min-height: 100vh;
        padding: .5rem;
        gap: .5rem;
      }

      .right-col {
        width: 100%;
        overflow: visible;
        height: auto;
        display: contents; /* 모바일에서 자식들을 page-wrap 레벨에 배치 */
      }

      /* 모바일에서 순서 조정 */
      .top-section {
        order: 1;
        flex-shrink: 1;
        border-bottom: 2px solid #ccc;
        padding-bottom: .5rem;
      }

      .left-col {
        width: 100%;
        overflow-y: visible;
        order: 2; /* 모바일에서 Top 다음에 위치 */
        background: none;
        padding: 0;
      }

      .content-section {
        order: 3; /* 모바일에서 왼쪽 영역 다음에 위치 */
        overflow-y: visible;
        padding-top: .5rem;
      }

      .box {
        padding: .65rem;
      }

      /* 버튼 크기 증가 (터치 친화적) */
      button {
        padding: .5rem .75rem;
        font-size: .9rem;
        min-height: 44px; /* 터치 권장 크기 */
      }

      button.step-btn {
        font-size: .95rem;
      }

      /* 입력 필드 크기 증가 */
      input[type="text"],
      input[type="date"],
      input[type="password"],
      select {
        padding: .5rem .65rem;
        font-size: 16px; /* iOS 줌 방지 */
        min-height: 44px;
      }

      textarea {
        font-size: 16px; /* iOS 줌 방지 */
        padding: .5rem;
      }

      /* 상단 버튼 컨테이너 - 모바일에서는 세로 배치 */
      .top-buttons-container {
        flex-direction: column;
      }

      .top-buttons-container .box {
        width: 100%;
      }

      /* 관리자 공간 - 모바일에서는 세로 배치 */
      .guide-row-container {
        flex-direction: column;
      }

      .guide-row-container .box {
        width: 100%;
      }

      /* 처리 단계 + Q&A - 모바일에서는 세로 배치 */
      .processing-qa-container {
        flex-direction: column;
      }

      .processing-steps-panel,
      .qa-panel {
        width: 100%;
      }

      /* Auth 헤더 - 모바일 최적화 */
      .auth-header {
        flex-wrap: wrap;
        gap: .5rem;
        padding: .5rem;
      }

      .auth-header h1 {
        font-size: 1.1rem;
      }

      .auth-links {
        gap: .5rem;
        flex-wrap: wrap;
      }

      .auth-links a,
      .auth-links .user-info {
        font-size: .8rem;
        padding: .35rem .6rem;
      }

      /* 모달 크기 조정 */
      .modal-content {
        width: 95%;
        max-height: 90vh;
        padding: 1rem;
      }

      .modal-title {
        font-size: 1.1rem;
      }

      /* 스타일 아이템 터치 영역 증가 */
      .style-item {
        padding: .6rem .75rem;
        margin-bottom: .5rem;
      }

      /* Q&A 메시지 여백 조정 */
      .qa-message.user {
        margin-left: .5rem;
      }

      .qa-message.assistant {
        margin-right: .5rem;
      }

      /* 저장 아이템 버튼 크기 */
      .storage-item {
        flex-direction: column;
        align-items: flex-start;
        gap: .5rem;
      }

      .storage-item > div:last-child {
        display: flex;
        gap: .5rem;
        width: 100%;
      }

      .storage-item button {
        flex: 1;
        font-size: .85rem;
      }

      /* 버튼 행 줄바꿈 */
      .btn-row {
        flex-wrap: wrap;
      }

      /* 상태바 */
      .status-bar {
        font-size: .9rem;
        padding: .8rem 1.5rem;
        max-width: 80%;
      }

      /* 라벨 */
      .label {
        font-size: .95rem;
      }

      /* 제목 선택 라벨 */
      .title-option-label {
        padding: .5rem;
        margin-bottom: .6rem;
      }

      .title-option-label span {
        font-size: .9rem;
      }
    }

    /* 아주 작은 화면 (360px 이하) */
    @media screen and (max-width: 360px) {
      .page-wrap {
        padding: .25rem;
      }

      .box {
        padding: .5rem;
        border-radius: 6px;
      }

      button {
        font-size: .85rem;
        padding: .45rem .6rem;
      }

      .auth-header h1 {
        font-size: 1rem;
      }

      .modal-content {
        padding: .75rem;
      }
    }

    /* Step2 박스 고정 및 블라인드 처리 */
    .step2-box {
      position: relative;
    }

    .step2-content-wrapper {
      position: relative;
      max-height: 200px;
      overflow: hidden;
    }

    .step2-content-wrapper textarea {
      resize: none !important;
      overflow: hidden !important;
    }

    .step2-gradient-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 80px;
      background: linear-gradient(to bottom, rgba(255,255,255,0) 0%, rgba(255,255,255,0.7) 40%, rgba(255,255,255,1) 100%);
      pointer-events: none;
    }

    /* 태블릿 가로 모드 (768px - 1024px) */
    @media screen and (min-width: 769px) and (max-width: 1024px) {
      .left-col {
        width: 320px;
      }

      .page-wrap {
        padding: .75rem;
      }
    }
  </style>
</head>
<body>
  <!-- Auth Header -->
  <div class="auth-header">
    <h1>BIBLE LAB</h1>
    <div class="auth-links">
      <a href="/" class="btn-home">홈</a>
      {% if session.user_id %}
        <span class="user-info">{{ session.user_name }}님</span>
        <a href="/logout" class="btn-logout">로그아웃</a>
      {% else %}
        <a href="/login" class="btn-login">로그인</a>
        <a href="/signup" class="btn-signup">회원가입</a>
      {% endif %}
    </div>
  </div>

  <div class="page-wrap">
    <!-- 왼쪽 -->
    <div class="left-col">
      <!-- 날짜 -->
      <div class="box">
        <label class="label" for="sermon-date">날짜</label>
        <input type="date" id="sermon-date">
      </div>

      <!-- 카테고리 -->
      <div class="box">
        <div class="label-row">
          <label class="label">카테고리</label>
          <button id="btn-manage-categories" style="font-size: .75rem; padding: .2rem .5rem;">관리</button>
        </div>
        <select id="sermon-category"></select>
      </div>

      <!-- 시리즈명 -->
      <div class="box" id="series-box" style="display: none;">
        <label class="label">시리즈명</label>
        <input type="text" id="series-name" placeholder="예: 요한복음 시리즈">
      </div>

      <!-- 성경구절 -->
      <div class="box">
        <label class="label">성경구절<span class="label-hint">필수</span></label>
        <input type="text" id="sermon-ref" placeholder="예) 시 78:1-8">
      </div>

      <!-- 제목 (선택사항) - 직접 입력 -->
      <div class="box">
        <label class="label">제목<span class="label-hint">선택</span></label>
        <input type="text" id="manual-title" placeholder="직접 입력 또는 아래 제목 추천에서 선택">
      </div>

      <!-- 제목 선택 영역 (제목 추천 후 표시) -->
      <div class="box" id="title-selection-box" style="display: none;">
        <label class="label">✨ 제목 추천 선택</label>
        <div id="title-options" style="margin-top: .5rem;"></div>
      </div>

      <!-- 성경 본문 -->
      <div class="box">
        <label class="label">성경 본문<span class="label-hint">선택</span></label>
        <textarea id="sermon-text" class="autosize" placeholder="본문을 여기에 붙여넣으세요."></textarea>
      </div>

      <!-- 설교 스타일 -->
      <div class="box">
        <div class="label-row">
          <label class="label">설교 스타일<span class="label-hint">클릭하여 선택</span></label>
          <button id="btn-manage-styles" style="font-size: .75rem; padding: .2rem .5rem;">관리</button>
        </div>
        <div id="styles-list"></div>
      </div>

      <!-- 처리 단계 -->
      <div class="box">
        <label class="label">처리 단계<span class="label-hint">클릭 후 대기</span></label>
        <div id="processing-steps"></div>
      </div>

      <!-- 전체 복사 + GPT PRO 버튼 -->
      <div style="margin-bottom: .75rem;">
        <div class="box copy-all-box" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; padding: .85rem; margin-bottom: .75rem;">
          <div class="box-title" style="font-size: .95rem; margin-bottom: .4rem; color: white; font-weight: 700;">📋 개인 GPT-PRO 사용</div>
          <div class="box-desc" style="font-size: .8rem; margin-bottom: .6rem; color: rgba(255,255,255,0.95);">아래 버튼을 클릭 후 사용하시는 GPT에 붙여넣기 해주세요.</div>
          <button id="btn-copy-all" style="width: 100%; padding: .6rem; font-size: .9rem; background: white; color: #667eea; font-weight: 700; border: none; border-radius: 6px; cursor: pointer;">전체 복사</button>
        </div>
        <div class="box gpt-pro-box" style="background: linear-gradient(135deg, #f5576c 0%, #f093fb 100%); border: none; padding: .85rem;">
          <div class="box-title" style="font-size: .95rem; margin-bottom: .4rem; color: white; font-weight: 700;">🚀 GPT 최신 버전 이용</div>
          <div class="box-desc" style="font-size: .8rem; margin-bottom: .6rem; color: rgba(255,255,255,0.95);">아래 버튼을 클릭 하시면 유료버전 GPT를 이용해서 설교문을 요청합니다.</div>
          <button id="btn-gpt-pro" style="width: 100%; padding: .6rem; font-size: .9rem; background: white; color: #f5576c; font-weight: 700; border: none; border-radius: 6px; cursor: pointer;">설교문 작성</button>
        </div>
      </div>

      <!-- 저장 공간 -->
      <div class="box">
        <label class="label">저장된 설교 자료</label>
        <button id="btn-save" style="width: 100%; margin-bottom: .5rem;">현재 내용 저장</button>
        <div id="saved-list"></div>
      </div>

      <!-- 카카오톡 문의 -->
      <div class="box" style="background: linear-gradient(135deg, #FEE500 0%, #FFEB3B 100%); border: none; text-align: center; padding: 1rem;">
        <div style="font-size: .9rem; font-weight: 600; color: #3C1E1E; margin-bottom: .75rem;">
          💬 문의 및 궁금사항
        </div>
        <a href="https://open.kakao.com/o/sfFpe12h" target="_blank" rel="noopener noreferrer"
           style="display: inline-block; background: #3C1E1E; color: #FEE500; padding: .65rem 1.5rem; border-radius: 8px; text-decoration: none; font-weight: 600; font-size: .9rem; transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(0,0,0,0.15);"
           onmouseover="this.style.background='#2C1414'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.25)';"
           onmouseout="this.style.background='#3C1E1E'; this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.15)';">
          💬 카카오톡 문의하기
        </a>
        <div style="font-size: .7rem; color: #6D4C41; margin-top: .75rem; opacity: 0.9;">
          📱 BIBLE LAB 오픈채팅방
        </div>
      </div>

    </div>

    <!-- 오른쪽 -->
    <div class="right-col">
      <!-- Top 영역: 지침 -->
      <div class="top-section">
      <!-- 상태 표시 -->
      <div id="status-bar" class="status-bar">작업 중...</div>

      <!-- 관리자 공간 -->
        <div class="box" id="guide-box">
          <div style="text-align: center;">
            <div style="font-size: .85rem; color: #666; margin-bottom: .5rem; font-weight: 600;">관리자 공간 🔒</div>
            <button id="toggle-guides" class="primary" style="width: 100%;">관리자 공간 열기</button>
          </div>
        </div>
      </div>
      <!-- Top 영역 끝 -->

      <!-- Content 영역: 처리 결과 + Q&A -->
      <div class="content-section">
        <!-- 처리 단계 + Q&A 영역 (50:50 분할) -->
        <div class="processing-qa-container">
        <!-- 왼쪽: 처리 단계 결과 -->
        <div class="processing-steps-panel">
          <!-- 업데이트 내역 안내 -->
          <div id="update-notice" class="box" style="background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); border: none;">
            <div style="text-align: center; margin-bottom: 1rem;">
              <h3 style="margin: 0 0 .5rem 0; color: #667eea; font-size: 1.2rem;">📢 최근 업데이트</h3>
              <p style="margin: 0; font-size: .85rem; color: #666;">BIBLE LAB의 새로운 기능들을 확인해보세요</p>
            </div>

            <div style="background: white; border-radius: 8px; padding: 1rem;">
              <div style="margin-bottom: .75rem; padding: .6rem; border-left: 3px solid #667eea; background: #f8f9ff;">
                <div style="font-weight: 600; color: #667eea; margin-bottom: .25rem;">2025-11-19</div>
                <div style="font-size: .9rem; color: #333;">✨ UI 디자인 개선 및 사용자 가이드 추가</div>
              </div>

              <div style="margin-bottom: .75rem; padding: .6rem; border-left: 3px solid #4a90e2; background: #f0f8ff;">
                <div style="font-weight: 600; color: #4a90e2; margin-bottom: .25rem;">2025-11-19</div>
                <div style="font-size: .9rem; color: #333;">📱 모바일 UI 최적화 (Top/Content 영역 분리)</div>
              </div>

              <div style="margin-bottom: .75rem; padding: .6rem; border-left: 3px solid #f5576c; background: #fff5f7;">
                <div style="font-weight: 600; color: #f5576c; margin-bottom: .25rem;">2025-11-19</div>
                <div style="font-size: .9rem; color: #333;">💾 데이터 백업 및 복원 기능 추가</div>
              </div>

              <div style="padding: .6rem; border-left: 3px solid #4caf50; background: #f1f8f4;">
                <div style="font-weight: 600; color: #4caf50; margin-bottom: .25rem;">2025-11-19</div>
                <div style="font-size: .9rem; color: #333;">💬 Q&A 대화 기능 추가</div>
              </div>
            </div>

            <div style="text-align: center; margin-top: 1rem; padding-top: .75rem; border-top: 1px solid rgba(255,255,255,0.5);">
              <p style="margin: 0; font-size: .8rem; color: #777;">왼쪽에서 카테고리를 선택하고 설교스타일을 정하세요! 🚀</p>
            </div>
          </div>

          <div id="result-boxes"></div>
        </div>

        <!-- 오른쪽: Q&A 인터페이스 -->
        <div class="qa-panel">
          <div class="qa-interface">
            <div class="qa-prompt">검색된 결과에 대해 간단한 질문을 해주세요.</div>
            <div class="qa-history" id="qa-history">
              <div class="qa-empty-state">아직 질문이 없습니다.<br>처리 단계 결과나 본문에 대해 궁금한 점을 물어보세요.</div>
            </div>
            <div class="qa-input-area">
              <textarea id="qa-input" placeholder="질문을 입력하세요. (분석된 내용에 대해서 질문 하시면, 추가 답변을 드립니다.)"></textarea>
              <button id="btn-send-qa" class="primary">전송</button>
            </div>
          </div>
        </div>
      </div>

        <!-- GPT PRO (Step3) 결과 박스 -->
        <div id="gpt-pro-result-container" style="display: none;">
          <div class="gpt-pro-result-box">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .5rem;">
              <div class="label" style="margin: 0;">🎯 Step3. 설교문 완성</div>
              <span id="usage-step3" style="font-size: .75rem; color: rgba(255,255,255,0.9);"></span>
            </div>
            <textarea id="gpt-pro-result" class="autosize" readonly placeholder="Step3 처리 결과가 여기에 표시됩니다."></textarea>
            <button id="btn-copy-gpt-pro" style="margin-top: .5rem; width: 100%; background: white; color: #f5576c; font-weight: 600;">📋 완성본 복사</button>
          </div>
        </div>
      </div>
      <!-- Content 영역 끝 -->
    </div>
  </div>

  <!-- 패스워드 모달 -->
  <div id="modal-password" class="modal">
    <div class="modal-content">
      <div class="modal-title">🔒 관리자 공간 잠금</div>
      <p style="color: #666; font-size: .9rem; margin-bottom: 1rem;">관리자 공간에 접근하려면 패스워드를 입력하세요.</p>
      <input type="password" id="password-input" placeholder="패스워드 입력" style="margin-bottom: .5rem;">
      <div class="modal-buttons">
        <button id="btn-cancel-password">취소</button>
        <button id="btn-submit-password" class="primary">확인</button>
      </div>
    </div>
  </div>

  <!-- 관리자 공간 모달 -->
  <div id="modal-admin-panel" class="modal">
    <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <div class="modal-title" style="margin: 0;">🔒 관리자 공간</div>
        <button id="btn-close-admin-panel" style="background: transparent; border: none; font-size: 1.5rem; cursor: pointer; padding: 0; color: #999;">&times;</button>
      </div>

      <div id="guide-content">
        <!-- AI 모델 설정 (제일 위로) -->
        <div style="margin-bottom: 1.5rem;">
          <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: .6rem 1rem; border-radius: 8px 8px 0 0; font-weight: 700; font-size: 1rem;">🤖 AI 모델 설정</div>
          <div style="background: #f8f5ff; padding: 1rem; border-radius: 0 0 8px 8px; border: 2px solid #667eea; border-top: none;">
            <div style="font-size: .85rem; color: #666; margin-bottom: 1rem;">
              각 단계에서 사용할 AI 모델을 선택하세요. 비용 차이는 기준 모델 대비 %입니다.
            </div>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; margin-bottom: 1rem;">
              <!-- Step1 모델 -->
              <div style="background: white; padding: .75rem; border-radius: 8px; border: 2px solid #ff6b6b;">
                <label style="font-weight: 700; font-size: .9rem; color: #ff6b6b; display: block; margin-bottom: .4rem;">Step1 (본문 연구)</label>
                <select id="model-step1" style="width: 100%; padding: .4rem; border-radius: 4px; border: 1px solid #ddd; font-size: .85rem;">
                  <option value="gpt-4o">GPT-4o (기준)</option>
                  <option value="gpt-4o-mini">GPT-4o Mini (-94% 저렴)</option>
                  <option value="gpt-5">GPT-5 (+100%)</option>
                  <option value="gpt-5.1">GPT-5.1 (+200%)</option>
                </select>
                <div style="font-size: .7rem; color: #999; margin-top: .3rem;">기준: GPT-4o</div>
              </div>
              <!-- Step2 모델 -->
              <div style="background: white; padding: .75rem; border-radius: 8px; border: 2px solid #4ecdc4;">
                <label style="font-weight: 700; font-size: .9rem; color: #4ecdc4; display: block; margin-bottom: .4rem;">Step2 (설교 구조)</label>
                <select id="model-step2" style="width: 100%; padding: .4rem; border-radius: 4px; border: 1px solid #ddd; font-size: .85rem;">
                  <option value="gpt-4o">GPT-4o (기준)</option>
                  <option value="gpt-4o-mini">GPT-4o Mini (-94% 저렴)</option>
                  <option value="gpt-5">GPT-5 (+100%)</option>
                  <option value="gpt-5.1">GPT-5.1 (+200%)</option>
                </select>
                <div style="font-size: .7rem; color: #999; margin-top: .3rem;">기준: GPT-4o</div>
              </div>
              <!-- Step3 (설교문 작성) 모델 -->
              <div style="background: white; padding: .75rem; border-radius: 8px; border: 2px solid #f5576c;">
                <label style="font-weight: 700; font-size: .9rem; color: #f5576c; display: block; margin-bottom: .4rem;">Step3 (설교문 작성)</label>
                <select id="model-gpt-pro" style="width: 100%; padding: .4rem; border-radius: 4px; border: 1px solid #ddd; font-size: .85rem;">
                  <option value="gpt-5">GPT-5 (기준)</option>
                  <option value="gpt-4o">GPT-4o (-50% 저렴)</option>
                  <option value="gpt-5.1">GPT-5.1 (+50%)</option>
                </select>
                <div style="font-size: .7rem; color: #999; margin-top: .3rem;">기준: GPT-5</div>
              </div>
            </div>
            <!-- Step3 토큰량 설정 -->
            <div style="background: white; padding: .75rem; border-radius: 8px; border: 1px solid #e0e0e0; margin-bottom: .5rem;">
              <label style="font-weight: 600; font-size: .85rem; color: #f5576c; display: block; margin-bottom: .4rem;">Step3 최대 토큰량</label>
              <div style="display: flex; gap: .5rem; align-items: center;">
                <input type="number" id="step3-max-tokens" value="16000" min="1000" max="32000" step="1000" style="width: 120px; padding: .4rem; border-radius: 4px; border: 1px solid #ddd; font-size: .85rem;">
                <span style="font-size: .8rem; color: #666;">토큰 (기본: 16000, 최대: 32000)</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Step3 지침 수정 -->
        <div style="margin-bottom: 1.5rem;">
          <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: .6rem 1rem; border-radius: 8px 8px 0 0; font-weight: 700; font-size: 1rem;">📝 Step3 지침 (설교문 작성)</div>
          <div style="background: #fff5f8; padding: 1rem; border-radius: 0 0 8px 8px; border: 2px solid #f5576c; border-top: none;">
            <div style="font-size: .85rem; color: #666; margin-bottom: .75rem;">
              설교문 작성 시 AI에게 전달되는 시스템 지침입니다. 직접 수정하여 원하는 스타일로 설교문을 생성할 수 있습니다.
            </div>
            <textarea id="step3-system-prompt" style="width: 100%; min-height: 200px; padding: .75rem; border-radius: 6px; border: 1px solid #ddd; font-size: .85rem; line-height: 1.5; resize: vertical;" placeholder="Step3 시스템 지침..."></textarea>
            <div class="btn-row" style="margin-top: .75rem; gap: .5rem;">
              <button id="btn-save-step3-prompt" class="primary" style="flex: 1;">Step3 지침 저장</button>
              <button id="btn-reset-step3-prompt" style="flex: 1;">기본값 복원</button>
            </div>
          </div>
        </div>

        <!-- 처리 단계 지침 -->
        <div style="margin-bottom: 1.5rem;">
          <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: .6rem 1rem; border-radius: 8px 8px 0 0; font-weight: 700; font-size: 1rem;">📋 처리 단계 지침</div>
          <div style="background: #f8f5ff; padding: 1rem; border-radius: 0 0 8px 8px; border: 2px solid #667eea; border-top: none;">
            <div class="btn-row" style="margin-bottom: .5rem;">
              <button id="save-guide" class="primary">지침 저장</button>
            </div>
            <div id="guide-tabs" class="btn-row" style="margin-bottom: .5rem;"></div>
            <div id="current-guide-info" style="font-size: .85rem; color: #666; margin-bottom: .5rem;"></div>
            <textarea id="guide-text" class="autosize" style="min-height: 120px;" placeholder="이 처리 단계의 구체적인 지침을 작성하세요."></textarea>
          </div>
        </div>

        <!-- Step3 사용 코드 관리 -->
        <div style="margin-bottom: 1.5rem;">
          <div style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: white; padding: .6rem 1rem; border-radius: 8px 8px 0 0; font-weight: 700; font-size: 1rem;">🔑 Step3 사용 코드 관리</div>
          <div style="background: #fffbf0; padding: 1rem; border-radius: 0 0 8px 8px; border: 2px solid #f39c12; border-top: none;">
            <div style="font-size: .85rem; color: #666; margin-bottom: 1rem;">
              테스터에게 배포할 1회용 코드를 생성하고 관리합니다. 코드당 사용 횟수를 지정할 수 있습니다.
            </div>
            <!-- 새 코드 생성 -->
            <div style="background: white; padding: .75rem; border-radius: 8px; border: 1px solid #ffe0b2; margin-bottom: 1rem;">
              <div style="font-weight: 600; font-size: .9rem; color: #e67e22; margin-bottom: .5rem;">새 코드 생성</div>
              <div style="display: flex; gap: .5rem; align-items: center; flex-wrap: wrap;">
                <input type="text" id="new-code-name" placeholder="코드명 (비우면 자동생성)" style="flex: 1; min-width: 150px; padding: .4rem; border-radius: 4px; border: 1px solid #ddd; font-size: .85rem;">
                <div style="display: flex; align-items: center; gap: .3rem;">
                  <label style="font-size: .85rem; color: #666;">횟수:</label>
                  <input type="number" id="new-code-limit" value="3" min="1" max="100" style="width: 60px; padding: .4rem; border-radius: 4px; border: 1px solid #ddd; font-size: .85rem; text-align: center;">
                </div>
                <button id="btn-create-code" style="padding: .4rem .8rem; background: #f39c12; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: .85rem; font-weight: 600;">생성</button>
              </div>
            </div>
            <!-- 코드 목록 -->
            <div style="font-weight: 600; font-size: .9rem; color: #e67e22; margin-bottom: .5rem;">코드 목록</div>
            <div id="code-list-container" style="max-height: 200px; overflow-y: auto; background: white; border-radius: 8px; border: 1px solid #ffe0b2;">
              <table style="width: 100%; border-collapse: collapse; font-size: .85rem;">
                <thead>
                  <tr style="background: #fff8e1; position: sticky; top: 0;">
                    <th style="padding: .5rem; text-align: left; border-bottom: 1px solid #ffe0b2;">코드</th>
                    <th style="padding: .5rem; text-align: center; border-bottom: 1px solid #ffe0b2;">남은횟수</th>
                    <th style="padding: .5rem; text-align: center; border-bottom: 1px solid #ffe0b2;">상태</th>
                    <th style="padding: .5rem; text-align: center; border-bottom: 1px solid #ffe0b2;">관리</th>
                  </tr>
                </thead>
                <tbody id="code-list-body">
                  <tr><td colspan="4" style="padding: 1rem; text-align: center; color: #999;">로딩 중...</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <!-- 백업/복원 버튼 -->
        <div style="margin-bottom: 1rem;">
          <div style="background: #f8f9fa; padding: .75rem 1rem; border-radius: 8px; border: 1px solid #e0e0e0;">
            <div style="font-size: .85rem; color: #666; margin-bottom: .5rem; font-weight: 600;">💾 데이터 백업</div>
            <div class="btn-row" style="gap: .5rem;">
              <button id="btn-export-backup" style="flex: 1; font-size: .85rem;">백업 다운로드</button>
              <button id="btn-import-backup" style="flex: 1; font-size: .85rem;">백업 복원</button>
            </div>
            <input type="file" id="backup-file-input" accept=".json" style="display: none;">
            <div style="font-size: .75rem; color: #999; margin-top: .5rem;">
              정기적으로 백업 파일을 다운로드하여 안전한 곳에 보관하세요.
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- 사용 가이드 모달 -->
  <div id="modal-guide" class="modal">
    <div class="modal-content" style="max-width: 500px; max-height: 80vh; overflow-y: auto;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <div class="modal-title" style="margin: 0;">📖 사용 가이드</div>
        <button id="btn-close-guide-x" style="background: transparent; border: none; font-size: 1.5rem; cursor: pointer; padding: 0; color: #999;">&times;</button>
      </div>

      <div style="color: #555; font-size: .85rem; line-height: 1.5;">
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; text-align: center;">
          <strong style="font-size: 1.05rem;">🎉 BIBLE LAB에 오신 것을 환영합니다!</strong><br>
          <span style="font-size: .8rem; opacity: 0.9;">현재 테스트 진행 중입니다</span>
        </div>

        <div style="background: #f0f4ff; padding: .65rem; border-radius: 6px; margin-bottom: .6rem; border-left: 3px solid #667eea;">
          <strong style="color: #667eea;">1. 카테고리 선택</strong><br>
          <span style="font-size: .8rem;">원하는 기능 선택 후 성경구절 입력 (예: 창1:1-10 또는 창세기 1장 1~10절)</span>
        </div>

        <div style="background: #f0f4ff; padding: .65rem; border-radius: 6px; margin-bottom: .6rem; border-left: 3px solid #667eea;">
          <strong style="color: #667eea;">2. 제목 및 성경구절</strong><br>
          <span style="font-size: .8rem;">선택사항이므로 꼭 기입하지 않아도 됩니다</span>
        </div>

        <div style="background: #f0f4ff; padding: .65rem; border-radius: 6px; margin-bottom: .6rem; border-left: 3px solid #667eea;">
          <strong style="color: #667eea;">3. 설교스타일 선택</strong><br>
          <span style="font-size: .8rem;">스타일을 선택하면 처리단계가 나타납니다</span>
        </div>

        <div style="background: #f0f4ff; padding: .65rem; border-radius: 6px; margin-bottom: .6rem; border-left: 3px solid #667eea;">
          <strong style="color: #667eea;">4. 처리 실행</strong><br>
          <span style="font-size: .8rem;">각 단계를 클릭하면 AI가 수행합니다 (5-10초 소요)</span>
        </div>

        <div style="background: #f0f4ff; padding: .65rem; border-radius: 6px; margin-bottom: .6rem; border-left: 3px solid #667eea;">
          <strong style="color: #667eea;">5. 결과 확인</strong><br>
          <span style="font-size: .8rem;">전체 복사 또는 홈페이지에서 완성형 설교문 출력 가능</span>
        </div>

        <div style="background: #fff9e6; padding: .65rem; border-radius: 6px; margin-bottom: .6rem; border-left: 3px solid #ffc107;">
          <strong style="color: #f57c00;">📋 보라색 버튼</strong><br>
          <span style="font-size: .8rem;">개인 GPT 유료버전에 붙여넣기하여 설교문 작성</span>
        </div>

        <div style="background: #ffe6f0; padding: .65rem; border-radius: 6px; margin-bottom: .6rem; border-left: 3px solid #f5576c;">
          <strong style="color: #c2185b;">🚀 분홍색 버튼</strong><br>
          <span style="font-size: .8rem;">페이지 내에서 완성형 설교문 출력 (유료 기능 준비 중)</span>
        </div>

        <div style="background: #e8f5e9; padding: .65rem; border-radius: 6px; border-left: 3px solid #4caf50;">
          <strong style="color: #2e7d32;">💡 TIP</strong><br>
          <span style="font-size: .8rem;">Q&A를 통해 더 자세한 질문을 하실 수 있습니다</span>
        </div>
      </div>

      <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e0e0e0;">
        <label style="display: flex; align-items: center; gap: .5rem; cursor: pointer; font-size: .85rem;">
          <input type="checkbox" id="dont-show-week" style="width: 16px; height: 16px; cursor: pointer;">
          <span>일주일간 보지 않기</span>
        </label>
      </div>

      <div class="modal-buttons" style="margin-top: 1rem;">
        <button id="btn-close-guide" class="primary" style="flex: 1;">시작하기</button>
      </div>
    </div>
  </div>

  <!-- GPT PRO 패스워드 모달 -->
  <div id="modal-gpt-pro-password" class="modal">
    <div class="modal-content">
      <div class="modal-title">🔒 GPT PRO 실행 (테스트 중)</div>
      <p style="color: #666; font-size: .9rem; margin-bottom: 1rem;">이 기능은 현재 테스트 중입니다. 패스워드를 입력하세요.</p>
      <input type="password" id="gpt-pro-password-input" placeholder="패스워드 입력" style="margin-bottom: .5rem;">
      <div class="modal-buttons">
        <button id="btn-cancel-gpt-pro-password">취소</button>
        <button id="btn-submit-gpt-pro-password" class="primary">확인</button>
      </div>
    </div>
  </div>

  <!-- 관리 기능 패스워드 모달 -->
  <div id="modal-manage-password" class="modal">
    <div class="modal-content">
      <div class="modal-title">🔒 관리 기능 잠금</div>
      <p style="color: #666; font-size: .9rem; margin-bottom: 1rem;">카테고리 및 스타일 관리는 관리자만 사용할 수 있습니다. 패스워드를 입력하세요.</p>
      <input type="password" id="manage-password-input" placeholder="패스워드 입력" style="margin-bottom: .5rem;">
      <div class="modal-buttons">
        <button id="btn-cancel-manage-password">취소</button>
        <button id="btn-submit-manage-password" class="primary">확인</button>
      </div>
    </div>
  </div>

  <!-- 카테고리 관리 모달 -->
  <div id="modal-categories" class="modal">
    <div class="modal-content">
      <div class="modal-title">카테고리 관리</div>
      <input type="text" id="new-cat-label" placeholder="표시 이름 (예: 특별예배)" style="margin-bottom: .5rem;">
      <button id="btn-add-category" class="primary" style="width: 100%; margin-bottom: 1rem;">추가</button>
      <div id="categories-list" style="max-height: 300px; overflow-y: auto;"></div>
      <div class="modal-buttons">
        <button id="btn-close-categories">닫기</button>
      </div>
    </div>
  </div>

  <!-- 스타일 관리 모달 -->
  <div id="modal-styles" class="modal">
    <div class="modal-content">
      <div class="modal-title">설교 스타일 관리</div>
      <p style="font-size: .85rem; color: #666; margin-bottom: .5rem;">카테고리: <strong id="modal-styles-category"></strong></p>

      <input type="text" id="new-style-name" placeholder="스타일 이름 (예: 새벽예배 - 강해설교)" style="margin-bottom: .3rem;">
      <input type="text" id="new-style-desc" placeholder="설명 (예: 본론 중심, 아이스브래이킹 제외)" style="margin-bottom: .5rem;">
      <button id="btn-add-style" class="primary" style="width: 100%; margin-bottom: 1rem;">추가</button>

      <div id="styles-manage-list" style="max-height: 300px; overflow-y: auto;"></div>
      <div class="modal-buttons">
        <button id="btn-close-styles">닫기</button>
      </div>
    </div>
  </div>

  <!-- 처리 단계 관리 모달 -->
  <div id="modal-steps" class="modal">
    <div class="modal-content">
      <div class="modal-title">처리 단계 관리</div>
      <p style="font-size: .85rem; color: #666; margin-bottom: .5rem;">
        스타일: <strong id="modal-steps-style"></strong>
      </p>
      <input type="text" id="new-step-name" placeholder="단계 이름 (예: 제목 추천, 본문 분석, 개요 작성)" style="margin-bottom: .5rem;">
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: .5rem; margin-bottom: 1rem;">
        <button id="btn-add-step1" class="primary" style="background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%); border: none; box-shadow: 0 3px 10px rgba(255,107,107,.3);">➕ Step1 추가</button>
        <button id="btn-add-step2" class="primary" style="background: linear-gradient(135deg, #4ecdc4 0%, #44a3c2 100%); border: none; box-shadow: 0 3px 10px rgba(78,205,196,.3);">➕ Step2 추가</button>
      </div>
      <div id="steps-list" style="max-height: 300px; overflow-y: auto;"></div>
      <div class="modal-buttons">
        <button id="btn-close-steps">닫기</button>
      </div>
    </div>
  </div>

  <!-- GPT 작업 중 로딩 오버레이 -->
  <div id="gpt-loading-overlay" style="display: none;">
    <div class="gpt-loading-content">
      <div class="gpt-loading-spinner"></div>
      <div class="gpt-loading-text">BIBLE LAB을 이용해 주셔서 감사합니다</div>
      <div class="gpt-loading-subtext">잠시만 기다려주세요</div>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

  <script>
  // ===== Firebase 초기화 =====
  const firebaseConfig = {
    apiKey: "AIzaSyBacmJDk-PG5FaoqnXV8Rg3P__AKOS2vu4",
    authDomain: "my-sermon-guides.firebaseapp.com",
    projectId: "my-sermon-guides",
    storageBucket: "my-sermon-guides.firebasestorage.app",
    messagingSenderId: "539520456089",
    appId: "1:539520456089:web:d6aceb7838baa89e70af08",
    measurementId: "G-KWN8TH7Z26"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();

  const USER_CODE = 'samuel123';
  const PAGE_NAME = 'sermon';
  const GUIDE_PASSWORD = '5555';
  const GPT_PRO_PASSWORD = '6039';
  const MANAGE_PASSWORD = '6039';
  const CONFIG_KEY = '_sermon-config';

  // ===== 전역 변수 =====
  let guideUnlocked = false;
  let gptProUnlocked = false;
  let manageUnlocked = false;
  let pendingManageAction = null; // 'categories' or 'styles'
  let currentCategory = 'general';
  let currentStyleId = '';
  let currentGuideStep = '';
  let stepResults = {};
  let titleOptions = []; // 제목 후보 저장
  let selectedTitle = ''; // 선택된 제목 저장

  // 기본 설정
  let config = {
    categories: [
      {value: "general", label: "일반 설교"},
      {value: "series", label: "시리즈 설교"},
      {value: "education", label: "교육"},
      {value: "lecture", label: "강의"}
    ],
    categorySettings: {
      general: {
        masterGuide: "",
        styles: [
          {
            id: "dawn_expository",
            name: "새벽예배 - 강해설교",
            description: "본론 중심",
            steps: [
              {id: "title", name: "제목 추천", order: 1},
              {id: "analysis", name: "본문 분석", order: 2},
              {id: "outline", name: "개요 작성", order: 3}
            ]
          },
          {
            id: "sunday_topical",
            name: "주일예배 - 주제설교",
            description: "주제 중심",
            steps: [
              {id: "title", name: "제목 추천", order: 1},
              {id: "analysis", name: "본문 분석", order: 2},
              {id: "outline", name: "개요 작성", order: 3}
            ]
          }
        ]
      },
      series: {
        masterGuide: "",
        styles: [
          {
            id: "series_continuous",
            name: "수요예배 - 연속강해",
            description: "시리즈형 강해",
            steps: [
              {id: "title", name: "제목 추천", order: 1},
              {id: "analysis", name: "본문 분석", order: 2},
              {id: "outline", name: "개요 작성", order: 3}
            ]
          }
        ]
      },
      education: {
        masterGuide: "",
        styles: []
      },
      lecture: {
        masterGuide: "",
        styles: []
      }
    }
  };

  // ===== 한글 → 영문 ID 자동 생성 =====
  function koreanToId(korean) {
    const map = {
      '제목': 'title',
      '아이스브래이킹': 'icebreaking',
      '서론': 'intro',
      '본론': 'body',
      '결론': 'conclusion',
      '본문': 'analysis',
      '분석': 'analysis',
      '신학': 'theology',
      '해석': 'interpretation',
      '예화': 'illustration',
      '적용': 'application',
      '실천': 'practice',
      '과제': 'task',
      '질문': 'questions',
      '토론': 'discussion',
      '기도': 'prayer',
      '개요': 'outline'
    };

    for (const [key, value] of Object.entries(map)) {
      if (korean.includes(key)) {
        return value + '_' + Date.now().toString(36);
      }
    }

    return 'step_' + Date.now().toString(36);
  }

  // ===== 유틸리티 =====
  function showStatus(msg) {
    const statusBar = document.getElementById('status-bar');
    if (statusBar) {
      statusBar.textContent = msg;
      statusBar.style.display = 'block';
    }
  }

  // ===== GPT 로딩 오버레이 =====
  function showGptLoading() {
    const overlay = document.getElementById('gpt-loading-overlay');
    if (overlay) {
      overlay.style.display = 'flex';
    }
  }

  function hideGptLoading() {
    const overlay = document.getElementById('gpt-loading-overlay');
    if (overlay) {
      overlay.style.display = 'none';
    }
  }

  // ===== 모델별 가격 정보 (1M 토큰당 USD) =====
  const modelPricing = {
    'gpt-4o-mini': { input: 0.15, output: 0.60 },
    'gpt-4o': { input: 2.50, output: 10.00 },
    'gpt-5': { input: 5.00, output: 20.00 },
    'gpt-5.1': { input: 7.50, output: 30.00 }
  };

  // 비용 계산 함수 (원화, 소수점 1자리)
  function calculateCost(modelId, inputTokens, outputTokens) {
    const pricing = modelPricing[modelId];
    if (!pricing) return null;
    const inputCost = (inputTokens / 1000000) * pricing.input;
    const outputCost = (outputTokens / 1000000) * pricing.output;
    const totalUSD = inputCost + outputCost;
    const totalKRW = (totalUSD * 1400).toFixed(1); // 원화 환산, 소수점 1자리
    return {
      inputCost: inputCost.toFixed(6),
      outputCost: outputCost.toFixed(6),
      totalCost: totalUSD.toFixed(6),
      totalCostKRW: totalKRW
    };
  }

  // Step3 기본 시스템 프롬프트
  const DEFAULT_STEP3_PROMPT = `당신은 한국어 설교 전문가입니다.
자료는 참고용으로만 활용하고 문장은 처음부터 새로 구성하며,
묵직하고 명료한 어조로 신학적 통찰과 실제적 적용을 균형 있게 제시하세요.
마크다운 기호 대신 순수 텍스트만 사용합니다.

Step2의 설교 구조를 반드시 따라 작성하세요:
- Step2에서 제시한 서론, 본론, 결론 구조를 그대로 사용
- Step2의 대지(포인트) 구성을 유지
- 각 섹션의 핵심 메시지를 확장하여 풍성하게 작성

⚠️ 중요: 충분히 길고 상세하며 풍성한 내용으로 작성해주세요.`;

  // ===== 모델 설정 관리 =====
  function getModelSettings(category) {
    const settings = config.categorySettings[category];
    if (!settings.modelSettings) {
      settings.modelSettings = {
        step1: 'gpt-4o',
        step2: 'gpt-4o',
        gptPro: 'gpt-5',
        step3MaxTokens: 16000,
        step3Prompt: DEFAULT_STEP3_PROMPT
      };
    }
    // 기존 설정에 새 필드가 없으면 추가
    if (!settings.modelSettings.step3MaxTokens) {
      settings.modelSettings.step3MaxTokens = 16000;
    }
    if (!settings.modelSettings.step3Prompt) {
      settings.modelSettings.step3Prompt = DEFAULT_STEP3_PROMPT;
    }
    return settings.modelSettings;
  }

  function loadModelSettings() {
    const modelSettings = getModelSettings(currentCategory);
    const step1Select = document.getElementById('model-step1');
    const step2Select = document.getElementById('model-step2');
    const gptProSelect = document.getElementById('model-gpt-pro');
    const step3MaxTokensInput = document.getElementById('step3-max-tokens');
    const step3PromptTextarea = document.getElementById('step3-system-prompt');

    if (step1Select) step1Select.value = modelSettings.step1;
    if (step2Select) step2Select.value = modelSettings.step2;
    if (gptProSelect) gptProSelect.value = modelSettings.gptPro;
    if (step3MaxTokensInput) step3MaxTokensInput.value = modelSettings.step3MaxTokens;
    if (step3PromptTextarea) step3PromptTextarea.value = modelSettings.step3Prompt;
  }

  async function saveModelSettings() {
    const step1Select = document.getElementById('model-step1');
    const step2Select = document.getElementById('model-step2');
    const gptProSelect = document.getElementById('model-gpt-pro');
    const step3MaxTokensInput = document.getElementById('step3-max-tokens');

    const modelSettings = getModelSettings(currentCategory);
    modelSettings.step1 = step1Select ? step1Select.value : 'gpt-4o';
    modelSettings.step2 = step2Select ? step2Select.value : 'gpt-4o';
    modelSettings.gptPro = gptProSelect ? gptProSelect.value : 'gpt-5';
    modelSettings.step3MaxTokens = step3MaxTokensInput ? parseInt(step3MaxTokensInput.value) || 16000 : 16000;

    await saveConfig();
  }

  async function saveStep3Prompt() {
    const step3PromptTextarea = document.getElementById('step3-system-prompt');
    if (!step3PromptTextarea) return;

    const modelSettings = getModelSettings(currentCategory);
    modelSettings.step3Prompt = step3PromptTextarea.value;
    await saveConfig();
    showStatus('✅ Step3 지침 저장됨');
    setTimeout(hideStatus, 2000);
  }

  function resetStep3Prompt() {
    const step3PromptTextarea = document.getElementById('step3-system-prompt');
    if (step3PromptTextarea) {
      step3PromptTextarea.value = DEFAULT_STEP3_PROMPT;
    }
  }

  function hideStatus() {
    const statusBar = document.getElementById('status-bar');
    if (statusBar) {
      statusBar.style.display = 'none';
    }
  }

  function autoResize(el) {
    if (!el) return;
    el.style.height = 'auto';
    el.style.height = el.scrollHeight + 'px';
  }

  // ===== Firebase 함수 (재시도 로직 포함) =====
  async function loadFromFirebase() {
    try {
      const snapshot = await db.collection('users').doc(USER_CODE).collection(PAGE_NAME).get();

      if (!snapshot.empty) {
        snapshot.forEach(doc => {
          localStorage.setItem(doc.id, doc.data().value);
        });

        const configData = localStorage.getItem(CONFIG_KEY);
        if (configData) {
          config = JSON.parse(configData);
        }
        console.log('✅ Firebase 동기화 완료');
        return true;
      }
      return false;
    } catch (err) {
      console.error('Firebase 로드 실패:', err);
      return false;
    }
  }

  async function saveToFirebase(key, value, retries = 0) {
    const MAX_RETRIES = 4;
    const RETRY_DELAYS = [2000, 4000, 8000, 16000]; // exponential backoff

    try {
      await db.collection('users').doc(USER_CODE).collection(PAGE_NAME).doc(key).set({
        value: value,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      });
      return true;
    } catch (err) {
      console.error(`Firebase 저장 실패 (시도 ${retries + 1}/${MAX_RETRIES + 1}):`, err);

      // 네트워크 오류인 경우에만 재시도
      const isNetworkError = err.code === 'unavailable' || err.code === 'deadline-exceeded' ||
                             err.message.includes('network') || err.message.includes('offline');

      if (isNetworkError && retries < MAX_RETRIES) {
        const delay = RETRY_DELAYS[retries];
        console.log(`${delay}ms 후 재시도...`);
        await new Promise(resolve => setTimeout(resolve, delay));
        return saveToFirebase(key, value, retries + 1);
      }

      return false;
    }
  }

  async function saveConfig() {
    const configStr = JSON.stringify(config);
    localStorage.setItem(CONFIG_KEY, configStr);
    const success = await saveToFirebase(CONFIG_KEY, configStr);
    if (!success) {
      console.warn('⚠️ Firebase 저장 실패 - 로컬에만 저장됨');
    }
  }

  // ===== 자동 저장 함수 =====
  let autoSaveTimeout = null;
  const AUTO_SAVE_KEY = '_sermon-autosave';

  async function autoSaveStepResults() {
    // debounce: 마지막 변경 후 2초 뒤에 저장
    if (autoSaveTimeout) {
      clearTimeout(autoSaveTimeout);
    }

    autoSaveTimeout = setTimeout(async () => {
      const autoSaveData = {
        category: currentCategory,
        styleId: currentStyleId,
        stepResults: stepResults,
        titleOptions: titleOptions,
        selectedTitle: selectedTitle,
        timestamp: new Date().toISOString()
      };

      const autoSaveStr = JSON.stringify(autoSaveData);
      localStorage.setItem(AUTO_SAVE_KEY, autoSaveStr);

      const success = await saveToFirebase(AUTO_SAVE_KEY, autoSaveStr);
      if (success) {
        console.log('💾 자동 저장 완료');
      } else {
        console.warn('⚠️ 자동 저장 실패 - 로컬에만 저장됨');
      }
    }, 2000);
  }

  function loadAutoSave() {
    try {
      const autoSaveStr = localStorage.getItem(AUTO_SAVE_KEY);
      if (!autoSaveStr) return false;

      const autoSaveData = JSON.parse(autoSaveStr);

      // 자동 저장된 데이터가 현재 카테고리/스타일과 일치하는지 확인
      if (autoSaveData.category === currentCategory && autoSaveData.styleId === currentStyleId) {
        stepResults = autoSaveData.stepResults || {};
        titleOptions = autoSaveData.titleOptions || [];
        selectedTitle = autoSaveData.selectedTitle || '';

        console.log('✅ 자동 저장된 데이터 복원 완료');
        return true;
      }

      return false;
    } catch (err) {
      console.error('자동 저장 데이터 로드 실패:', err);
      return false;
    }
  }

  // ===== 실시간 동기화 =====
  let realtimeListeners = [];
  let isUpdatingFromRemote = false;

  function setupRealtimeSync() {
    // 기존 리스너 정리
    realtimeListeners.forEach(unsubscribe => unsubscribe());
    realtimeListeners = [];

    // CONFIG_KEY 실시간 동기화
    const configListener = db.collection('users').doc(USER_CODE).collection(PAGE_NAME).doc(CONFIG_KEY)
      .onSnapshot((doc) => {
        if (doc.exists && !isUpdatingFromRemote) {
          const remoteData = doc.data();
          const localTimestamp = localStorage.getItem(`${CONFIG_KEY}_timestamp`) || '0';
          const remoteTimestamp = remoteData.updatedAt?.toMillis().toString() || '0';

          // 원격 데이터가 로컬보다 최신인 경우에만 업데이트
          if (remoteTimestamp > localTimestamp) {
            isUpdatingFromRemote = true;
            localStorage.setItem(CONFIG_KEY, remoteData.value);
            localStorage.setItem(`${CONFIG_KEY}_timestamp`, remoteTimestamp);
            config = JSON.parse(remoteData.value);

            console.log('🔄 설정 동기화: 다른 기기에서 업데이트됨');

            // UI 업데이트
            renderCategories();
            renderStyles();
            renderProcessingSteps();
            renderResultBoxes();
            renderGuideTabs();

            setTimeout(() => {
              isUpdatingFromRemote = false;
            }, 1000);
          }
        }
      }, (error) => {
        console.error('실시간 동기화 오류 (CONFIG):', error);
      });

    realtimeListeners.push(configListener);

    // AUTO_SAVE_KEY 실시간 동기화
    const autoSaveListener = db.collection('users').doc(USER_CODE).collection(PAGE_NAME).doc(AUTO_SAVE_KEY)
      .onSnapshot((doc) => {
        if (doc.exists && !isUpdatingFromRemote) {
          const remoteData = doc.data();
          const localTimestamp = localStorage.getItem(`${AUTO_SAVE_KEY}_timestamp`) || '0';
          const remoteTimestamp = remoteData.updatedAt?.toMillis().toString() || '0';

          // 원격 데이터가 로컬보다 최신인 경우에만 업데이트
          if (remoteTimestamp > localTimestamp) {
            isUpdatingFromRemote = true;
            localStorage.setItem(AUTO_SAVE_KEY, remoteData.value);
            localStorage.setItem(`${AUTO_SAVE_KEY}_timestamp`, remoteTimestamp);

            const autoSaveData = JSON.parse(remoteData.value);

            // 현재 카테고리/스타일과 일치하는 경우에만 적용
            if (autoSaveData.category === currentCategory && autoSaveData.styleId === currentStyleId) {
              stepResults = autoSaveData.stepResults || {};
              titleOptions = autoSaveData.titleOptions || [];
              selectedTitle = autoSaveData.selectedTitle || '';

              console.log('🔄 작업 내용 동기화: 다른 기기에서 업데이트됨');
              renderResultBoxes();
            }

            setTimeout(() => {
              isUpdatingFromRemote = false;
            }, 1000);
          }
        }
      }, (error) => {
        console.error('실시간 동기화 오류 (AUTOSAVE):', error);
      });

    realtimeListeners.push(autoSaveListener);
  }

  // ===== 백업 및 복원 =====
  function exportBackup() {
    try {
      const backupData = {
        version: '1.0',
        exportDate: new Date().toISOString(),
        config: config,
        guides: {},
        savedSermons: JSON.parse(localStorage.getItem('sermon-saved') || '[]')
      };

      // 모든 지침 데이터 백업
      for (const key of Object.keys(localStorage)) {
        if (key.startsWith('guide-')) {
          backupData.guides[key] = localStorage.getItem(key);
        }
      }

      const dataStr = JSON.stringify(backupData, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `sermon-backup-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      showStatus('✅ 백업 다운로드 완료!');
      setTimeout(hideStatus, 2000);
    } catch (err) {
      console.error('백업 실패:', err);
      alert('백업 생성 실패: ' + err.message);
    }
  }

  async function importBackup(file) {
    try {
      const reader = new FileReader();

      reader.onload = async (e) => {
        try {
          const backupData = JSON.parse(e.target.result);

          if (!backupData.version || !backupData.config) {
            throw new Error('유효하지 않은 백업 파일입니다.');
          }

          const confirmed = confirm(
            `백업 복원 시 현재 모든 설정이 덮어쓰여집니다.\n\n` +
            `백업 날짜: ${new Date(backupData.exportDate).toLocaleString('ko-KR')}\n\n` +
            `계속하시겠습니까?`
          );

          if (!confirmed) return;

          showStatus('♻️ 백업 복원 중...');

          // Config 복원
          config = backupData.config;
          await saveConfig();

          // 지침 복원
          if (backupData.guides) {
            for (const [key, value] of Object.entries(backupData.guides)) {
              localStorage.setItem(key, value);
              await saveToFirebase(key, value);
            }
          }

          // 저장된 설교 복원
          if (backupData.savedSermons) {
            localStorage.setItem('sermon-saved', JSON.stringify(backupData.savedSermons));
          }

          showStatus('✅ 백업 복원 완료!');

          // UI 새로고침
          setTimeout(() => {
            location.reload();
          }, 1500);

        } catch (err) {
          console.error('백업 복원 실패:', err);
          alert('백업 복원 실패: ' + err.message);
          hideStatus();
        }
      };

      reader.readAsText(file);
    } catch (err) {
      console.error('파일 읽기 실패:', err);
      alert('파일 읽기 실패: ' + err.message);
    }
  }

  // 백업 이벤트 리스너
  const btnExportBackup = document.getElementById('btn-export-backup');
  if (btnExportBackup) {
    btnExportBackup.addEventListener('click', exportBackup);
  }

  const btnImportBackup = document.getElementById('btn-import-backup');
  const backupFileInput = document.getElementById('backup-file-input');

  if (btnImportBackup && backupFileInput) {
    btnImportBackup.addEventListener('click', () => {
      backupFileInput.click();
    });

    backupFileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        importBackup(file);
      }
      // 같은 파일을 다시 선택할 수 있도록 초기화
      e.target.value = '';
    });
  }

  // ===== 제목 관리 함수 =====
  function getSelectedTitle() {
    // 수동 입력 제목이 있으면 우선
    const manualTitle = document.getElementById('manual-title');
    if (manualTitle && manualTitle.value.trim()) {
      return manualTitle.value.trim();
    }
    // 그렇지 않으면 선택된 제목 반환
    return selectedTitle;
  }

  // ===== 제목 선택 관리 =====
  function displayTitleOptions(titles) {
    titleOptions = titles;
    const container = document.getElementById('title-options');
    const box = document.getElementById('title-selection-box');

    if (!container || !box) return;

    if (titles.length >= 3) {
      container.innerHTML = titles.slice(0, 3).map((title, idx) => `
        <label class="title-option-label">
          <input type="radio" name="selectedTitle" value="${idx}" style="margin-right: .5rem;" ${idx === 0 ? 'checked' : ''}>
          <span>${title}</span>
        </label>
      `).join('');

      // 첫 번째 제목을 기본 선택
      selectedTitle = titles[0];

      // 라디오 버튼 변경 이벤트
      container.querySelectorAll('input[type="radio"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
          selectedTitle = titleOptions[parseInt(e.target.value)];
          console.log('선택된 제목:', selectedTitle);
        });
      });

      box.style.display = 'block';
    }
  }

  // ===== 총괄 지침 관리 =====
  function loadMasterGuide(category) {
    const settings = config.categorySettings[category];
    const textarea = document.getElementById('master-guide-text');
    if (textarea) {
      if (settings && settings.masterGuide) {
        textarea.value = settings.masterGuide;
      } else {
        textarea.value = '';
      }
      autoResize(textarea);
    }
  }

  async function saveMasterGuide() {
    const textarea = document.getElementById('master-guide-text');
    if (!textarea) return;

    const value = textarea.value;
    const settings = config.categorySettings[currentCategory];

    if (settings) {
      settings.masterGuide = value;
      await saveConfig();

      showStatus('✅ 총괄 지침 저장 완료!');
      setTimeout(hideStatus, 2000);
    }
  }

  const saveMasterGuideBtn = document.getElementById('save-master-guide');
  if (saveMasterGuideBtn) {
    saveMasterGuideBtn.addEventListener('click', saveMasterGuide);
  }

  const toggleMasterGuideBtn = document.getElementById('toggle-master-guide');
  if (toggleMasterGuideBtn) {
    toggleMasterGuideBtn.addEventListener('click', () => {
      const content = document.getElementById('master-guide-content');
      const btn = document.getElementById('toggle-master-guide');

      if (content && btn) {
        if (content.style.display === 'none') {
          content.style.display = 'block';
          btn.textContent = '닫기';
          loadMasterGuide(currentCategory);
        } else {
          content.style.display = 'none';
          btn.textContent = '열기';
        }
      }
    });
  }

  // ===== 지침 관리 =====
  function getGuideKey(category, stepId, styleId = currentStyleId) {
    const stylePart = styleId || 'default';
    return `guide-${category}-${stylePart}-${stepId}`;
  }

  function loadGuide(category, stepId) {
    const key = getGuideKey(category, stepId);
    const legacyKey = `guide-${category}-${stepId}`;
    const migrationKey = `guide-migrated-${category}`;
    let stored = localStorage.getItem(key);

    if (!stored) {
      const legacyValue = localStorage.getItem(legacyKey);
      const migrationTarget = localStorage.getItem(migrationKey);

      if (legacyValue && (!migrationTarget || migrationTarget === currentStyleId)) {
        stored = legacyValue;
        // 스타일 단위로 키를 분리하면서 기존 데이터를 현재 스타일로 승격
        localStorage.setItem(key, stored);
        saveToFirebase(key, stored);

        if (!migrationTarget) {
          const targetStyle = currentStyleId || 'default';
          localStorage.setItem(migrationKey, targetStyle);
          saveToFirebase(migrationKey, targetStyle);
        }
      }
    }

    stored = stored || '';
    const textarea = document.getElementById('guide-text');
    if (textarea) {
      textarea.value = stored;
      autoResize(textarea);
    }

    let info = `카테고리: ${getCategoryLabel(category)} | 단계: ${getStepName(stepId)}`;
    const infoEl = document.getElementById('current-guide-info');
    if (infoEl) {
      infoEl.textContent = info;
    }
  }

  async function saveGuide() {
    const textarea = document.getElementById('guide-text');
    if (!textarea) return;

    const key = getGuideKey(currentCategory, currentGuideStep);
    const value = textarea.value;

    localStorage.setItem(key, value);

    showStatus('💾 저장 중...');
    const success = await saveToFirebase(key, value);

    if (success) {
      showStatus('✅ 지침 저장 완료!');
    } else {
      showStatus('⚠️ 로컬에만 저장됨');
    }

    setTimeout(hideStatus, 2000);
  }

  // ===== 헬퍼 함수 =====
  function getCategoryLabel(value) {
    const cat = config.categories.find(c => c.value === value);
    return cat ? cat.label : value;
  }

  function getCurrentStyle() {
    const settings = config.categorySettings[currentCategory];
    if (!settings || !settings.styles) return null;
    return settings.styles.find(s => s.id === currentStyleId);
  }

  function getCurrentSteps() {
    const style = getCurrentStyle();
    if (!style || !style.steps) return [];
    return style.steps.sort((a, b) => a.order - b.order);
  }

  function getStepName(stepId) {
    const steps = getCurrentSteps();
    const step = steps.find(s => s.id === stepId);
    return step ? step.name : stepId;
  }

  // ===== GPT PRO 초안 구성 유틸 =====
  function assembleGptProDraft() {
    const steps = getCurrentSteps();
    const ref = document.getElementById('sermon-ref').value.trim();
    const seriesName = document.getElementById('series-name').value.trim();
    const style = getCurrentStyle();
    const finalTitle = getSelectedTitle();

    if (!ref) {
      return { error: '성경구절을 입력하세요.' };
    }

    if (steps.length === 0) {
      return { error: '처리된 단계가 없습니다.' };
    }

    const completedSteps = steps.filter(step => stepResults[step.id]);

    if (completedSteps.length === 0) {
      return { error: '완성된 단계가 없습니다. 먼저 각 단계를 실행해주세요.' };
    }

    const categoryLabel = getCategoryLabel(currentCategory);
    const styleName = style ? style.name : '';
    const styleDescription = style ? style.description : '';

    let fullText = `====================================\n`;
    fullText += `📖 설교 초안 자료 (GPT-5.1 작성용)\n`;
    fullText += `====================================\n\n`;
    fullText += `⚠️ 중요: 이 자료는 gpt-4o-mini가 만든 '초안'입니다.\n`;
    fullText += `GPT-5.1은 이 자료를 참고하되, 처음부터 새로 작성해주세요.\n`;
    fullText += `mini가 만든 문장을 그대로 복사하지 말고, 자연스러운 설교문으로 재작성하세요.\n\n`;
    fullText += `${'='.repeat(50)}\n\n`;
    fullText += `📌 기본 정보\n`;
    fullText += `- 카테고리: ${categoryLabel}\n`;
    fullText += `- 스타일: ${styleName}\n`;
    if (styleDescription) {
      fullText += `- 스타일 설명: ${styleDescription}\n`;
    }
    fullText += `- 성경구절: ${ref}\n`;
    if (finalTitle) {
      fullText += `- 설교 제목: ${finalTitle}\n`;
    }
    if (seriesName) {
      fullText += `- 시리즈명: ${seriesName}\n`;
    }
    fullText += `- 작성일: ${new Date().toLocaleDateString('ko-KR')}\n`;
    fullText += `\n${'='.repeat(50)}\n\n`;

    let hasContent = false;
    let sectionIndex = 1;
    completedSteps.forEach(step => {
      if (step.name === '제목 추천') return;

      hasContent = true;
      fullText += `【 ${sectionIndex}. ${step.name} 】\n\n`;
      fullText += stepResults[step.id];
      fullText += `\n\n${'='.repeat(50)}\n\n`;
      sectionIndex += 1;
    });

    if (!hasContent) {
      return { error: '제목 추천 외의 완료된 단계가 없습니다. 다른 단계를 먼저 실행해주세요.' };
    }

    fullText += `\n📝 작성 지침:\n`;
    fullText += `위의 초안 자료를 참고하여, 완성도 높은 설교문을 처음부터 새로 작성해주세요.\n`;
    fullText += `⚠️ 중요: max_tokens를 16000으로 설정하고, 충분히 길고 상세하며 풍성한 내용으로 작성해주세요.\n`;

    // 제목 추천 단계를 제외한 완료된 단계 이름들
    const stepNames = completedSteps
      .filter(step => step.name !== '제목 추천')
      .map(step => step.name);

    return {
      error: null,
      fullText,
      draftContent: fullText,
      meta: {
        reference: ref,
        seriesName,
        styleName,
        styleDescription,
        finalTitle,
        categoryLabel
      },
      completedStepNames: stepNames
    };
  }

  // ===== 전체 복사 기능 =====
  const btnCopyAll = document.getElementById('btn-copy-all');
  if (btnCopyAll) {
    btnCopyAll.addEventListener('click', () => {
      const draft = assembleGptProDraft();
      if (draft.error) {
        alert(draft.error);
        return;
      }

      const tempTextarea = document.createElement('textarea');
      tempTextarea.value = draft.fullText;
      tempTextarea.style.position = 'fixed';
      tempTextarea.style.opacity = '0';
      document.body.appendChild(tempTextarea);
      tempTextarea.select();

      try {
        document.execCommand('copy');
        showStatus('✅ GPT-5.1에 붙여넣을 준비 완료!');
        setTimeout(hideStatus, 2000);
      } catch (err) {
        alert('복사 실패: ' + err.message);
      } finally {
        document.body.removeChild(tempTextarea);
      }
    });
  }

  // ===== GPT PRO 처리 기능 =====
  async function executeGptPro() {
    const draft = assembleGptProDraft();
    if (draft.error) {
      alert(draft.error);
      return;
    }

    // ===== 코드 검증 (코드가 존재하는 경우에만) =====
    const hasAnyCodes = Object.keys(step3Codes).length > 0;
    if (hasAnyCodes) {
      const codeResult = await showCodeInputPopup();
      if (codeResult.cancelled) {
        return; // 취소됨
      }
      showStatus(`✅ 코드 확인됨! (남은 횟수: ${codeResult.remaining})`);
    }

    // ===== 1단계: 전체 복사 =====
    const tempTextarea = document.createElement('textarea');
    tempTextarea.value = draft.fullText;
    tempTextarea.style.position = 'fixed';
    tempTextarea.style.opacity = '0';
    document.body.appendChild(tempTextarea);
    tempTextarea.select();

    try {
      document.execCommand('copy');
      showStatus('📋 전체 복사 완료! GPT PRO 처리 중...');
    } catch (err) {
      console.error('복사 실패:', err);
    } finally {
      document.body.removeChild(tempTextarea);
    }

    // ===== 2단계: GPT PRO (Step3)로 설교문 작성 =====
    const modelSettings = getModelSettings(currentCategory);
    const gptProModel = modelSettings.gptPro;
    const step3MaxTokens = modelSettings.step3MaxTokens || 16000;
    const step3Prompt = modelSettings.step3Prompt || DEFAULT_STEP3_PROMPT;

    showGptLoading(); // 로딩 오버레이 표시
    showStatus(`🚀 Step3 (${gptProModel}) 처리 중... (약 30초 소요)`);

    try {
      const response = await fetch('/api/sermon/gpt-pro', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          model: gptProModel, // 선택된 모델 전달
          maxTokens: step3MaxTokens, // 최대 토큰량
          customSystemPrompt: step3Prompt, // 사용자 정의 지침
          reference: draft.meta.reference,
          title: draft.meta.finalTitle,
          seriesName: draft.meta.seriesName,
          styleName: draft.meta.styleName,
          styleDescription: draft.meta.styleDescription,
          category: draft.meta.categoryLabel,
          draftContent: draft.draftContent,
          completedStepNames: draft.completedStepNames
        })
      });

      const data = await response.json();

      if (data.ok) {
        const resultTextarea = document.getElementById('gpt-pro-result');
        const resultContainer = document.getElementById('gpt-pro-result-container');

        if (resultTextarea && resultContainer) {
          resultTextarea.value = data.result;
          autoResize(resultTextarea);
          resultContainer.style.display = 'block';

          // 토큰 사용량 표시
          if (data.usage) {
            const cost = calculateCost(gptProModel, data.usage.input_tokens || 0, data.usage.output_tokens || 0);
            const usageSpan = document.getElementById('usage-step3');
            if (usageSpan) {
              usageSpan.textContent = `in(${(data.usage.input_tokens || 0).toLocaleString()}), out(${(data.usage.output_tokens || 0).toLocaleString()}), ${cost ? cost.totalCostKRW : '0.0'}`;
            }
          }

          // 결과 박스로 스크롤
          resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        showStatus('✅ 전체 복사 + Step3 완성!');
      } else {
        alert(`오류: ${data.error}`);
        showStatus('❌ 실패');
      }
    } catch (err) {
      alert(`네트워크 오류: ${err.message}`);
      showStatus('❌ 오류');
    } finally {
      hideGptLoading(); // 로딩 오버레이 숨김
      setTimeout(hideStatus, 3000);
    }
  }

  const btnGptPro = document.getElementById('btn-gpt-pro');
  if (btnGptPro) {
    btnGptPro.addEventListener('click', () => {
      if (!gptProUnlocked) {
        // 패스워드 모달 표시
        const modal = document.getElementById('modal-gpt-pro-password');
        if (modal) modal.classList.add('show');
        const input = document.getElementById('gpt-pro-password-input');
        if (input) {
          input.value = '';
          input.focus();
        }
      } else {
        // 이미 잠금 해제된 경우 바로 실행
        executeGptPro();
      }
    });
  }

  // GPT PRO 결과 복사
  const btnCopyGptPro = document.getElementById('btn-copy-gpt-pro');
  if (btnCopyGptPro) {
    btnCopyGptPro.addEventListener('click', () => {
      const textarea = document.getElementById('gpt-pro-result');
      if (textarea && textarea.value) {
        textarea.select();
        document.execCommand('copy');
        const orig = btnCopyGptPro.textContent;
        btnCopyGptPro.textContent = '✅ 복사됨!';
        setTimeout(() => btnCopyGptPro.textContent = orig, 1500);
      }
    });
  }

  // ===== 렌더링 함수 =====
  function renderCategories() {
    const select = document.getElementById('sermon-category');
    if (!select) return;

    const current = select.value;
    select.innerHTML = config.categories.map(c =>
      `<option value="${c.value}">${c.label}</option>`
    ).join('');

    if (current && config.categories.find(c => c.value === current)) {
      select.value = current;
    } else {
      select.value = config.categories[0].value;
    }
    currentCategory = select.value;
  }

  function renderStyles() {
    const settings = config.categorySettings[currentCategory];
    const styles = (settings && settings.styles) ? settings.styles : [];
    const container = document.getElementById('styles-list');

    if (!container) return;

    if (styles.length === 0) {
      container.innerHTML = '<p style="color: #999; font-size: .85rem; text-align: center;">스타일을 추가하세요.</p>';
      return;
    }

    container.innerHTML = styles.map(style =>
      `<div class="style-item ${style.id === currentStyleId ? 'active' : ''}" data-style="${style.id}">
        <div>
          <div style="font-weight: 600;">${style.name}</div>
          <div class="style-desc">${style.description || ''}</div>
        </div>
      </div>`
    ).join('');

    container.querySelectorAll('.style-item').forEach(item => {
      item.addEventListener('click', () => {
        currentStyleId = item.dataset.style;
        stepResults = {};
        titleOptions = [];
        selectedTitle = '';
        const titleBox = document.getElementById('title-selection-box');
        if (titleBox) titleBox.style.display = 'none';
        const gptProContainer = document.getElementById('gpt-pro-result-container');
        if (gptProContainer) gptProContainer.style.display = 'none';
        renderStyles();
        renderProcessingSteps();
        renderResultBoxes();
        renderGuideTabs();
      });
    });

    // 새로고침 시 자동 선택 비활성화 - 사용자가 명시적으로 선택하도록 함
    // if (!currentStyleId && styles.length > 0) {
    //   currentStyleId = styles[0].id;
    //   renderStyles();
    // }
  }

  function renderProcessingSteps() {
    const steps = getCurrentSteps();
    const container = document.getElementById('processing-steps');

    if (!container) return;

    if (steps.length === 0) {
      container.innerHTML = '<p style="color: #999; font-size: .85rem; text-align: center;">단계를 추가하세요.</p>';
      return;
    }

    container.innerHTML = steps.map(step =>
      `<button class="step-btn primary" data-step="${step.id}">${step.name} <span style="float: right;">(클릭!)</span></button>`
    ).join('');

    container.querySelectorAll('.step-btn').forEach(btn => {
      btn.addEventListener('click', () => executeStep(btn.dataset.step));
    });
  }

  // Step2 결과를 서론까지만 표시하는 함수
  function truncateToIntro(text) {
    if (!text) return '';

    // 서론 이후의 패턴들 (본론, 1대지, 대지1, 첫 번째, Conflict 등)
    const cutoffPatterns = [
      /\n\s*(본론|1대지|대지\s*1|첫\s*번째|First|Conflict|본문\s*1|I\.|1\.|하나\.|첫째)/i,
      /\n\s*[-=]{3,}/,  // 구분선
    ];

    let cutIndex = text.length;

    for (const pattern of cutoffPatterns) {
      const match = text.match(pattern);
      if (match && match.index < cutIndex) {
        cutIndex = match.index;
      }
    }

    // 서론 부분만 추출
    let intro = text.substring(0, cutIndex).trim();

    // 최소 100자 이상은 보여주기
    if (intro.length < 100 && text.length > 100) {
      intro = text.substring(0, 300).trim();
    }

    return intro;
  }

  // 토큰 사용량 저장
  let stepUsage = {};

  function renderResultBoxes() {
    const steps = getCurrentSteps();
    const container = document.getElementById('result-boxes');
    const updateNotice = document.getElementById('update-notice');
    const modelSettings = getModelSettings(currentCategory);

    if (!container) return;

    // 업데이트 안내 표시/숨김
    if (updateNotice) {
      updateNotice.style.display = steps.length === 0 ? 'block' : 'none';
    }

    container.innerHTML = steps.map(step => {
      const stepType = step.stepType || 'step1';
      const stepLabel = stepType === 'step1' ? 'Step1' : 'Step2';
      const usage = stepUsage[step.id];
      const usageHtml = usage ? `
        <span id="usage-${step.id}" style="font-size: .75rem; color: #888;">
          in(${usage.inputTokens?.toLocaleString() || 0}), out(${usage.outputTokens?.toLocaleString() || 0}), ${usage.costKRW || '0.0'}
        </span>
      ` : `<span id="usage-${step.id}" style="font-size: .75rem; color: #888;"></span>`;

      if (step.id === 'step2' || stepType === 'step2') {
        // Step2는 서론까지만 표시 + 더보기 표시
        return `
          <div class="box step2-box">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .35rem;">
              <label class="label" style="margin: 0;">${stepLabel}. ${step.name}</label>
              ${usageHtml}
            </div>
            <div class="step2-content-wrapper">
              <textarea id="result-${step.id}" class="autosize" style="min-height: 100px; max-height: 150px;" readonly placeholder="${step.name} 결과가 표시됩니다."></textarea>
              <div class="step2-gradient-overlay"></div>
            </div>
            <div style="text-align: center; color: #999; font-size: .85rem; padding: .5rem; border-top: 1px dashed #ddd; margin-top: .3rem;">
              -<br>-<br>-<br>
              <span style="font-size: .75rem;">이하 내용 생략</span>
            </div>
          </div>
        `;
      } else {
        return `
          <div class="box">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .35rem;">
              <label class="label" style="margin: 0;">${stepLabel}. ${step.name}</label>
              ${usageHtml}
            </div>
            <textarea id="result-${step.id}" class="autosize" style="min-height: 140px;" placeholder="${step.name} 결과가 표시됩니다."></textarea>
          </div>
        `;
      }
    }).join('');

    // 결과 복원 및 자동 높이
    steps.forEach(step => {
      if (stepResults[step.id]) {
        const textarea = document.getElementById(`result-${step.id}`);
        if (textarea) {
          // Step2는 서론까지만 표시
          if (step.id === 'step2') {
            textarea.value = truncateToIntro(stepResults[step.id]);
          } else {
            textarea.value = stepResults[step.id];
            autoResize(textarea);
          }
        }
      }
    });

    // 입력 이벤트로 자동 높이 + 결과 저장
    container.querySelectorAll('textarea').forEach(textarea => {
      textarea.addEventListener('input', () => {
        autoResize(textarea);
        // 사용자가 편집한 내용을 stepResults에 저장
        const stepId = textarea.id.replace('result-', '');
        stepResults[stepId] = textarea.value;
        // 자동 저장
        autoSaveStepResults();
      });
    });
  }

  function renderGuideTabs() {
    const steps = getCurrentSteps();
    const container = document.getElementById('guide-tabs');

    if (!container) return;

    if (!steps.find(step => step.id === currentGuideStep)) {
      currentGuideStep = steps.length > 0 ? steps[0].id : '';
    }

    container.innerHTML = steps.map(step =>
      `<button class="${step.id === currentGuideStep ? 'primary' : ''}"
        data-step="${step.id}">${step.name}</button>`
    ).join('');

    container.querySelectorAll('button').forEach(btn => {
      btn.addEventListener('click', () => {
        currentGuideStep = btn.dataset.step;
        renderGuideTabs();
        loadGuide(currentCategory, currentGuideStep);
      });
    });
  }

  // ===== 처리 단계 실행 =====
  async function executeStep(stepId) {
    const ref = document.getElementById('sermon-ref').value;
    if (!ref) {
      alert('성경구절을 입력하세요.');
      return;
    }

    const text = document.getElementById('sermon-text').value;
    const guideKey = getGuideKey(currentCategory, stepId);
    const guide = localStorage.getItem(guideKey) || '';

    // 총괄 지침 가져오기
    const settings = config.categorySettings[currentCategory];
    const masterGuide = settings ? settings.masterGuide : '';

    const steps = getCurrentSteps();
    const currentStepIndex = steps.findIndex(s => s.id === stepId);
    const currentStep = steps[currentStepIndex];
    const stepType = currentStep ? (currentStep.stepType || 'step1') : 'step1';

    // 선택된 모델 가져오기
    const modelSettings = getModelSettings(currentCategory);
    const selectedModel = stepType === 'step1' ? modelSettings.step1 : modelSettings.step2;

    const previousResults = {};
    for (let i = 0; i < currentStepIndex; i++) {
      const prevStep = steps[i];
      if (stepResults[prevStep.id]) {
        previousResults[prevStep.id] = {
          name: prevStep.name,
          result: stepResults[prevStep.id]
        };
      }
    }

    showGptLoading(); // 로딩 오버레이 표시
    showStatus(`🤖 ${getStepName(stepId)} 처리 중...`);

    try {
      const response = await fetch('/api/sermon/process', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          category: currentCategory,
          stepId: stepId,
          stepName: getStepName(stepId),
          stepType: stepType,
          model: selectedModel, // 선택된 모델 전달
          reference: ref,
          title: getSelectedTitle(), // 현재 제목 전달
          text: text,
          guide: guide,
          masterGuide: masterGuide,
          previousResults: previousResults
        })
      });

      const data = await response.json();

      if (data.ok) {
        stepResults[stepId] = data.result;  // 전체 결과는 저장
        const textarea = document.getElementById(`result-${stepId}`);
        if (textarea) {
          // Step2는 서론까지만 표시
          if (stepId === 'step2' || stepType === 'step2') {
            textarea.value = truncateToIntro(data.result);
          } else {
            textarea.value = data.result;
            autoResize(textarea);
          }
        }

        // 토큰 사용량 표시
        if (data.usage) {
          const cost = calculateCost(selectedModel, data.usage.input_tokens || 0, data.usage.output_tokens || 0);
          stepUsage[stepId] = {
            inputTokens: data.usage.input_tokens || 0,
            outputTokens: data.usage.output_tokens || 0,
            model: selectedModel,
            costKRW: cost ? cost.totalCostKRW : 0
          };
          // 사용량 표시 업데이트
          const usageSpan = document.getElementById(`usage-${stepId}`);
          if (usageSpan) {
            usageSpan.textContent = `in(${(data.usage.input_tokens || 0).toLocaleString()}), out(${(data.usage.output_tokens || 0).toLocaleString()}), ${cost ? cost.totalCostKRW : '0.0'}`;
          }
        }

        // 제목 추천 단계인 경우 라디오 버튼 표시
        const stepName = getStepName(stepId);
        if (stepName.includes('제목')) {
          const lines = data.result.trim().split('\n').filter(line => line.trim());
          if (lines.length >= 3) {
            displayTitleOptions(lines.slice(0, 3));
          }
        }

        // 자동 저장
        autoSaveStepResults();

        showStatus('✅ 완료!');
      } else {
        alert(`오류: ${data.error}`);
        showStatus('❌ 실패');
      }
    } catch (err) {
      alert(`네트워크 오류: ${err.message}`);
      showStatus('❌ 오류');
    } finally {
      hideGptLoading(); // 로딩 오버레이 숨김
      setTimeout(hideStatus, 2000);
    }
  }

  // ===== 카테고리 변경 =====
  const categorySelect = document.getElementById('sermon-category');
  if (categorySelect) {
    categorySelect.addEventListener('change', (e) => {
      currentCategory = e.target.value;
      currentStyleId = '';
      stepResults = {};
      stepUsage = {};  // 토큰 사용량도 초기화
      titleOptions = [];
      selectedTitle = '';
      const titleBox = document.getElementById('title-selection-box');
      if (titleBox) titleBox.style.display = 'none';
      const gptProContainer = document.getElementById('gpt-pro-result-container');
      if (gptProContainer) gptProContainer.style.display = 'none';

      loadMasterGuide(currentCategory);
      loadModelSettings(); // 모델 설정 로드
      renderStyles();
      renderProcessingSteps();
      renderResultBoxes();
      renderGuideTabs();

      const seriesBox = document.getElementById('series-box');
      if (seriesBox) {
        if (currentCategory === 'series') {
          seriesBox.style.display = 'block';
        } else {
          seriesBox.style.display = 'none';
        }
      }
    });
  }

  // ===== 패스워드 =====
  const toggleGuidesBtn = document.getElementById('toggle-guides');
  if (toggleGuidesBtn) {
    toggleGuidesBtn.addEventListener('click', () => {
      if (!guideUnlocked) {
        const modal = document.getElementById('modal-password');
        if (modal) modal.classList.add('show');
        const input = document.getElementById('password-input');
        if (input) {
          input.value = '';
          input.focus();
        }
      } else {
        const adminModal = document.getElementById('modal-admin-panel');
        if (adminModal) adminModal.classList.add('show');

        const steps = getCurrentSteps();
        if (steps.length > 0) {
          currentGuideStep = steps[0].id;
          renderGuideTabs();
          loadGuide(currentCategory, currentGuideStep);
        }
      }
    });
  }

  const btnCloseAdminPanel = document.getElementById('btn-close-admin-panel');
  if (btnCloseAdminPanel) {
    btnCloseAdminPanel.addEventListener('click', () => {
      const modal = document.getElementById('modal-admin-panel');
      if (modal) modal.classList.remove('show');
    });
  }

  const btnSubmitPassword = document.getElementById('btn-submit-password');
  if (btnSubmitPassword) {
    btnSubmitPassword.addEventListener('click', () => {
      const input = document.getElementById('password-input');
      if (input && input.value === GUIDE_PASSWORD) {
        guideUnlocked = true;
        const modal = document.getElementById('modal-password');
        if (modal) modal.classList.remove('show');

        const adminModal = document.getElementById('modal-admin-panel');
        if (adminModal) adminModal.classList.add('show');

        const steps = getCurrentSteps();
        if (steps.length > 0) {
          currentGuideStep = steps[0].id;
          renderGuideTabs();
          loadGuide(currentCategory, currentGuideStep);
        }
      } else {
        alert('❌ 패스워드가 틀렸습니다.');
        if (input) input.value = '';
      }
    });
  }

  const btnCancelPassword = document.getElementById('btn-cancel-password');
  if (btnCancelPassword) {
    btnCancelPassword.addEventListener('click', () => {
      const modal = document.getElementById('modal-password');
      if (modal) modal.classList.remove('show');
    });
  }

  // 사용 가이드 모달 닫기
  function closeGuideModal() {
    const modal = document.getElementById('modal-guide');
    const dontShowCheckbox = document.getElementById('dont-show-week');

    if (dontShowCheckbox && dontShowCheckbox.checked) {
      // 일주일(7일) 후까지 숨기기
      const hideUntil = Date.now() + (7 * 24 * 60 * 60 * 1000);
      localStorage.setItem('sermon-guide-hide-until', hideUntil.toString());
    } else {
      // 다음 방문시에는 표시
      localStorage.removeItem('sermon-guide-hide-until');
    }

    if (modal) modal.classList.remove('show');
  }

  const btnCloseGuide = document.getElementById('btn-close-guide');
  if (btnCloseGuide) {
    btnCloseGuide.addEventListener('click', closeGuideModal);
  }

  const btnCloseGuideX = document.getElementById('btn-close-guide-x');
  if (btnCloseGuideX) {
    btnCloseGuideX.addEventListener('click', closeGuideModal);
  }

  const passwordInput = document.getElementById('password-input');
  if (passwordInput) {
    passwordInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const btn = document.getElementById('btn-submit-password');
        if (btn) btn.click();
      }
    });
  }

  const saveGuideBtn = document.getElementById('save-guide');
  if (saveGuideBtn) {
    saveGuideBtn.addEventListener('click', saveGuide);
  }

  // ===== 관리 기능 패스워드 =====
  const btnSubmitManagePassword = document.getElementById('btn-submit-manage-password');
  if (btnSubmitManagePassword) {
    btnSubmitManagePassword.addEventListener('click', () => {
      const input = document.getElementById('manage-password-input');
      if (input && input.value === MANAGE_PASSWORD) {
        manageUnlocked = true;
        const modal = document.getElementById('modal-manage-password');
        if (modal) modal.classList.remove('show');

        // 패스워드 확인 후 요청된 관리 모달 표시
        if (pendingManageAction === 'categories') {
          renderCategoryManageList();
          const categoriesModal = document.getElementById('modal-categories');
          if (categoriesModal) categoriesModal.classList.add('show');
        } else if (pendingManageAction === 'styles') {
          const categoryLabel = document.getElementById('modal-styles-category');
          if (categoryLabel) {
            categoryLabel.textContent = getCategoryLabel(currentCategory);
          }
          renderStylesManageList();
          const stylesModal = document.getElementById('modal-styles');
          if (stylesModal) stylesModal.classList.add('show');
        }
        pendingManageAction = null;
      } else {
        alert('❌ 패스워드가 틀렸습니다.');
        if (input) input.value = '';
      }
    });
  }

  const btnCancelManagePassword = document.getElementById('btn-cancel-manage-password');
  if (btnCancelManagePassword) {
    btnCancelManagePassword.addEventListener('click', () => {
      pendingManageAction = null;
      const modal = document.getElementById('modal-manage-password');
      if (modal) modal.classList.remove('show');
    });
  }

  const managePasswordInput = document.getElementById('manage-password-input');
  if (managePasswordInput) {
    managePasswordInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const btn = document.getElementById('btn-submit-manage-password');
        if (btn) btn.click();
      }
    });
  }

  // ===== GPT PRO 패스워드 =====
  const btnSubmitGptProPassword = document.getElementById('btn-submit-gpt-pro-password');
  if (btnSubmitGptProPassword) {
    btnSubmitGptProPassword.addEventListener('click', () => {
      const input = document.getElementById('gpt-pro-password-input');
      if (input && input.value === GPT_PRO_PASSWORD) {
        gptProUnlocked = true;
        const modal = document.getElementById('modal-gpt-pro-password');
        if (modal) modal.classList.remove('show');

        // 패스워드 확인 후 GPT PRO 실행
        executeGptPro();
      } else {
        alert('❌ 패스워드가 틀렸습니다.');
        if (input) input.value = '';
      }
    });
  }

  const btnCancelGptProPassword = document.getElementById('btn-cancel-gpt-pro-password');
  if (btnCancelGptProPassword) {
    btnCancelGptProPassword.addEventListener('click', () => {
      const modal = document.getElementById('modal-gpt-pro-password');
      if (modal) modal.classList.remove('show');
    });
  }

  const gptProPasswordInput = document.getElementById('gpt-pro-password-input');
  if (gptProPasswordInput) {
    gptProPasswordInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const btn = document.getElementById('btn-submit-gpt-pro-password');
        if (btn) btn.click();
      }
    });
  }

  // ===== 카테고리 관리 =====
  function renderCategoryManageList() {
    const list = document.getElementById('categories-list');
    if (!list) return;

    if (config.categories.length === 0) {
      list.innerHTML = '<p style="color: #999; font-size: .8rem; text-align: center; padding: .5rem;">카테고리를 추가하세요.</p>';
      return;
    }

    list.innerHTML = config.categories.map((cat, idx) => `
      <div class="storage-item">
        <div>
          <div style="font-weight: 600;">${cat.label}</div>
          <div style="font-size: .75rem; color: #666;">${cat.value}</div>
        </div>
        <div>
          <button onclick="editCategory(${idx})" style="margin-right: .3rem;">이름 수정</button>
          ${config.categories.length > 1 ? `<button class="danger" onclick="deleteCategory(${idx})">삭제</button>` : ''}
        </div>
      </div>
    `).join('');
  }

  const btnManageCategories = document.getElementById('btn-manage-categories');
  if (btnManageCategories) {
    btnManageCategories.addEventListener('click', () => {
      if (manageUnlocked) {
        // 이미 잠금 해제된 경우 바로 모달 표시
        renderCategoryManageList();
        const modal = document.getElementById('modal-categories');
        if (modal) modal.classList.add('show');
      } else {
        // 패스워드 확인 필요
        pendingManageAction = 'categories';
        const modal = document.getElementById('modal-manage-password');
        if (modal) modal.classList.add('show');
        const input = document.getElementById('manage-password-input');
        if (input) {
          input.value = '';
          setTimeout(() => input.focus(), 100);
        }
      }
    });
  }

  const btnCloseCategories = document.getElementById('btn-close-categories');
  if (btnCloseCategories) {
    btnCloseCategories.addEventListener('click', () => {
      const modal = document.getElementById('modal-categories');
      if (modal) modal.classList.remove('show');
    });
  }

  const btnAddCategory = document.getElementById('btn-add-category');
  if (btnAddCategory) {
    btnAddCategory.addEventListener('click', async () => {
      const input = document.getElementById('new-cat-label');
      if (!input) return;

      const label = input.value.trim();

      if (!label) {
        alert('표시 이름을 입력하세요.');
        return;
      }

      const value = koreanToId(label);

      if (config.categories.find(c => c.value === value)) {
        alert('이미 존재하는 카테고리입니다.');
        return;
      }

      config.categories.push({value, label});
      config.categorySettings[value] = {
        masterGuide: "",
        styles: []
      };

      await saveConfig();
      renderCategories();
      renderCategoryManageList();
      input.value = '';
    });
  }

  window.editCategory = async function(idx) {
    const current = config.categories[idx];
    if (!current) return;

    const newLabel = prompt('새 카테고리 이름을 입력하세요.', current.label);
    if (newLabel === null) return;

    const trimmed = newLabel.trim();
    if (!trimmed) {
      alert('표시 이름을 입력하세요.');
      return;
    }

    current.label = trimmed;
    await saveConfig();
    renderCategories();
    renderCategoryManageList();
    if (current.value === currentCategory) {
      loadMasterGuide(currentCategory);
      renderStyles();
      renderProcessingSteps();
      renderResultBoxes();
      renderGuideTabs();
    }
  };

  window.deleteCategory = async function(idx) {
    if (!confirm(`"${config.categories[idx].label}" 삭제?`)) return;
    const value = config.categories[idx].value;
    config.categories.splice(idx, 1);
    delete config.categorySettings[value];
    await saveConfig();
    renderCategories();
    renderCategoryManageList();
    loadMasterGuide(currentCategory);
    renderStyles();
    renderProcessingSteps();
    renderResultBoxes();
    renderGuideTabs();
  };

  // ===== 스타일 관리 =====
  const btnManageStyles = document.getElementById('btn-manage-styles');
  if (btnManageStyles) {
    btnManageStyles.addEventListener('click', () => {
      if (manageUnlocked) {
        // 이미 잠금 해제된 경우 바로 모달 표시
        const categoryLabel = document.getElementById('modal-styles-category');
        if (categoryLabel) {
          categoryLabel.textContent = getCategoryLabel(currentCategory);
        }

        renderStylesManageList();
        const modal = document.getElementById('modal-styles');
        if (modal) modal.classList.add('show');
      } else {
        // 패스워드 확인 필요
        pendingManageAction = 'styles';
        const modal = document.getElementById('modal-manage-password');
        if (modal) modal.classList.add('show');
        const input = document.getElementById('manage-password-input');
        if (input) {
          input.value = '';
          setTimeout(() => input.focus(), 100);
        }
      }
    });
  }

  function renderStylesManageList() {
    const list = document.getElementById('styles-manage-list');
    if (!list) return;

    const settings = config.categorySettings[currentCategory];
    const styles = (settings && settings.styles) ? settings.styles : [];

    if (styles.length === 0) {
      list.innerHTML = '<p style="color: #999; font-size: .8rem; text-align: center; padding: .5rem;">스타일을 추가하세요.</p>';
      return;
    }

    list.innerHTML = styles.map((style, idx) => `
      <div class="storage-item">
        <div>
          <div style="font-weight: 600;">${style.name}</div>
          <div style="font-size: .75rem; color: #666;">${style.description || ''}</div>
        </div>
        <div>
          <button onclick="editStyle(${idx})" style="margin-right: .3rem;">이름 수정</button>
          <button onclick="editStyleSteps('${style.id}')" style="margin-right: .3rem;">단계 편집</button>
          <button onclick="duplicateStyle(${idx})" style="margin-right: .3rem; background: #4CAF50; color: white;">복제</button>
          <button class="danger" onclick="deleteStyle(${idx})">삭제</button>
        </div>
      </div>
    `).join('');
  }

  const btnCloseStyles = document.getElementById('btn-close-styles');
  if (btnCloseStyles) {
    btnCloseStyles.addEventListener('click', () => {
      const modal = document.getElementById('modal-styles');
      if (modal) modal.classList.remove('show');
    });
  }

  const btnAddStyle = document.getElementById('btn-add-style');
  if (btnAddStyle) {
    btnAddStyle.addEventListener('click', async () => {
      const nameInput = document.getElementById('new-style-name');
      const descInput = document.getElementById('new-style-desc');

      if (!nameInput) return;

      const name = nameInput.value.trim();
      const desc = descInput ? descInput.value.trim() : '';

      if (!name) {
        alert('스타일 이름을 입력하세요.');
        return;
      }

      const id = koreanToId(name);
      const settings = config.categorySettings[currentCategory];

      if (!settings.styles) {
        settings.styles = [];
      }

      settings.styles.push({
        id: id,
        name: name,
        description: desc,
        steps: []
      });

      await saveConfig();
      renderStyles();
      renderStylesManageList();
      nameInput.value = '';
      if (descInput) descInput.value = '';
    });
  }

  window.editStyle = async function(idx) {
    const settings = config.categorySettings[currentCategory];
    if (!settings || !settings.styles) return;

    const style = settings.styles[idx];
    if (!style) return;

    const newName = prompt('새 스타일 이름을 입력하세요.', style.name);
    if (newName === null) return;

    const trimmedName = newName.trim();
    if (!trimmedName) {
      alert('스타일 이름을 입력하세요.');
      return;
    }

    const newDesc = prompt('스타일 설명을 입력하세요.', style.description || '');
    if (newDesc === null) return;

    style.name = trimmedName;
    style.description = newDesc.trim();

    await saveConfig();
    renderStyles();
    renderStylesManageList();
    renderProcessingSteps();
    renderResultBoxes();
    renderGuideTabs();
  };

  window.deleteStyle = async function(idx) {
    const settings = config.categorySettings[currentCategory];
    if (!settings || !settings.styles) return;

    const style = settings.styles[idx];
    if (!confirm(`"${style.name}" 삭제?`)) return;

    // 스타일 삭제 시 관련 지침도 모두 삭제
    if (style.steps && style.steps.length > 0) {
      style.steps.forEach(step => {
        const guideKey = getGuideKey(currentCategory, step.id, style.id);
        localStorage.removeItem(guideKey);
        // Firebase에서도 삭제
        db.collection('users').doc(USER_CODE).collection(PAGE_NAME).doc(guideKey).delete().catch(err => {
          console.warn('Firebase 지침 삭제 실패:', err);
        });
      });
    }

    settings.styles.splice(idx, 1);
    if (currentStyleId === style.id) {
      currentStyleId = '';
    }
    await saveConfig();
    renderStyles();
    renderStylesManageList();
    renderProcessingSteps();
    renderResultBoxes();
    renderGuideTabs();
  };

  window.duplicateStyle = async function(idx) {
    const settings = config.categorySettings[currentCategory];
    if (!settings || !settings.styles) return;

    const originalStyle = settings.styles[idx];
    if (!originalStyle) return;

    // 복제할 스타일 이름 입력받기
    const newName = prompt('복제된 스타일의 이름을 입력하세요.', `${originalStyle.name} (사본)`);
    if (newName === null) return;

    const trimmedName = newName.trim();
    if (!trimmedName) {
      alert('스타일 이름을 입력하세요.');
      return;
    }

    // 새로운 고유 ID 생성
    const newId = koreanToId(trimmedName);

    // 스타일 복제 (단계들도 함께 복제)
    const duplicatedStyle = {
      id: newId,
      name: trimmedName,
      description: originalStyle.description || '',
      steps: originalStyle.steps ? JSON.parse(JSON.stringify(originalStyle.steps)) : []
    };

    // 스타일 추가
    settings.styles.push(duplicatedStyle);

    // 지침 복사 (각 단계별로)
    if (originalStyle.steps && originalStyle.steps.length > 0) {
      for (const step of originalStyle.steps) {
        const originalGuideKey = getGuideKey(currentCategory, step.id, originalStyle.id);
        const newGuideKey = getGuideKey(currentCategory, step.id, newId);

        // localStorage에서 지침 복사
        const guideContent = localStorage.getItem(originalGuideKey);
        if (guideContent) {
          localStorage.setItem(newGuideKey, guideContent);

          // Firebase에도 저장
          await saveToFirebase(newGuideKey, guideContent);
        }
      }
    }

    // 설정 저장
    await saveConfig();

    // UI 업데이트
    renderStyles();
    renderStylesManageList();

    showStatus(`✅ "${trimmedName}" 스타일이 복제되었습니다.`);
    setTimeout(hideStatus, 2000);
  };

  window.editStyleSteps = function(styleId) {
    const settings = config.categorySettings[currentCategory];
    if (!settings || !settings.styles) return;

    const style = settings.styles.find(s => s.id === styleId);
    if (!style) return;

    currentStyleId = styleId;
    const modal = document.getElementById('modal-styles');
    if (modal) modal.classList.remove('show');

    const styleLabel = document.getElementById('modal-steps-style');
    if (styleLabel) styleLabel.textContent = style.name;

    renderStepsManageList(style);

    const stepsModal = document.getElementById('modal-steps');
    if (stepsModal) stepsModal.classList.add('show');
  };

  function renderStepsManageList(style) {
    const list = document.getElementById('steps-list');
    if (!list) return;

    if (!style.steps) style.steps = [];
    style.steps.sort((a, b) => a.order - b.order);

    if (style.steps.length === 0) {
      list.innerHTML = '<p style="color: #999; font-size: .8rem; text-align: center; padding: .5rem;">단계를 추가하세요.</p>';
      return;
    }

    list.innerHTML = style.steps.map((step, idx) => {
      const stepType = step.stepType || 'step1';
      const stepBadgeColor = stepType === 'step1' ? '#ff6b6b' : '#4ecdc4';
      const stepBadgeText = stepType === 'step1' ? 'Step1' : 'Step2';
      return `
        <div class="storage-item">
          <div style="display: flex; align-items: center; gap: .5rem;">
            <span style="background: ${stepBadgeColor}; color: white; padding: .2rem .4rem; border-radius: 4px; font-size: .7rem; font-weight: 600;">${stepBadgeText}</span>
            <span>${step.order}. ${step.name}</span>
          </div>
          <div>
            ${idx > 0 ? `<button onclick="moveStep(${idx}, -1)" style="margin-right: .3rem;">↑</button>` : ''}
            ${idx < style.steps.length - 1 ? `<button onclick="moveStep(${idx}, 1)" style="margin-right: .3rem;">↓</button>` : ''}
            <button onclick="renameStep(${idx})" style="margin-right: .3rem;">이름 수정</button>
            <button class="danger" onclick="deleteStep(${idx})">삭제</button>
          </div>
        </div>
      `;
    }).join('');
  }

  const btnCloseSteps = document.getElementById('btn-close-steps');
  if (btnCloseSteps) {
    btnCloseSteps.addEventListener('click', () => {
      const modal = document.getElementById('modal-steps');
      if (modal) modal.classList.remove('show');
    });
  }

  // Step1 추가 버튼
  const btnAddStep1 = document.getElementById('btn-add-step1');
  if (btnAddStep1) {
    btnAddStep1.addEventListener('click', async () => {
      const input = document.getElementById('new-step-name');
      if (!input) return;

      const name = input.value.trim();

      if (!name) {
        alert('단계 이름을 입력하세요.');
        return;
      }

      const style = getCurrentStyle();
      if (!style) return;

      if (!style.steps) style.steps = [];

      const id = koreanToId(name);
      const maxOrder = style.steps.length > 0 ? Math.max(...style.steps.map(s => s.order)) : 0;

      style.steps.push({
        id: id,
        name: name,
        order: maxOrder + 1,
        stepType: 'step1'
      });

      await saveConfig();
      renderProcessingSteps();
      renderResultBoxes();
      renderGuideTabs();
      const updatedStyle = getCurrentStyle();
      if (updatedStyle) {
        renderStepsManageList(updatedStyle);
      }
      input.value = '';
    });
  }

  // Step2 추가 버튼
  const btnAddStep2 = document.getElementById('btn-add-step2');
  if (btnAddStep2) {
    btnAddStep2.addEventListener('click', async () => {
      const input = document.getElementById('new-step-name');
      if (!input) return;

      const name = input.value.trim();

      if (!name) {
        alert('단계 이름을 입력하세요.');
        return;
      }

      const style = getCurrentStyle();
      if (!style) return;

      if (!style.steps) style.steps = [];

      const id = koreanToId(name);
      const maxOrder = style.steps.length > 0 ? Math.max(...style.steps.map(s => s.order)) : 0;

      style.steps.push({
        id: id,
        name: name,
        order: maxOrder + 1,
        stepType: 'step2'
      });

      await saveConfig();
      renderProcessingSteps();
      renderResultBoxes();
      renderGuideTabs();
      const updatedStyle = getCurrentStyle();
      if (updatedStyle) {
        renderStepsManageList(updatedStyle);
      }
      input.value = '';
    });
  }

  window.moveStep = async function(idx, direction) {
    const style = getCurrentStyle();
    if (!style || !style.steps) return;

    const steps = style.steps;
    const targetIdx = idx + direction;

    if (targetIdx < 0 || targetIdx >= steps.length) return;

    [steps[idx].order, steps[targetIdx].order] = [steps[targetIdx].order, steps[idx].order];

    await saveConfig();
    renderProcessingSteps();
    renderResultBoxes();
    renderGuideTabs();
    const updatedStyle = getCurrentStyle();
    if (updatedStyle) {
      renderStepsManageList(updatedStyle);
    }
  };

  window.deleteStep = async function(idx) {
    const style = getCurrentStyle();
    if (!style || !style.steps) return;

    if (!confirm(`"${style.steps[idx].name}" 삭제?`)) return;

    style.steps.splice(idx, 1);
    await saveConfig();
    renderProcessingSteps();
    renderResultBoxes();
    renderGuideTabs();
    renderStepsManageList(style);
  };

  window.renameStep = async function(idx) {
    const style = getCurrentStyle();
    if (!style || !style.steps) return;

    const step = style.steps[idx];
    if (!step) return;

    const newName = prompt('새 단계 이름을 입력하세요.', step.name);
    if (newName === null) return;

    const trimmed = newName.trim();
    if (!trimmed) {
      alert('단계 이름을 입력하세요.');
      return;
    }

    step.name = trimmed;
    await saveConfig();
    renderProcessingSteps();
    renderResultBoxes();
    renderGuideTabs();
    renderStepsManageList(style);
  };

  // ===== 저장/불러오기 =====
  const btnSave = document.getElementById('btn-save');
  if (btnSave) {
    btnSave.addEventListener('click', () => {
      const saved = JSON.parse(localStorage.getItem('sermon-saved') || '[]');
      const style = getCurrentStyle();

      saved.push({
        date: document.getElementById('sermon-date').value,
        category: currentCategory,
        styleId: currentStyleId,
        styleName: style ? style.name : '',
        seriesName: document.getElementById('series-name').value,
        ref: document.getElementById('sermon-ref').value,
        manualTitle: document.getElementById('manual-title').value,
        selectedTitle: selectedTitle,
        text: document.getElementById('sermon-text').value,
        results: stepResults,
        titleOptions: titleOptions,
        savedAt: new Date().toISOString()
      });

      localStorage.setItem('sermon-saved', JSON.stringify(saved));
      renderSavedList();
      alert('✅ 저장되었습니다!');
    });
  }

  function renderSavedList() {
    const saved = JSON.parse(localStorage.getItem('sermon-saved') || '[]');
    const list = document.getElementById('saved-list');

    if (!list) return;

    if (saved.length === 0) {
      list.innerHTML = '<p style="color: #999; font-size: .8rem; text-align: center; padding: .5rem;">저장된 자료가 없습니다.</p>';
      return;
    }

    list.innerHTML = saved.map((item, idx) => {
      const catLabel = getCategoryLabel(item.category);
      const display = item.seriesName
        ? `${item.date} - ${catLabel} - ${item.seriesName}`
        : `${item.date} - ${catLabel} - ${item.styleName}`;

      return `
        <div class="storage-item">
          <span style="font-size: .85rem;">${display}</span>
          <div>
            <button onclick="loadSaved(${idx})" style="margin-right: .3rem;">불러오기</button>
            <button onclick="deleteSaved(${idx})">삭제</button>
          </div>
        </div>
      `;
    }).join('');
  }

  window.loadSaved = function(idx) {
    const saved = JSON.parse(localStorage.getItem('sermon-saved') || '[]');
    const item = saved[idx];

    document.getElementById('sermon-date').value = item.date || '';
    document.getElementById('sermon-category').value = item.category || 'general';
    document.getElementById('sermon-ref').value = item.ref || '';
    document.getElementById('sermon-text').value = item.text || '';
    document.getElementById('series-name').value = item.seriesName || '';
    document.getElementById('manual-title').value = item.manualTitle || '';

    currentCategory = item.category || 'general';
    currentStyleId = item.styleId || '';
    stepResults = item.results || {};
    titleOptions = item.titleOptions || [];
    selectedTitle = item.selectedTitle || '';

    // 제목이 있으면 표시
    if (titleOptions.length >= 3) {
      displayTitleOptions(titleOptions);
      // 저장된 선택 복원
      if (selectedTitle) {
        const idx = titleOptions.indexOf(selectedTitle);
        if (idx >= 0) {
          const radio = document.querySelector(`input[name="selectedTitle"][value="${idx}"]`);
          if (radio) radio.checked = true;
        }
      }
    }

    renderStyles();
    renderProcessingSteps();
    renderResultBoxes();
    renderGuideTabs();

    document.querySelectorAll('textarea').forEach(autoResize);
  };

  window.deleteSaved = function(idx) {
    if (!confirm('삭제하시겠습니까?')) return;
    const saved = JSON.parse(localStorage.getItem('sermon-saved') || '[]');
    saved.splice(idx, 1);
    localStorage.setItem('sermon-saved', JSON.stringify(saved));
    renderSavedList();
  };

  // ===== textarea 자동 높이 =====
  document.querySelectorAll('textarea.autosize').forEach(textarea => {
    textarea.addEventListener('input', () => autoResize(textarea));
  });

  // ===== Q&A 기능 =====
  const QA_STORAGE_KEY = 'sermon-qa-history';

  function loadQAHistory() {
    try {
      const history = sessionStorage.getItem(QA_STORAGE_KEY);
      return history ? JSON.parse(history) : [];
    } catch (e) {
      console.error('Q&A 히스토리 로드 실패:', e);
      return [];
    }
  }

  function saveQAHistory(history) {
    try {
      sessionStorage.setItem(QA_STORAGE_KEY, JSON.stringify(history));
    } catch (e) {
      console.error('Q&A 히스토리 저장 실패:', e);
    }
  }

  function renderQAHistory() {
    const qaHistory = document.getElementById('qa-history');
    if (!qaHistory) return;

    const history = loadQAHistory();

    if (history.length === 0) {
      qaHistory.innerHTML = '<div class="qa-empty-state">아직 질문이 없습니다.<br>처리 단계 결과나 본문에 대해 궁금한 점을 물어보세요.</div>';
      return;
    }

    qaHistory.innerHTML = history.map(item => {
      const userMsg = `
        <div class="qa-message user">
          <div class="qa-message-label">질문</div>
          <div class="qa-message-content">${escapeHtml(item.question)}</div>
        </div>
      `;
      const assistantMsg = `
        <div class="qa-message assistant">
          <div class="qa-message-label">답변</div>
          <div class="qa-message-content">${escapeHtml(item.answer)}</div>
        </div>
      `;
      return userMsg + assistantMsg;
    }).join('');

    // 스크롤을 맨 아래로
    qaHistory.scrollTop = qaHistory.scrollHeight;
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  async function sendQAQuestion() {
    const input = document.getElementById('qa-input');
    const question = input.value.trim();

    if (!question) {
      alert('질문을 입력해주세요.');
      return;
    }

    const reference = document.getElementById('sermon-ref').value.trim();

    // 현재 처리 단계 결과들 수집
    const contextStepResults = {};
    for (const [stepId, stepData] of Object.entries(stepResults)) {
      if (stepData && stepData.result) {
        contextStepResults[stepId] = {
          name: stepData.name || stepId,
          result: stepData.result
        };
      }
    }

    // UI 업데이트: 질문 추가
    const history = loadQAHistory();
    history.push({
      question: question,
      answer: '답변을 생성 중입니다...'
    });
    saveQAHistory(history);
    renderQAHistory();

    // 입력창 비우기
    input.value = '';

    showGptLoading(); // 로딩 오버레이 표시

    try {
      showStatus('🤔 답변 생성 중...');

      const response = await fetch('/api/sermon/qa', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          question: question,
          reference: reference,
          stepResults: contextStepResults
        })
      });

      const result = await response.json();
      hideGptLoading(); // 로딩 오버레이 숨김
      hideStatus();

      if (result.ok) {
        // 마지막 항목의 답변 업데이트
        history[history.length - 1].answer = result.answer;
        saveQAHistory(history);
        renderQAHistory();
      } else {
        alert('답변 생성 실패: ' + (result.error || '알 수 없는 오류'));
        // 실패한 항목 제거
        history.pop();
        saveQAHistory(history);
        renderQAHistory();
      }
    } catch (err) {
      hideGptLoading(); // 로딩 오버레이 숨김
      hideStatus();
      console.error('Q&A 요청 실패:', err);
      alert('답변 생성 중 오류가 발생했습니다.');
      // 실패한 항목 제거
      history.pop();
      saveQAHistory(history);
      renderQAHistory();
    }
  }

  // ===== Step3 사용 코드 관리 시스템 =====
  const CODES_KEY = '_sermon-step3-codes';
  let step3Codes = {}; // { 코드명: { limit: 총횟수, remaining: 남은횟수, createdAt: 생성일 } }

  // 코드 목록 로드
  async function loadStep3Codes() {
    const saved = localStorage.getItem(CODES_KEY);
    if (saved) {
      try {
        step3Codes = JSON.parse(saved);
      } catch (e) {
        step3Codes = {};
      }
    }
    renderCodeList();
  }

  // 코드 목록 저장
  async function saveStep3Codes() {
    localStorage.setItem(CODES_KEY, JSON.stringify(step3Codes));
    await saveToFirebase(CODES_KEY, JSON.stringify(step3Codes));
  }

  // 랜덤 코드 생성
  function generateRandomCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // 혼동 가능한 문자 제외 (0,O,1,I)
    let code = '';
    for (let i = 0; i < 6; i++) {
      code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
  }

  // 새 코드 생성
  async function createNewCode() {
    const nameInput = document.getElementById('new-code-name');
    const limitInput = document.getElementById('new-code-limit');

    let codeName = nameInput.value.trim().toUpperCase();
    const limit = parseInt(limitInput.value) || 3;

    // 코드명이 비어있으면 자동 생성
    if (!codeName) {
      do {
        codeName = generateRandomCode();
      } while (step3Codes[codeName]); // 중복 방지
    }

    // 이미 존재하는 코드 체크
    if (step3Codes[codeName]) {
      alert(`'${codeName}' 코드가 이미 존재합니다.`);
      return;
    }

    // 코드 추가
    step3Codes[codeName] = {
      limit: limit,
      remaining: limit,
      createdAt: new Date().toISOString()
    };

    await saveStep3Codes();
    renderCodeList();

    // 입력 필드 초기화
    nameInput.value = '';
    limitInput.value = '3';

    showStatus(`✅ 코드 '${codeName}' 생성 완료!`);
    setTimeout(hideStatus, 2000);
  }

  // 코드 삭제
  async function deleteCode(codeName) {
    if (!confirm(`'${codeName}' 코드를 삭제하시겠습니까?`)) return;

    delete step3Codes[codeName];
    await saveStep3Codes();
    renderCodeList();

    showStatus(`🗑️ 코드 '${codeName}' 삭제됨`);
    setTimeout(hideStatus, 2000);
  }

  // 코드 목록 렌더링
  function renderCodeList() {
    const tbody = document.getElementById('code-list-body');
    if (!tbody) return;

    const codeNames = Object.keys(step3Codes);

    if (codeNames.length === 0) {
      tbody.innerHTML = '<tr><td colspan="4" style="padding: 1rem; text-align: center; color: #999;">생성된 코드가 없습니다.</td></tr>';
      return;
    }

    // 생성일 기준 정렬 (최신순)
    codeNames.sort((a, b) => {
      const dateA = new Date(step3Codes[a].createdAt || 0);
      const dateB = new Date(step3Codes[b].createdAt || 0);
      return dateB - dateA;
    });

    tbody.innerHTML = codeNames.map(code => {
      const info = step3Codes[code];
      const isExhausted = info.remaining <= 0;
      const statusText = isExhausted ? '소진' : '활성';
      const statusColor = isExhausted ? '#e74c3c' : '#27ae60';
      const statusBg = isExhausted ? '#fde8e8' : '#e8f8e8';

      return `
        <tr style="border-bottom: 1px solid #f0f0f0;">
          <td style="padding: .5rem; font-family: monospace; font-weight: 600;">${code}</td>
          <td style="padding: .5rem; text-align: center;">${info.remaining}/${info.limit}</td>
          <td style="padding: .5rem; text-align: center;">
            <span style="background: ${statusBg}; color: ${statusColor}; padding: .2rem .5rem; border-radius: 4px; font-size: .75rem; font-weight: 600;">${statusText}</span>
          </td>
          <td style="padding: .5rem; text-align: center;">
            <button onclick="deleteCode('${code}')" style="padding: .2rem .5rem; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: .75rem;">삭제</button>
          </td>
        </tr>
      `;
    }).join('');
  }

  // 코드 유효성 검사 및 사용
  async function validateAndUseCode(inputCode) {
    const code = inputCode.trim().toUpperCase();

    if (!code) {
      return { valid: false, message: '코드를 입력해주세요.' };
    }

    if (!step3Codes[code]) {
      return { valid: false, message: '존재하지 않는 코드입니다.' };
    }

    if (step3Codes[code].remaining <= 0) {
      return { valid: false, message: '사용 횟수가 모두 소진된 코드입니다.' };
    }

    // 코드 사용 (횟수 차감)
    step3Codes[code].remaining--;
    await saveStep3Codes();
    renderCodeList();

    return { valid: true, remaining: step3Codes[code].remaining };
  }

  // 코드 입력 팝업 표시
  function showCodeInputPopup() {
    return new Promise((resolve) => {
      const overlay = document.createElement('div');
      overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 10000;';

      const popup = document.createElement('div');
      popup.style.cssText = 'background: white; padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 350px; width: 90%;';
      popup.innerHTML = `
        <div style="font-size: 1.1rem; font-weight: 700; color: #f5576c; margin-bottom: 1rem; text-align: center;">🔑 Step3 사용 코드 입력</div>
        <div style="font-size: .85rem; color: #666; margin-bottom: 1rem; text-align: center;">
          Step3 실행을 위해 발급받은 코드를 입력해주세요.
        </div>
        <input type="text" id="step3-code-input" placeholder="코드 입력 (예: ABC123)" style="width: 100%; padding: .75rem; font-size: 1rem; border: 2px solid #ddd; border-radius: 8px; text-align: center; text-transform: uppercase; font-family: monospace; font-weight: 600; margin-bottom: 1rem; box-sizing: border-box;">
        <div id="code-error-msg" style="color: #e74c3c; font-size: .85rem; text-align: center; margin-bottom: 1rem; display: none;"></div>
        <div style="display: flex; gap: .5rem;">
          <button id="btn-code-cancel" style="flex: 1; padding: .6rem; background: #e0e0e0; color: #666; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">취소</button>
          <button id="btn-code-confirm" style="flex: 1; padding: .6rem; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">확인</button>
        </div>
      `;

      overlay.appendChild(popup);
      document.body.appendChild(overlay);

      const input = popup.querySelector('#step3-code-input');
      const errorMsg = popup.querySelector('#code-error-msg');
      const cancelBtn = popup.querySelector('#btn-code-cancel');
      const confirmBtn = popup.querySelector('#btn-code-confirm');

      input.focus();

      const cleanup = () => {
        document.body.removeChild(overlay);
      };

      cancelBtn.addEventListener('click', () => {
        cleanup();
        resolve({ cancelled: true });
      });

      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          cleanup();
          resolve({ cancelled: true });
        }
      });

      const handleConfirm = async () => {
        confirmBtn.disabled = true;
        confirmBtn.textContent = '확인 중...';

        const result = await validateAndUseCode(input.value);

        if (result.valid) {
          cleanup();
          resolve({ cancelled: false, ...result });
        } else {
          errorMsg.textContent = result.message;
          errorMsg.style.display = 'block';
          confirmBtn.disabled = false;
          confirmBtn.textContent = '확인';
          input.focus();
          input.select();
        }
      };

      confirmBtn.addEventListener('click', handleConfirm);
      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') handleConfirm();
      });
    });
  }

  // 전역 함수로 등록 (onclick에서 사용)
  window.deleteCode = deleteCode;

  // ===== 초기화 =====
  document.addEventListener('DOMContentLoaded', async () => {
    const dateInput = document.getElementById('sermon-date');
    if (dateInput) {
      dateInput.value = new Date().toISOString().split('T')[0];
    }

    showStatus('☁️ 클라우드 동기화 중...');
    await loadFromFirebase();
    hideStatus();

    renderCategories();
    loadMasterGuide(currentCategory);
    loadModelSettings(); // 모델 설정 로드
    loadStep3Codes(); // Step3 코드 목록 로드

    // 코드 생성 버튼 이벤트 리스너
    const btnCreateCode = document.getElementById('btn-create-code');
    if (btnCreateCode) {
      btnCreateCode.addEventListener('click', createNewCode);
    }
    renderStyles();
    renderProcessingSteps();

    // 모델 선택 이벤트 리스너
    const step1Select = document.getElementById('model-step1');
    const step2Select = document.getElementById('model-step2');
    const gptProSelect = document.getElementById('model-gpt-pro');

    if (step1Select) {
      step1Select.addEventListener('change', async () => {
        await saveModelSettings();
        showStatus('✅ 모델 설정 저장됨');
        setTimeout(hideStatus, 1500);
      });
    }
    if (step2Select) {
      step2Select.addEventListener('change', async () => {
        await saveModelSettings();
        showStatus('✅ 모델 설정 저장됨');
        setTimeout(hideStatus, 1500);
      });
    }
    if (gptProSelect) {
      gptProSelect.addEventListener('change', async () => {
        await saveModelSettings();
        showStatus('✅ 모델 설정 저장됨');
        setTimeout(hideStatus, 1500);
      });
    }

    // Step3 토큰 설정 이벤트 리스너
    const step3MaxTokensInput = document.getElementById('step3-max-tokens');
    if (step3MaxTokensInput) {
      step3MaxTokensInput.addEventListener('change', async () => {
        await saveModelSettings();
        showStatus('✅ 토큰 설정 저장됨');
        setTimeout(hideStatus, 1500);
      });
    }

    // Step3 지침 버튼 이벤트 리스너
    const btnSaveStep3Prompt = document.getElementById('btn-save-step3-prompt');
    if (btnSaveStep3Prompt) {
      btnSaveStep3Prompt.addEventListener('click', saveStep3Prompt);
    }

    const btnResetStep3Prompt = document.getElementById('btn-reset-step3-prompt');
    if (btnResetStep3Prompt) {
      btnResetStep3Prompt.addEventListener('click', () => {
        resetStep3Prompt();
        showStatus('✅ 기본값 복원됨 (저장하려면 저장 버튼 클릭)');
        setTimeout(hideStatus, 2000);
      });
    }

    // 자동 저장 데이터 복원 - 새로고침 시 초기화하기 위해 제거
    // loadAutoSave();

    // 새로고침 시 stepResults 초기화
    stepResults = {};
    titleOptions = [];
    selectedTitle = '';

    // 새로고침 시 AUTO_SAVE_KEY 데이터 삭제 및 타임스탬프를 미래 값으로 설정 (실시간 동기화 방지)
    localStorage.removeItem(AUTO_SAVE_KEY);
    // 타임스탬프를 현재 + 1년으로 설정하여 실시간 동기화가 복원하지 않도록 함
    const futureTimestamp = (Date.now() + 365 * 24 * 60 * 60 * 1000).toString();
    localStorage.setItem(`${AUTO_SAVE_KEY}_timestamp`, futureTimestamp);

    // 새로고침 시 Q&A 히스토리 초기화
    sessionStorage.removeItem(QA_STORAGE_KEY);

    // 새로고침 시 GPT PRO 결과 초기화
    const gptProContainer = document.getElementById('gpt-pro-result-container');
    if (gptProContainer) gptProContainer.style.display = 'none';
    const gptProResult = document.getElementById('gpt-pro-result');
    if (gptProResult) gptProResult.value = '';

    // 제목 선택 박스 숨기기
    const titleBox = document.getElementById('title-selection-box');
    if (titleBox) titleBox.style.display = 'none';

    renderResultBoxes();
    renderGuideTabs();
    renderSavedList();

    // 첫 방문자 가이드 표시
    const guideHideUntil = localStorage.getItem('sermon-guide-hide-until');
    const now = Date.now();
    if (!guideHideUntil || now > parseInt(guideHideUntil)) {
      const modal = document.getElementById('modal-guide');
      if (modal) {
        modal.classList.add('show');
      }
    }

    // 실시간 동기화 시작
    console.log('🔄 실시간 동기화 활성화');
    setupRealtimeSync();

    // Q&A 초기화
    renderQAHistory();

    // Q&A 이벤트 리스너
    const btnSendQA = document.getElementById('btn-send-qa');
    if (btnSendQA) {
      btnSendQA.addEventListener('click', sendQAQuestion);
    }

    const qaInput = document.getElementById('qa-input');
    if (qaInput) {
      // Enter 키로 전송 (Shift+Enter는 줄바꿈)
      qaInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendQAQuestion();
        }
      });
    }

    document.querySelectorAll('textarea').forEach(autoResize);
  });
  </script>
</body>
</html>
