<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>DRAMA LAB</title>
  <!-- 외부 CSS 파일 -->
  <link rel="stylesheet" href="/static/css/drama.css">
</head>
<body>
  <!-- 중앙 로딩 인디케이터 -->
  <div id="loading-overlay" class="loading-overlay">
    <div class="loading-content">
      <div class="loading-spinner"></div>
      <div class="loading-text">AI 작업 중</div>
      <div class="loading-subtext">잠시만 기다려주세요...</div>
    </div>
  </div>

  <!-- 지침 보기 모달 -->
  <div id="guidelines-modal" class="modal">
    <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
      <div class="modal-title" style="display: flex; justify-content: space-between; align-items: center;">
        <span>📋 대본 작성 지침</span>
        <button onclick="closeGuidelinesModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;">&times;</button>
      </div>
      <div id="guidelines-modal-content" style="padding: 1rem 0; white-space: pre-wrap; font-size: 0.9rem; line-height: 1.8;"></div>
      <div class="modal-buttons">
        <button onclick="closeGuidelinesModal()" class="primary">닫기</button>
      </div>
    </div>
  </div>

  <!-- JSON 뷰어 모달 -->
  <div id="json-viewer-modal" class="modal">
    <div class="modal-content" style="max-width: 95vw; max-height: 95vh; overflow: hidden; display: flex; flex-direction: column;">
      <div class="modal-title" style="display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;">
        <span>🔍 현재 적용 중인 JSON 데이터</span>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
          <button onclick="refreshJsonViewer()" style="padding: 0.3rem 0.8rem; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">🔄 새로고침</button>
          <button onclick="closeJsonViewerModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #666;">&times;</button>
        </div>
      </div>
      <div style="display: flex; gap: 0.5rem; margin: 0.5rem 0; flex-shrink: 0;">
        <button onclick="showJsonTab('session')" id="json-tab-session" class="json-tab active" style="flex: 1; padding: 0.5rem; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">📦 세션 데이터</button>
        <button onclick="showJsonTab('guidelines')" id="json-tab-guidelines" class="json-tab" style="flex: 1; padding: 0.5rem; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">📋 지침 (style_guide)</button>
        <button onclick="showJsonTab('structure')" id="json-tab-structure" class="json-tab" style="flex: 1; padding: 0.5rem; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">🏗️ 대본 구조</button>
      </div>
      <div id="json-viewer-content" style="flex: 1; overflow-y: auto; background: #1e1e1e; color: #d4d4d4; padding: 1rem; border-radius: 8px; font-family: 'Consolas', 'Monaco', monospace; font-size: 0.85rem; white-space: pre-wrap;"></div>
      <div class="modal-buttons" style="flex-shrink: 0; margin-top: 0.5rem;">
        <button onclick="copyJsonContent()" style="flex: 1; background: #2196F3;">📋 복사</button>
        <button onclick="closeJsonViewerModal()" class="primary" style="flex: 1;">닫기</button>
      </div>
    </div>
  </div>

  <!-- Auth Header -->
  <div class="auth-header">
    <h1>🎭 드라마 스크립트 작성 도구</h1>
    <div class="auth-links">
      <a href="/" class="btn-home">홈</a>
      {% if session.user_id %}
        <span class="user-info">{{ session.user_name }}님</span>
        <a href="/logout" class="btn-logout">로그아웃</a>
      {% else %}
        <a href="/login" class="btn-login">로그인</a>
        <a href="/signup" class="btn-signup">회원가입</a>
      {% endif %}
    </div>
  </div>

  <div class="page-wrap">
    <!-- 왼쪽 -->
    <div class="left-col">
      <div class="quick-nav">
        <h3>드라마 워크플로우</h3>
        <button class="nav-btn active" data-panel-target="guide-panel">
          <span class="nav-label">🧭 작업지침</span>
          <span class="nav-desc">전체 가이드 보기</span>
        </button>
        <button class="nav-btn" data-panel-target="data-panel">
          <span class="nav-label">📚 데이터 축적</span>
          <span class="nav-desc">텍스트 · JSON · 벤치마킹</span>
        </button>
        <button class="nav-btn" data-panel-target="workflow-panel" data-scroll-target="step1-container">
          <span class="nav-label">✍️ Step1 대본 생성</span>
          <span class="nav-desc">대본 작성 흐름</span>
        </button>
        <button class="nav-btn" data-panel-target="workflow-panel" data-scroll-target="step4-container">
          <span class="nav-label">🖼️ Step2 이미지 생성</span>
          <span class="nav-desc">씬별 이미지 가이드</span>
        </button>
        <button class="nav-btn" data-panel-target="workflow-panel" data-scroll-target="step5-container">
          <span class="nav-label">🔊 Step3 음성 합성</span>
          <span class="nav-desc">목소리 & 설정</span>
        </button>
        <button class="nav-btn" data-panel-target="workflow-panel" data-scroll-target="step6-container">
          <span class="nav-label">🎞️ Step4 영상 제작</span>
          <span class="nav-desc">타임라인 & 컷 편집</span>
        </button>
        <!-- Step5 업로드 비활성화됨
        <button class="nav-btn" data-panel-target="workflow-panel" data-scroll-target="step7-container">
          <span class="nav-label">🚀 Step5 업로드</span>
          <span class="nav-desc">메타데이터 & 게시</span>
        </button>
        -->
      </div>

      <!-- 진행 상황 트래커 -->
      <div id="workflow-progress-sidebar" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; padding: .75rem; margin-top: .5rem;">
        <div style="color: white; font-weight: 700; font-size: .9rem; margin-bottom: .75rem; text-align: center;">📊 진행 현황</div>

        <div style="display: flex; flex-direction: column; gap: .35rem;">
          <!-- Step 1 -->
          <div class="progress-step-sidebar" data-step="step1">
            <div style="display: flex; align-items: center; gap: .4rem; padding: .4rem .5rem; background: rgba(255,255,255,0.1); border-radius: 6px; border-left: 3px solid rgba(255,255,255,0.3);">
              <div class="step-indicator" style="min-width: 20px; height: 20px; background: rgba(255,255,255,0.3); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: .7rem; font-weight: 700; color: white;">1</div>
              <div style="flex: 1;">
                <div style="font-size: .75rem; font-weight: 600; color: white;">대본 생성</div>
                <div class="step-substatus" style="font-size: .65rem; color: rgba(255,255,255,0.7);">대기</div>
              </div>
              <div class="step-status-icon" style="font-size: .8rem;">○</div>
            </div>
          </div>

          <!-- Step 2 -->
          <div class="progress-step-sidebar" data-step="step2">
            <div style="display: flex; align-items: center; gap: .4rem; padding: .4rem .5rem; background: rgba(255,255,255,0.1); border-radius: 6px; border-left: 3px solid rgba(255,255,255,0.3);">
              <div class="step-indicator" style="min-width: 20px; height: 20px; background: rgba(255,255,255,0.3); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: .7rem; font-weight: 700; color: white;">2</div>
              <div style="flex: 1;">
                <div style="font-size: .75rem; font-weight: 600; color: white;">대사+지문</div>
                <div class="step-substatus" style="font-size: .65rem; color: rgba(255,255,255,0.7);">대기</div>
              </div>
              <div class="step-status-icon" style="font-size: .8rem;">○</div>
            </div>
          </div>

          <!-- Step 3 -->
          <div class="progress-step-sidebar" data-step="step3">
            <div style="display: flex; align-items: center; gap: .4rem; padding: .4rem .5rem; background: rgba(255,255,255,0.1); border-radius: 6px; border-left: 3px solid rgba(255,255,255,0.3);">
              <div class="step-indicator" style="min-width: 20px; height: 20px; background: rgba(255,255,255,0.3); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: .7rem; font-weight: 700; color: white;">3</div>
              <div style="flex: 1;">
                <div style="font-size: .75rem; font-weight: 600; color: white;">대본 완성</div>
                <div class="step-substatus" style="font-size: .65rem; color: rgba(255,255,255,0.7);">대기</div>
              </div>
              <div class="step-status-icon" style="font-size: .8rem;">○</div>
            </div>
          </div>

          <!-- Step 4 -->
          <div class="progress-step-sidebar" data-step="step4">
            <div style="display: flex; align-items: center; gap: .4rem; padding: .4rem .5rem; background: rgba(255,255,255,0.1); border-radius: 6px; border-left: 3px solid rgba(255,255,255,0.3);">
              <div class="step-indicator" style="min-width: 20px; height: 20px; background: rgba(255,255,255,0.3); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: .7rem; font-weight: 700; color: white;">4</div>
              <div style="flex: 1;">
                <div style="font-size: .75rem; font-weight: 600; color: white;">이미지 생성</div>
                <div class="step-substatus" style="font-size: .65rem; color: rgba(255,255,255,0.7);">대기</div>
              </div>
              <div class="step-status-icon" style="font-size: .8rem;">○</div>
            </div>
          </div>

          <!-- Step 5 -->
          <div class="progress-step-sidebar" data-step="step5">
            <div style="display: flex; align-items: center; gap: .4rem; padding: .4rem .5rem; background: rgba(255,255,255,0.1); border-radius: 6px; border-left: 3px solid rgba(255,255,255,0.3);">
              <div class="step-indicator" style="min-width: 20px; height: 20px; background: rgba(255,255,255,0.3); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: .7rem; font-weight: 700; color: white;">5</div>
              <div style="flex: 1;">
                <div style="font-size: .75rem; font-weight: 600; color: white;">음성+자막</div>
                <div class="step-substatus" style="font-size: .65rem; color: rgba(255,255,255,0.7);">대기</div>
              </div>
              <div class="step-status-icon" style="font-size: .8rem;">○</div>
            </div>
          </div>

          <!-- Step 6 -->
          <div class="progress-step-sidebar" data-step="step6">
            <div style="display: flex; align-items: center; gap: .4rem; padding: .4rem .5rem; background: rgba(255,255,255,0.1); border-radius: 6px; border-left: 3px solid rgba(255,255,255,0.3);">
              <div class="step-indicator" style="min-width: 20px; height: 20px; background: rgba(255,255,255,0.3); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: .7rem; font-weight: 700; color: white;">6</div>
              <div style="flex: 1;">
                <div style="font-size: .75rem; font-weight: 600; color: white;">영상 제작</div>
                <div class="step-substatus" style="font-size: .65rem; color: rgba(255,255,255,0.7);">대기</div>
              </div>
              <div class="step-status-icon" style="font-size: .8rem;">○</div>
            </div>
          </div>

          <!-- Step 7 -->
          <div class="progress-step-sidebar" data-step="step7">
            <div style="display: flex; align-items: center; gap: .4rem; padding: .4rem .5rem; background: rgba(255,255,255,0.1); border-radius: 6px; border-left: 3px solid rgba(255,255,255,0.3);">
              <div class="step-indicator" style="min-width: 20px; height: 20px; background: rgba(255,255,255,0.3); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: .7rem; font-weight: 700; color: white;">7</div>
              <div style="flex: 1;">
                <div style="font-size: .75rem; font-weight: 600; color: white;">YouTube 업로드</div>
                <div class="step-substatus" style="font-size: .65rem; color: rgba(255,255,255,0.7);">대기</div>
              </div>
              <div class="step-status-icon" style="font-size: .8rem;">○</div>
            </div>
          </div>
        </div>

        <!-- 전체 상태 메시지 -->
        <div id="progress-status" style="margin-top: .75rem; padding: .4rem .5rem; background: rgba(255,255,255,0.15); border-radius: 6px; text-align: center;">
          <div style="color: rgba(255,255,255,0.95); font-size: .7rem; font-weight: 600;">Step1부터 시작하세요</div>
        </div>
      </div>

      <div class="legacy-left-content" style="display: none;">
      <!-- Step 네비게이션 -->
      <div class="step-nav" style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 12px; padding: .75rem; margin-bottom: .5rem;">
        <div style="color: white; font-weight: 700; font-size: .9rem; margin-bottom: .75rem; text-align: center;">📍 워크플로우</div>
        <div class="step-nav-items" style="display: flex; flex-direction: column; gap: .4rem;">
          <button class="step-nav-btn active" data-step="step1" onclick="scrollToStep('step1-container')">
            <span class="step-num">1</span>
            <span class="step-name">주제 선정</span>
            <span class="step-status">●</span>
          </button>
          <button class="step-nav-btn" data-step="step2" onclick="scrollToStep('step2-container')">
            <span class="step-num">2</span>
            <span class="step-name">자료 조사</span>
            <span class="step-status">○</span>
          </button>
          <button class="step-nav-btn" data-step="step3" onclick="scrollToStep('step3-container')">
            <span class="step-num">3</span>
            <span class="step-name">대본 작성</span>
            <span class="step-status">○</span>
          </button>
          <button class="step-nav-btn" data-step="step4" onclick="scrollToStep('step4-container')">
            <span class="step-num">4</span>
            <span class="step-name">이미지 생성</span>
            <span class="step-status">○</span>
          </button>
          <button class="step-nav-btn" data-step="step5" onclick="scrollToStep('step5-container')">
            <span class="step-num">5</span>
            <span class="step-name">음성 합성</span>
            <span class="step-status">○</span>
          </button>
          <button class="step-nav-btn" data-step="step6" onclick="scrollToStep('step6-container')">
            <span class="step-num">6</span>
            <span class="step-name">영상 제작</span>
            <span class="step-status">○</span>
          </button>
          <!-- Step7 업로드 비활성화됨
          <button class="step-nav-btn" data-step="step7" onclick="scrollToStep('step7-container')">
            <span class="step-num">7</span>
            <span class="step-name">업로드</span>
            <span class="step-status">○</span>
          </button>
          -->
        </div>
      </div>

      <!-- 날짜 + 영상 시간 + 콘텐츠 유형 -->
      <div class="box" style="padding: .5rem .75rem;">
        <div style="display: flex; gap: .5rem; align-items: center;">
          <div style="flex: 1;">
            <label class="label" style="font-size: .8rem; margin-bottom: .2rem; display: block;">날짜</label>
            <input type="date" id="drama-date" style="padding: .25rem .4rem; font-size: .85rem;">
          </div>
          <div style="flex: 1;">
            <label class="label" style="font-size: .8rem; margin-bottom: .2rem; display: block;">영상 시간</label>
            <select id="drama-category" style="padding: .25rem .4rem; font-size: .85rem;"></select>
          </div>
          <div style="flex: 1;">
            <label class="label" style="font-size: .8rem; margin-bottom: .2rem; display: block;">콘텐츠 유형</label>
            <select id="content-type" style="padding: .25rem .4rem; font-size: .85rem;">
              <option value="testimony">간증</option>
              <option value="drama">드라마</option>
            </select>
          </div>
        </div>
        <!-- 프롬프트 미리보기 토글 -->
        <div style="margin-top: .5rem;">
          <button id="btn-toggle-prompt-preview" style="width: 100%; padding: .3rem; font-size: .75rem; background: #f8f9fa; color: #666; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
            📝 Step3 프롬프트 미리보기 ▼
          </button>
          <div id="prompt-preview-container" style="display: none; margin-top: .4rem; padding: .5rem; background: #f8f9fa; border-radius: 6px; max-height: 200px; overflow-y: auto;">
            <div style="font-size: .7rem; color: #333; white-space: pre-wrap; line-height: 1.4;" id="prompt-preview-content">
              콘텐츠 유형을 선택하면 해당 프롬프트가 표시됩니다.
            </div>
          </div>
        </div>
      </div>

      <!-- 주인공 선택 -->
      <div class="box" style="padding: .5rem .75rem;">
        <label class="label" style="font-size: .8rem; margin-bottom: .3rem; display: block;">주인공 (선택사항)</label>
        <!-- 성별 선택 -->
        <div style="display: flex; gap: 1rem; margin-bottom: .4rem;">
          <label style="display: flex; align-items: center; gap: .3rem; cursor: pointer; font-size: .85rem;">
            <input type="radio" name="protagonist-gender" id="gender-male" value="male" style="cursor: pointer;">
            <span>👨 남성</span>
          </label>
          <label style="display: flex; align-items: center; gap: .3rem; cursor: pointer; font-size: .85rem;">
            <input type="radio" name="protagonist-gender" id="gender-female" value="female" style="cursor: pointer;">
            <span>👩 여성</span>
          </label>
          <span style="font-size: .7rem; color: #999; align-self: center;">(TTS 나레이션 목소리 자동 설정)</span>
        </div>
        <div style="display: flex; gap: .4rem; align-items: center;">
          <input type="text" id="main-character" placeholder="예: 60대 은퇴 목사, 70대 할머니 등" style="flex: 1; font-size: .85rem; padding: .3rem .4rem;">
          <button id="btn-random-character" style="padding: .3rem .6rem; font-size: .75rem; background: #9b59b6; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap;">🎲 랜덤</button>
        </div>
        <div style="font-size: .7rem; color: #666; margin-top: .3rem;">
          비워두면 AI가 자동으로 적절한 주인공을 설정합니다.
        </div>
      </div>

      <!-- 벤치마킹 대본 (축소) -->
      <div class="box">
        <label class="label" style="font-size: .9rem;">벤치마킹 대본</label>
        <textarea id="benchmark-script" placeholder="참고할 대본이나 스크립트를 여기에 붙여넣으세요." style="height: 80px; resize: none; font-size: .85rem;"></textarea>
      </div>

      <!-- AI 대본 분석 -->
      <div class="box" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; padding: .5rem;">
        <div style="color: white; font-weight: 600; font-size: .85rem; margin-bottom: .4rem;">📊 AI 대본 분석</div>
        <div style="background: white; border-radius: 6px; padding: .4rem; margin-bottom: .4rem;">
          <div style="display: flex; gap: .3rem; margin-bottom: .3rem;">
            <input type="text" id="benchmark-upload-date" placeholder="날짜" style="flex: 1; font-size: .7rem; padding: .25rem;">
            <input type="text" id="benchmark-view-count" placeholder="조회수" style="flex: 1; font-size: .7rem; padding: .25rem;">
          </div>
          <label style="display: flex; align-items: center; gap: .2rem; margin-bottom: .3rem; cursor: pointer;">
            <input type="checkbox" id="check-duplicates" style="cursor: pointer;">
            <span style="font-size: .7rem; color: #666;">중복 자료</span>
          </label>
          <button id="btn-analyze-benchmark" class="primary" style="width: 100%; font-size: .75rem; padding: .3rem;">분석</button>
        </div>
        <div style="background: white; border-radius: 6px; padding: .4rem; max-height: 60px; overflow-y: auto;">
          <div id="analysis-result" style="font-size: .7rem; color: #333; line-height: 1.3;">
            <p style="color: #999; text-align: center; font-size: .65rem;">
              분석 결과가 여기에 표시됩니다.
            </p>
          </div>
        </div>
        <button id="btn-view-accumulated-guide" style="width: 100%; margin-top: .4rem; background: white; color: #667eea; font-weight: 600; font-size: .7rem; padding: .3rem; border-radius: 6px; border: none; cursor: pointer;">📚 가이드 보기</button>
      </div>

      <!-- 저장 공간 -->
      <div class="box">
        <label class="label" style="font-size: .9rem;">저장된 드라마 자료</label>
        <button id="btn-save" style="width: 100%; margin-bottom: .5rem; font-size: .85rem; padding: .4rem;">현재 내용 저장</button>
        <div id="saved-list"></div>
      </div>

      <!-- Q&A 대화 -->
      <div class="box" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .5rem;">
          <label class="label" style="color: white; font-size: .9rem;">💬 AI 대화</label>
          <button onclick="DramaSession.clearHistory()" style="background: rgba(255,255,255,0.2); color: white; border: none; padding: .2rem .5rem; border-radius: 4px; font-size: .7rem; cursor: pointer;">기록 삭제</button>
        </div>
        <div id="qa-history" class="qa-history" style="background: white; border-radius: 8px; max-height: 200px; overflow-y: auto; margin-bottom: .5rem;">
          <div class="qa-empty-state">아직 대화가 없습니다.<br>대본이나 작업에 대해 궁금한 점을 물어보세요.</div>
        </div>
        <div class="qa-input-container" style="display: flex; gap: .3rem;">
          <input type="text" id="qa-input" placeholder="질문을 입력하세요..." style="flex: 1; padding: .4rem .5rem; border: none; border-radius: 6px; font-size: .8rem;" onkeypress="if(event.key==='Enter') DramaSession.sendQuestion()">
          <button onclick="DramaSession.sendQuestion()" style="background: white; color: #667eea; border: none; padding: .4rem .6rem; border-radius: 6px; font-weight: 600; font-size: .8rem; cursor: pointer;">전송</button>
        </div>
      </div>
      </div>
    </div>



    <div id="guide-panel" class="panel guide-panel active">
      <div class="box">
        <div class="label" style="font-size: 1rem;">🧭 작업 지침</div>
        <p style="margin: .4rem 0; color: #555;">왼쪽 버튼을 눌러 단계별 내용을 오른쪽 패널에서 바로 확인하세요. 새 창을 열지 않고도 모든 정보를 한 눈에 볼 수 있도록 정리했습니다.</p>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: .75rem;">
          <div class="box" style="background: #fef3c7; border: none;">
            <div class="label">워크플로우</div>
            <ul style="margin: .4rem 0; padding-left: 1rem; color: #92400e; font-size: .9rem; line-height: 1.6;">
              <li>Step1 대본 생성: 상황·캐릭터·구조를 정리하고 대본을 빌드</li>
              <li>Step2 이미지 생성: 씬별 프롬프트와 비주얼 톤 설계</li>
              <li>Step3 음성 합성: 화자 선택, 속도·피치·볼륨 조정</li>
              <li>Step4 영상 제작: 컷보드, 타임라인, 자막/효과 배치</li>
              <li>Step5 업로드: 제목·태그·썸네일·설명 최종 확정</li>
            </ul>
          </div>
          <div class="box" style="background: #eef2ff; border: none;">
            <div class="label">품질 체크</div>
            <ul style="margin: .4rem 0; padding-left: 1rem; color: #312e81; font-size: .9rem; line-height: 1.6;">
              <li>스토리 흐름: 갈등 → 고조 → 해결 순서를 유지</li>
              <li>감정선: 인물 감정 변화를 장면마다 명시</li>
              <li>시각화: 씬마다 구도/배경/조명을 적어 이미지와 연결</li>
              <li>톤 앤 매너: 채널 톤, 말투, 속도를 일관되게 유지</li>
              <li>리뷰: 업로드 전 체크리스트로 어조·오탈자 점검</li>
            </ul>
          </div>
        </div>
      </div>

      <div class="box" style="background: linear-gradient(135deg, #f97316 0%, #ef4444 100%); color: white;">
        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: .5rem;">
          <div class="label" style="color: white;">📚 축적된 작업 지침</div>
          <div style="display: flex; gap: .4rem; align-items: center;">
            <button id="btn-refresh-guide" style="background: rgba(255,255,255,0.15); color: white; border: none; padding: .45rem .75rem; border-radius: 8px; font-weight: 700; cursor: pointer;">가이드 불러오기</button>
            <button id="btn-open-guide-modal-panel" style="background: white; color: #ef4444; border: none; padding: .45rem .75rem; border-radius: 8px; font-weight: 700; cursor: pointer;">지침 관리</button>
          </div>
        </div>
        <div id="guide-panel-content" style="margin-top: .75rem; background: rgba(255,255,255,0.12); padding: .75rem; border-radius: 8px; min-height: 160px; white-space: pre-wrap; line-height: 1.6;">왼쪽의 "가이드 불러오기" 버튼을 눌러 축적된 작업 지침을 오른쪽에서 바로 확인하세요.</div>
      </div>
    </div>

    <div id="data-panel" class="panel data-panel">
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem;">
        <div class="box">
          <div class="label" style="font-size: 1rem;">📄 대본 작성 데이터 (텍스트)</div>
          <p style="margin: .35rem 0; color: #555;">현재 세션의 대본을 텍스트로 확인합니다. Step3 결과가 있을 경우 자동으로 불러옵니다.</p>
          <textarea id="data-text-view" style="min-height: 200px;">아직 불러온 대본이 없습니다. "데이터 새로고침" 버튼을 눌러 Step3 완성본을 가져오세요.</textarea>
          <div style="display: flex; gap: .5rem; margin-top: .5rem;">
            <button id="btn-refresh-dataset" class="primary" style="flex: 1;">데이터 새로고침</button>
            <button id="btn-copy-text-view" style="flex: 1;">텍스트 복사</button>
          </div>
        </div>
        <div class="box">
          <div class="label" style="font-size: 1rem;">🧾 대본 메타데이터 (JSON)</div>
          <p style="margin: .35rem 0; color: #555;">장면, 캐릭터, 톤 정보를 JSON 형태로 함께 확인하세요.</p>
          <pre id="data-json-view" style="background: #0f172a; color: #e2e8f0; padding: .75rem; border-radius: 10px; min-height: 200px; white-space: pre-wrap; overflow: auto;">{
  "title": "",
  "scenes": [],
  "tone": "",
  "voices": []
}</pre>
          <div style="display: flex; gap: .5rem; margin-top: .5rem;">
            <button id="btn-copy-json" style="flex: 1;">JSON 복사</button>
            <button id="btn-open-json" style="flex: 1;" data-panel-target="workflow-panel" data-scroll-target="step3-container">워크플로우로 이동</button>
          </div>
        </div>
      </div>

      <div class="box">
        <div class="label" style="font-size: 1rem;">🔎 벤치마킹 대본 분석</div>
        <p style="margin: .35rem 0; color: #555;">벤치마킹할 대본을 입력하면 길이·키워드·감정 톤을 간단히 요약해줍니다.</p>
        <textarea id="benchmark-analysis-input" placeholder="벤치마킹 대본을 붙여 넣으세요." style="min-height: 120px;"></textarea>
        <div style="display: flex; gap: .5rem; margin-top: .5rem; align-items: center;">
          <input type="text" id="benchmark-tag" placeholder="분석 태그 (예: 감동, 코믹)" style="flex: 1; padding: .45rem .6rem;">
          <button id="btn-run-benchmark-analysis" class="primary" style="flex-shrink: 0;">분석하기</button>
        </div>
        <div id="benchmark-analysis-output" style="margin-top: .6rem; background: #f8fafc; border-radius: 10px; padding: .75rem; min-height: 80px; border: 1px dashed #cbd5e1; color: #0f172a;"></div>
      </div>
    </div>

    <!-- 가운데 - 워크플로우 영역 -->
    <div id="workflow-panel" class="panel workflow-panel">
    <div class="content-area">
      <!-- Step1 앵커 및 컨트롤 -->
      <div id="step1-container"></div>

      <!-- Step2 앵커 및 컨트롤 -->
      <div id="step2-container"></div>

      <!-- Step3 앵커 및 전체 순차실행 -->
      <div id="step3-container"></div>

      <!-- 워크플로우 박스들이 동적으로 추가되는 영역 (카테고리/시간/지침 입력) -->
      <div id="workflow-boxes-container"></div>

      <!-- Step3 실행: Sonnet 4.5 대본 작성 -->
      <div class="box" style="padding: .6rem .75rem;">
        <button id="btn-execute-step3" class="primary" style="width: 100%; font-size: .9rem; padding: .65rem;">
          🎬 Claude Sonnet 4.5로 대본 작성
        </button>
        <div style="font-size: .75rem; color: #555; margin-top: .35rem; text-align: center;">
          OpenRouter의 Claude Sonnet 4.5 기본 프롬프트로 최종 대본을 생성합니다.
        </div>
      </div>

      <!-- 상태 표시 -->
      <div id="status-bar" class="status-bar">작업 중...</div>

      <!-- Step3 결과 박스 -->
      <div id="step3-result-container" class="step3-result-box" style="display: none;">
        <div class="step-header">
          <div class="label">🎬 Step1: OpenRouter 대본 완성 결과</div>
          <div style="display: flex; gap: .5rem;">
            <button id="btn-toggle-script-view" style="padding: .4rem .8rem; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: .85rem;">📖 대본 보기</button>
            <button id="btn-copy-step3-result" style="padding: .4rem .8rem; background: white; color: #f39c12; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: .85rem;">📋 복사</button>
            <button id="btn-clear-step3-result" style="padding: .4rem .8rem; background: rgba(255,255,255,0.3); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: .85rem;">🗑️ 지우기</button>
          </div>
        </div>
        <div id="step3-token-info" style="font-size: .75rem; color: rgba(255,255,255,0.9); margin-bottom: .5rem; display: none;">
          📥 <span id="step3-input-tokens">0</span> (입력) / 📤 <span id="step3-output-tokens">0</span> (출력) | 💰 <span id="step3-cost">₩0</span>
        </div>
        <!-- JSON 원본 뷰 -->
        <textarea id="step3-result" readonly style="width: 100%; font-size: .9rem; line-height: 1.6; resize: vertical;" placeholder="Step3 결과가 여기에 표시됩니다..."></textarea>
        <!-- 대본 텍스트 뷰 -->
        <div id="step3-script-viewer" style="display: none; background: white; border-radius: 8px; padding: 1rem; max-height: 600px; overflow-y: auto;">
          <div id="step3-script-content" style="font-size: .95rem; line-height: 1.8; color: #333;"></div>
        </div>
      </div>

      <!-- Step4: 이미지 생성 -->
      <div id="step4-container" class="step4-container" style="display: none;">
        <div class="step-header">
          <div class="label">🎨 Step2: 장면 이미지 생성</div>
          <div style="display: flex; gap: .5rem;">
            <button id="btn-generate-all-auto" class="step4-btn" style="background: linear-gradient(135deg, #ff6b6b, #ee5a6f); color: white; font-weight: 700; padding: .5rem 1rem;">🚀 전체 생성</button>
            <button id="btn-clear-step4" class="step4-btn" style="background: rgba(255,255,255,0.3); color: white;">🗑️ 초기화</button>
          </div>
        </div>

        <!-- 전체 자동 생성 진행 상황 -->
        <div id="auto-generate-progress" style="display: none; background: linear-gradient(135deg, #667eea, #764ba2); border-radius: 8px; padding: 1rem; margin-bottom: .75rem; color: white;">
          <div style="font-weight: 600; margin-bottom: .5rem;">🤖 전체 자동 생성 진행 중...</div>
          <div id="auto-generate-status" style="font-size: .85rem; margin-bottom: .5rem;">준비 중...</div>
          <div style="background: rgba(255,255,255,0.3); border-radius: 4px; height: 8px; overflow: hidden;">
            <div id="auto-generate-progress-bar" style="background: white; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
          </div>
          <div id="auto-generate-details" style="font-size: .75rem; margin-top: .5rem; opacity: 0.9;"></div>
        </div>

        <!-- 1단계: 인물 분석 -->
        <div class="step4-prompt-section">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .5rem;">
            <div class="prompt-label">👥 1단계: 등장인물 분석</div>
            <button id="btn-analyze-characters" class="step4-btn" style="padding: .4rem .8rem; font-size: .85rem;">🔍 대본에서 인물 추출</button>
          </div>
          <div id="step4-characters-list" style="background: rgba(255,255,255,0.95); border-radius: 8px; padding: .75rem; min-height: 60px;">
            <div style="color: #999; text-align: center; font-size: .85rem;">대본을 분석하면 등장인물이 여기에 표시됩니다</div>
          </div>
        </div>

        <!-- 2단계: 인물 이미지 생성 -->
        <div class="step4-prompt-section">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .5rem;">
            <div class="prompt-label">👤 2단계: 인물 이미지 생성</div>
            <div style="display: flex; gap: .5rem; align-items: center;">
              <select id="step4-character-select" style="padding: .4rem; border-radius: 6px; border: 1px solid #ddd; font-size: .85rem; min-width: 120px;">
                <option value="">-- 인물 선택 --</option>
              </select>
              <button id="btn-generate-character-image" class="step4-btn" style="padding: .4rem .8rem; font-size: .85rem;">🖼️ 인물 이미지 생성</button>
            </div>
          </div>
          <textarea id="step4-character-prompt" placeholder="선택한 인물의 이미지 프롬프트가 여기에 표시됩니다. 직접 수정도 가능합니다."></textarea>
          <div id="step4-character-images" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: .5rem; margin-top: .5rem;"></div>
        </div>

        <!-- 3단계: 씬 이미지 생성 -->
        <div class="step4-prompt-section">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .5rem;">
            <div class="prompt-label">🎬 3단계: 씬 이미지 생성</div>
            <div style="display: flex; gap: .5rem; align-items: center; flex-wrap: wrap;">
              <select id="step4-scene-select" style="padding: .4rem; border-radius: 6px; border: 1px solid #ddd; font-size: .85rem; min-width: 120px;">
                <option value="">-- 씬 선택 --</option>
              </select>
              <button id="btn-generate-scene-prompt" class="step4-btn" style="padding: .4rem .8rem; font-size: .85rem;">📝 프롬프트만</button>
              <button id="btn-generate-scene-all" class="step4-btn" style="padding: .4rem .8rem; font-size: .85rem; background: linear-gradient(135deg, #10b981, #059669); font-weight: 700;">🎬 프롬프트+이미지</button>
            </div>
          </div>

          <div style="margin-bottom: .5rem;">
            <div style="font-size: .8rem; color: rgba(255,255,255,0.9); margin-bottom: .25rem;">🏞️ 배경 프롬프트</div>
            <textarea id="step4-background-prompt" placeholder="씬의 배경 프롬프트가 여기에 표시됩니다."></textarea>
          </div>

          <div style="margin-bottom: .5rem;">
            <div style="font-size: .8rem; color: rgba(255,255,255,0.9); margin-bottom: .25rem;">👥 등장 인물 (씬에 포함될 인물 선택)</div>
            <div id="step4-scene-characters" style="display: flex; flex-wrap: wrap; gap: .5rem; background: rgba(255,255,255,0.1); padding: .5rem; border-radius: 6px; min-height: 40px;">
              <span style="color: rgba(255,255,255,0.6); font-size: .85rem;">인물 분석 후 선택 가능</span>
            </div>
          </div>

          <div>
            <div style="font-size: .8rem; color: rgba(255,255,255,0.9); margin-bottom: .25rem;">🎭 통합 씬 프롬프트 (인물 + 배경)</div>
            <textarea id="step4-combined-prompt" placeholder="인물들이 배경에 자연스럽게 어울리는 통합 장면 프롬프트입니다."></textarea>
          </div>
        </div>

        <!-- 이미지 모델 선택 -->
        <div style="display: flex; gap: .5rem; margin-bottom: .5rem; flex-wrap: wrap;">
          <button class="step4-image-provider selected" data-provider="gemini" style="flex: 1; min-width: 100px; padding: .5rem; border: 2px solid #10b981; border-radius: 8px; background: rgba(16,185,129,0.2); cursor: pointer; font-weight: 600; font-size: .85rem;">
            ✨ Gemini<br><span style="font-size: .7rem; font-weight: normal; color: #666;">$0.039/장 (빠름)</span>
          </button>
          <button class="step4-image-provider" data-provider="flux" style="flex: 1; min-width: 100px; padding: .5rem; border: 2px solid #ddd; border-radius: 8px; background: white; cursor: pointer; font-weight: 600; font-size: .85rem;">
            ⚡ FLUX.1 Pro<br><span style="font-size: .7rem; font-weight: normal; color: #666;">$0.055/장 (고품질)</span>
          </button>
          <button class="step4-image-provider" data-provider="dalle" style="flex: 1; min-width: 100px; padding: .5rem; border: 2px solid #ddd; border-radius: 8px; background: white; cursor: pointer; font-weight: 600; font-size: .85rem;">
            🎨 DALL-E 3<br><span style="font-size: .7rem; font-weight: normal; color: #666;">$0.08/장 (창의적)</span>
          </button>
        </div>

        <!-- 이미지 생성 버튼 영역 -->
        <div style="display: flex; gap: .5rem; margin-bottom: .75rem;">
          <button id="btn-generate-image" class="step4-btn" style="flex: 1; padding: .75rem; font-size: .95rem; font-weight: 700;">
            🖼️ 씬 이미지 생성 (Gemini)
          </button>
          <select id="step4-image-size" style="padding: .5rem; border-radius: 6px; border: 1px solid #ddd; font-size: .85rem;">
            <option value="1024x1024">1024x1024 (정사각형)</option>
            <option value="1792x1024" selected>1792x1024 (가로형)</option>
            <option value="1024x1792">1024x1792 (세로형)</option>
          </select>
        </div>

        <!-- 유튜브 썸네일 자동 생성 -->
        <div style="background: white; border-radius: 8px; padding: .75rem; margin-bottom: .75rem;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .5rem;">
            <div>
              <div style="font-weight: 700; font-size: .95rem; color: #333;">🎬 유튜브 썸네일 (자동 생성)</div>
              <div style="font-size: .75rem; color: #666; margin-top: .25rem;">AI가 대본을 분석하여 클릭을 유도하는 썸네일을 만듭니다</div>
            </div>
            <button id="btn-generate-thumbnail" class="step4-btn" style="padding: .5rem 1rem; font-size: .85rem; background: linear-gradient(135deg, #ff6b6b, #ee5a6f);">
              📸 썸네일 생성
            </button>
          </div>

          <div id="step4-thumbnail-preview" style="display: none; margin-top: .75rem;">
            <div style="display: flex; gap: .75rem; align-items: flex-start; padding: .75rem; background: #f8f9fa; border-radius: 6px;">
              <div style="position: relative;">
                <img id="step4-thumbnail-image" style="width: 240px; height: 135px; border-radius: 6px; border: 2px solid #ff6b6b; object-fit: cover;" />
                <div id="step4-thumbnail-text-overlay" style="position: absolute; bottom: 10px; left: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: .5rem; border-radius: 4px; font-weight: 700; font-size: .9rem; text-align: center;">
                  썸네일 텍스트
                </div>
              </div>
              <div style="flex: 1;">
                <div style="font-size: .85rem; color: #333; line-height: 1.6;">
                  <p style="margin: 0 0 .5rem 0; font-weight: 600; color: #ff6b6b;">✅ 유튜브 썸네일</p>
                  <p style="margin: 0 0 .5rem 0; font-size: .8rem; color: #666;">이 이미지가 유튜브 업로드 시 썸네일로 사용됩니다</p>
                  <div style="margin-top: .75rem; padding: .5rem; background: white; border-radius: 4px; font-size: .75rem; color: #666;">
                    <strong>프롬프트:</strong> <span id="step4-thumbnail-prompt">-</span>
                  </div>
                  <button id="btn-regenerate-thumbnail" style="margin-top: .5rem; padding: .4rem .8rem; font-size: .8rem; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer;">
                    🔄 다시 생성
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- 생성된 이미지 표시 영역 -->
        <div id="step4-image-result" style="background: white; border-radius: 8px; padding: .75rem; min-height: 100px;">
          <div id="step4-image-placeholder" style="text-align: center; color: #999; padding: 2rem;">
            <div style="font-size: 2rem; margin-bottom: .5rem;">🖼️</div>
            <p>이미지를 생성하면 여기에 표시됩니다</p>
          </div>
          <div id="step4-image-grid" class="step4-image-grid" style="display: none;"></div>
        </div>

        <!-- 토큰/비용 정보 -->
        <div id="step4-cost-info" style="font-size: .75rem; color: rgba(255,255,255,0.9); margin-top: .5rem; display: none;">
          🖼️ 이미지 생성 비용: <span id="step4-image-cost">₩0</span>
        </div>
      </div>

      <!-- Step5: TTS 음성 합성 및 자막 생성 -->
      <div id="step5-container" class="step5-container" style="display: none;">
        <div class="step-header">
          <div class="label">🎙️ Step3: 음성 합성 (TTS) & 자막</div>
          <div style="display: flex; gap: .5rem;">
            <button id="btn-clear-step5" class="step5-btn" style="background: rgba(255,255,255,0.3); color: white;">🗑️ 초기화</button>
          </div>
        </div>

        <!-- TTS 제공자 선택 -->
        <div class="step5-section">
          <div class="section-label">🔊 TTS 제공자</div>
          <div style="display: flex; gap: .5rem; margin-bottom: .75rem;">
            <button class="step5-tts-provider selected" data-provider="google" style="flex: 1; padding: .5rem; border: 2px solid #10b981; border-radius: 8px; background: rgba(16,185,129,0.2); cursor: pointer; font-weight: 600;">
              🌐 Google Cloud<br><span style="font-size: .7rem; font-weight: normal; color: #666;">₩16/3000자 (저렴)</span>
            </button>
            <button class="step5-tts-provider" data-provider="naver" style="flex: 1; padding: .5rem; border: 2px solid #ddd; border-radius: 8px; background: white; cursor: pointer; font-weight: 600;">
              🇰🇷 네이버 클로바<br><span style="font-size: .7rem; font-weight: normal; color: #666;">₩12,000/3000자 (고품질)</span>
            </button>
          </div>
        </div>

        <!-- 음성 선택 영역 -->
        <div class="step5-section">
          <div class="section-label" id="step5-voice-label">🎤 음성 선택 (Google Cloud) <span style="font-size: .75rem; font-weight: normal; color: rgba(255,255,255,0.7);">- 클릭하여 미리듣기</span></div>

          <!-- Google TTS 음성 -->
          <div id="step5-voice-google" class="step5-voice-select">
            <div class="step5-voice-option selected" data-voice="ko-KR-Wavenet-A" data-provider="google">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-weight: 600;">여성 A</div>
                  <div style="font-size: .7rem; color: #666;">Wavenet (자연스러움)</div>
                </div>
                <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('ko-KR-Wavenet-A', 'google')">▶️</button>
              </div>
            </div>
            <div class="step5-voice-option" data-voice="ko-KR-Wavenet-B" data-provider="google">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-weight: 600;">여성 B</div>
                  <div style="font-size: .7rem; color: #666;">Wavenet</div>
                </div>
                <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('ko-KR-Wavenet-B', 'google')">▶️</button>
              </div>
            </div>
            <div class="step5-voice-option" data-voice="ko-KR-Wavenet-C" data-provider="google">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-weight: 600;">남성 A</div>
                  <div style="font-size: .7rem; color: #666;">Wavenet</div>
                </div>
                <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('ko-KR-Wavenet-C', 'google')">▶️</button>
              </div>
            </div>
            <div class="step5-voice-option" data-voice="ko-KR-Wavenet-D" data-provider="google">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-weight: 600;">남성 B</div>
                  <div style="font-size: .7rem; color: #666;">Wavenet</div>
                </div>
                <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('ko-KR-Wavenet-D', 'google')">▶️</button>
              </div>
            </div>
            <div class="step5-voice-option" data-voice="ko-KR-Neural2-A" data-provider="google">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-weight: 600;">여성 (Neural)</div>
                  <div style="font-size: .7rem; color: #666;">Neural2 (최고품질)</div>
                </div>
                <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('ko-KR-Neural2-A', 'google')">▶️</button>
              </div>
            </div>
            <div class="step5-voice-option" data-voice="ko-KR-Neural2-C" data-provider="google">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-weight: 600;">남성 (Neural)</div>
                  <div style="font-size: .7rem; color: #666;">Neural2 (최고품질)</div>
                </div>
                <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('ko-KR-Neural2-C', 'google')">▶️</button>
              </div>
            </div>
          </div>

          <!-- 네이버 TTS 음성 (숨김) -->
          <div id="step5-voice-naver" class="step5-voice-select" style="display: none;">
            <div class="step5-voice-option" data-voice="nara" data-provider="naver">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-weight: 600;">나라</div>
                  <div style="font-size: .7rem; color: #666;">여성 (기본)</div>
                </div>
                <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('nara', 'naver')">▶️</button>
              </div>
            </div>
            <div class="step5-voice-option" data-voice="nara_call" data-provider="naver">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-weight: 600;">나라 (밝음)</div>
                  <div style="font-size: .7rem; color: #666;">여성 (경쾌)</div>
                </div>
                <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('nara_call', 'naver')">▶️</button>
              </div>
            </div>
            <div class="step5-voice-option" data-voice="nminsang" data-provider="naver">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-weight: 600;">민상</div>
                  <div style="font-size: .7rem; color: #666;">남성</div>
                </div>
                <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('nminsang', 'naver')">▶️</button>
              </div>
            </div>
            <div class="step5-voice-option" data-voice="njiyun" data-provider="naver">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-weight: 600;">지윤</div>
                  <div style="font-size: .7rem; color: #666;">여성 (밝음)</div>
                </div>
                <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('njiyun', 'naver')">▶️</button>
              </div>
            </div>
            <div class="step5-voice-option" data-voice="nsujin" data-provider="naver">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-weight: 600;">수진</div>
                  <div style="font-size: .7rem; color: #666;">여성 (차분)</div>
                </div>
                <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('nsujin', 'naver')">▶️</button>
              </div>
            </div>
            <div class="step5-voice-option" data-voice="jinho" data-provider="naver">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <div style="font-weight: 600;">진호</div>
                  <div style="font-size: .7rem; color: #666;">남성 (차분)</div>
                </div>
                <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('jinho', 'naver')">▶️</button>
              </div>
            </div>
          </div>
        </div>

        <!-- TTS 설정 -->
        <div class="step5-section">
          <div class="section-label">⚙️ 음성 설정</div>
          <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
            <div style="flex: 1; min-width: 100px;">
              <label style="font-size: .8rem; color: #666;">속도</label>
              <input type="range" id="step5-speed" min="-5" max="5" value="-1" style="width: 100%;">
              <div style="display: flex; justify-content: space-between; font-size: .7rem; color: #999;">
                <span>느림</span><span>보통</span><span>빠름</span>
              </div>
            </div>
            <div style="flex: 1; min-width: 100px;">
              <label style="font-size: .8rem; color: #666;">음높이</label>
              <input type="range" id="step5-pitch" min="-5" max="5" value="0" style="width: 100%;">
              <div style="display: flex; justify-content: space-between; font-size: .7rem; color: #999;">
                <span>낮음</span><span>보통</span><span>높음</span>
              </div>
            </div>
            <div style="flex: 1; min-width: 100px;">
              <label style="font-size: .8rem; color: #666;">볼륨</label>
              <input type="range" id="step5-volume" min="-5" max="5" value="0" style="width: 100%;">
              <div style="display: flex; justify-content: space-between; font-size: .7rem; color: #999;">
                <span>작음</span><span>보통</span><span>큼</span>
              </div>
            </div>
          </div>
        </div>

        <!-- 대본 텍스트 (TTS용) -->
        <div class="step5-section">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .4rem;">
            <div class="section-label">📜 TTS용 대본 텍스트</div>
            <button id="btn-extract-narration" class="step5-btn" style="padding: .3rem .6rem; font-size: .75rem;">📝 지문만 추출</button>
          </div>
          <textarea id="step5-script-text" style="width: 100%; min-height: 120px; border: 1px solid #ddd; border-radius: 6px; padding: .5rem; font-size: .85rem; resize: vertical;" placeholder="Step3 대본에서 TTS로 읽을 텍스트를 입력하세요. '지문만 추출' 버튼으로 나레이션 부분만 추출할 수 있습니다."></textarea>
        </div>

        <!-- TTS 생성 버튼 -->
        <div style="display: flex; gap: .5rem; margin-bottom: .75rem;">
          <button id="btn-generate-tts" class="step5-btn" style="flex: 1; padding: .75rem; font-size: .95rem; font-weight: 700;">
            🎙️ 음성 생성 (TTS)
          </button>
          <button id="btn-generate-subtitle" class="step5-btn" style="flex: 1; padding: .75rem; font-size: .95rem; font-weight: 700;">
            📝 자막 생성 (SRT)
          </button>
        </div>

        <!-- 오디오 플레이어 -->
        <div class="step5-section" id="step5-audio-section" style="display: none;">
          <div class="section-label">🔊 생성된 음성</div>
          <audio id="step5-audio-player" class="step5-audio-player" controls></audio>
          <div style="display: flex; gap: .5rem; margin-top: .5rem;">
            <button id="btn-download-audio" class="step5-btn" style="flex: 1; padding: .4rem;">💾 음성 다운로드 (MP3)</button>
          </div>
        </div>

        <!-- 자막 미리보기 -->
        <div class="step5-section" id="step5-subtitle-section" style="display: none;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .4rem;">
            <div class="section-label">📝 자막 미리보기</div>
            <div style="display: flex; gap: .5rem;">
              <button id="btn-download-srt" class="step5-btn" style="padding: .3rem .6rem; font-size: .75rem;">💾 SRT 다운로드</button>
              <button id="btn-download-vtt" class="step5-btn" style="padding: .3rem .6rem; font-size: .75rem;">💾 VTT 다운로드</button>
            </div>
          </div>
          <div id="step5-subtitle-preview" class="step5-subtitle-preview">
            자막이 여기에 표시됩니다...
          </div>
        </div>

        <!-- 비용 정보 -->
        <div id="step5-cost-info" style="font-size: .75rem; color: rgba(255,255,255,0.9); margin-top: .5rem; display: none;">
          🎙️ TTS 생성 비용: <span id="step5-tts-cost">₩0</span> | 글자 수: <span id="step5-char-count">0</span>자
        </div>
      </div>

      <!-- Step6: 영상 제작 -->
      <div id="step6-container" class="step6-container">
        <div class="step-header">
          <div class="label">🎬 Step4: 영상 제작</div>
          <div style="display: flex; gap: .5rem;">
            <button id="btn-clear-step6" class="step6-btn" style="background: rgba(255,255,255,0.3); color: white;">🗑️ 초기화</button>
          </div>
        </div>

        <!-- 이미지 선택 영역 -->
        <div class="step6-section">
          <div class="section-label">🖼️ 사용할 이미지 선택 (Step2에서 생성)</div>
          <div id="step6-image-grid" class="step6-preview-grid">
            <div style="color: #999; text-align: center; padding: 1rem; grid-column: 1/-1;">
              Step2에서 이미지를 생성하면 여기에 표시됩니다
            </div>
          </div>
        </div>

        <!-- 오디오 선택 영역 -->
        <div class="step6-section">
          <div class="section-label">🎙️ 사용할 음성 (Step3에서 생성)</div>
          <div id="step6-audio-status" style="padding: .5rem; background: #f8f9fa; border-radius: 6px; font-size: .85rem; color: #666;">
            Step3에서 음성을 생성하면 자동으로 연결됩니다
          </div>
          <audio id="step6-audio-preview" style="width: 100%; margin-top: .5rem; display: none;" controls></audio>
        </div>

        <!-- 자막 옵션 -->
        <div class="step6-section">
          <div class="section-label">📝 자막 옵션</div>
          <div style="display: flex; gap: 1rem; align-items: center;">
            <label style="display: flex; align-items: center; gap: .3rem; cursor: pointer;">
              <input type="checkbox" id="step6-include-subtitle" checked>
              <span style="font-size: .85rem;">자막 포함</span>
            </label>
            <label style="display: flex; align-items: center; gap: .3rem; cursor: pointer;">
              <input type="checkbox" id="step6-burn-subtitle" checked>
              <span style="font-size: .85rem;">자막 하드코딩 (영상에 굽기)</span>
            </label>
          </div>
        </div>

        <!-- 영상 설정 -->
        <div class="step6-section">
          <div class="section-label">⚙️ 영상 설정</div>
          <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
            <div style="flex: 1; min-width: 120px;">
              <label style="font-size: .8rem; color: #666;">해상도</label>
              <select id="step6-resolution" style="width: 100%; padding: .4rem; border-radius: 6px; border: 1px solid #ddd;">
                <option value="1920x1080">1920x1080 (FHD)</option>
                <option value="1280x720">1280x720 (HD)</option>
                <option value="1080x1920">1080x1920 (세로형)</option>
                <option value="1080x1080">1080x1080 (정사각형)</option>
              </select>
            </div>
            <div style="flex: 1; min-width: 120px;">
              <label style="font-size: .8rem; color: #666;">FPS</label>
              <select id="step6-fps" style="width: 100%; padding: .4rem; border-radius: 6px; border: 1px solid #ddd;">
                <option value="24">24 fps (영화)</option>
                <option value="30" selected>30 fps (표준)</option>
                <option value="60">60 fps (부드러움)</option>
              </select>
            </div>
            <div style="flex: 1; min-width: 120px;">
              <label style="font-size: .8rem; color: #666;">이미지 전환 효과</label>
              <select id="step6-transition" style="width: 100%; padding: .4rem; border-radius: 6px; border: 1px solid #ddd;">
                <option value="none">없음</option>
                <option value="fade" selected>페이드</option>
                <option value="crossfade">크로스페이드</option>
              </select>
            </div>
          </div>
        </div>

        <!-- 영상 생성 버튼 -->
        <div style="display: flex; gap: .5rem; margin-bottom: .75rem;">
          <button id="btn-generate-video" class="step6-btn" style="flex: 1; padding: .75rem; font-size: .95rem; font-weight: 700;">
            🎬 영상 생성
          </button>
        </div>

        <!-- 영상 미리보기 -->
        <div class="step6-section" id="step6-video-section" style="display: none;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .4rem;">
            <div class="section-label">🎥 생성된 영상</div>
            <button id="btn-download-video" class="step6-btn" style="padding: .3rem .6rem; font-size: .75rem;">💾 다운로드 (MP4)</button>
          </div>
          <div class="step6-video-preview">
            <video id="step6-video-player" controls></video>
          </div>
        </div>

        <!-- 진행 상태 -->
        <div id="step6-progress" style="display: none;">
          <div style="background: white; border-radius: 8px; padding: .75rem;">
            <div style="font-size: .85rem; color: #333; margin-bottom: .5rem;">
              <span id="step6-progress-text">영상 생성 중...</span>
            </div>
            <div style="background: #e0e0e0; border-radius: 4px; height: 8px; overflow: hidden;">
              <div id="step6-progress-bar" style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); height: 100%; width: 0%; transition: width 0.3s;"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Step7: 유튜브 업로드 - 비활성화됨 -->
      <div id="step7-container" class="step7-container" style="display: none !important;">
        <div class="step-header">
          <div class="label">📺 Step5: 유튜브 업로드</div>
          <div style="display: flex; gap: .5rem;">
            <button id="btn-youtube-auth" class="step7-btn">🔑 YouTube 연결</button>
          </div>
        </div>

        <!-- 인증 상태 -->
        <div class="step7-section">
          <div id="youtube-auth-status" style="padding: .5rem; background: #fff3cd; border-radius: 6px; font-size: .85rem; color: #856404;">
            ⚠️ YouTube 계정을 연결해주세요
          </div>
        </div>

        <!-- 채널 선택 -->
        <div class="step7-section" id="youtube-channel-section" style="display: none; background: linear-gradient(135deg, #e8f5e9, #fff); border: 2px solid #4caf50; box-shadow: 0 0 10px rgba(76,175,80,0.3);">
          <div class="section-label" style="color: #2e7d32;">📺 업로드 채널 선택 (필수)</div>
          <select id="step7-channel-select" class="step7-input" style="cursor: pointer; border: 2px solid #4caf50;">
            <option value="">채널을 선택하세요</option>
          </select>
          <div style="margin-top: 0.5rem; font-size: 0.85rem; color: #2e7d32;">
            ✅ 채널이 로드되었습니다. 위에서 업로드할 채널을 선택해주세요.
          </div>
        </div>

        <!-- 영상 정보 입력 -->
        <div class="step7-section">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .5rem;">
            <div class="section-label" style="margin-bottom: 0;">📝 영상 정보</div>
            <button id="btn-auto-metadata" class="step7-btn" style="padding: .4rem .8rem; font-size: .8rem;">🤖 대본 기반 자동 입력</button>
          </div>
          <input type="text" id="step7-title" class="step7-input" placeholder="영상 제목" maxlength="100">
          <textarea id="step7-description" class="step7-input" style="min-height: 80px; resize: vertical;" placeholder="영상 설명&#10;&#10;해시태그, 링크 등을 포함할 수 있습니다." maxlength="5000"></textarea>
          <input type="text" id="step7-tags" class="step7-input" placeholder="태그 (쉼표로 구분: 드라마, 단편영화, 감동)" maxlength="500">
        </div>

        <!-- 공개 설정 -->
        <div class="step7-section">
          <div class="section-label">🔒 공개 설정</div>
          <div id="step7-privacy-options">
            <label class="step7-privacy-option" data-privacy="private">
              <input type="radio" name="step7-privacy" value="private" style="display: none;">
              🔒 비공개
            </label>
            <label class="step7-privacy-option" data-privacy="unlisted">
              <input type="radio" name="step7-privacy" value="unlisted" style="display: none;">
              🔗 일부공개
            </label>
            <label class="step7-privacy-option" data-privacy="public">
              <input type="radio" name="step7-privacy" value="public" style="display: none;">
              🌍 공개
            </label>
            <label class="step7-privacy-option selected" data-privacy="scheduled">
              <input type="radio" name="step7-privacy" value="scheduled" checked style="display: none;">
              📅 예약 (30분 후 공개)
            </label>
          </div>
        </div>

        <!-- 카테고리 -->
        <div class="step7-section">
          <div class="section-label">📁 카테고리</div>
          <select id="step7-category" class="step7-input" style="margin-bottom: 0;">
            <option value="22">사람 및 블로그</option>
            <option value="24">엔터테인먼트</option>
            <option value="1">영화 및 애니메이션</option>
            <option value="10">음악</option>
            <option value="23">코미디</option>
            <option value="27">교육</option>
            <option value="25">뉴스 및 정치</option>
            <option value="26">노하우 및 스타일</option>
          </select>
        </div>

        <!-- 업로드 버튼 -->
        <div style="display: flex; gap: .5rem; margin-bottom: .5rem;">
          <button id="btn-upload-youtube" class="step7-btn" style="flex: 1; padding: .75rem; font-size: .95rem; font-weight: 700;" disabled>
            📺 YouTube에 업로드
          </button>
        </div>

        <!-- 업로드 상태 메시지 -->
        <div id="step7-upload-status" style="padding: .4rem .6rem; background: #fff3cd; border-radius: 6px; font-size: .8rem; color: #856404; margin-bottom: .75rem;">
          Step4에서 영상을 먼저 생성해주세요
        </div>

        <!-- 업로드 진행 상태 -->
        <div id="step7-progress" style="display: none;">
          <div style="background: white; border-radius: 8px; padding: .75rem;">
            <div style="font-size: .85rem; color: #333; margin-bottom: .5rem;">
              <span id="step7-progress-text">업로드 준비 중...</span>
            </div>
            <div style="background: #e0e0e0; border-radius: 4px; height: 8px; overflow: hidden;">
              <div id="step7-progress-bar" style="background: linear-gradient(135deg, #ff0000 0%, #cc0000 100%); height: 100%; width: 0%; transition: width 0.3s;"></div>
            </div>
          </div>
        </div>

        <!-- 업로드 결과 -->
        <div class="step7-section" id="step7-result" style="display: none;">
          <div class="section-label">✅ 업로드 완료</div>
          <div style="padding: .5rem; background: #d4edda; border-radius: 6px;">
            <a id="step7-video-link" href="#" target="_blank" style="color: #155724; font-weight: 600; text-decoration: none;">
              🎬 업로드된 영상 보기
            </a>
          </div>
        </div>
      </div>
    </div>

  </div>

  <!-- 패스워드 모달 -->
  <div id="modal-password" class="modal">
    <div class="modal-content">
      <div class="modal-title">🔒 지침 영역 잠금</div>
      <p style="color: #666; font-size: .9rem; margin-bottom: 1rem;">지침 영역에 접근하려면 패스워드를 입력하세요.</p>
      <input type="password" id="password-input" placeholder="패스워드 입력" style="margin-bottom: .5rem;">
      <div class="modal-buttons">
        <button id="btn-cancel-password">취소</button>
        <button id="btn-submit-password" class="primary">확인</button>
      </div>
    </div>
  </div>

  <!-- GPT PRO 패스워드 모달 -->
  <div id="modal-gpt-pro-password" class="modal">
    <div class="modal-content">
      <div class="modal-title">🔒 GPT PRO 실행 (테스트 중)</div>
      <p style="color: #666; font-size: .9rem; margin-bottom: 1rem;">이 기능은 현재 테스트 중입니다. 패스워드를 입력하세요.</p>
      <input type="password" id="gpt-pro-password-input" placeholder="패스워드 입력" style="margin-bottom: .5rem;">
      <div class="modal-buttons">
        <button id="btn-cancel-gpt-pro-password">취소</button>
        <button id="btn-submit-gpt-pro-password" class="primary">확인</button>
      </div>
    </div>
  </div>

  <!-- 작업 지침 관리 모달 -->
  <div id="modal-guide-management" class="modal">
    <div class="modal-content" style="max-width: 800px; width: 90%; max-height: 90vh; display: flex; flex-direction: column;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <div class="modal-title" style="margin: 0;">📝 작업 지침 관리</div>
        <div style="display: flex; gap: .5rem;">
          <button id="btn-modal-save-guides" style="padding: .4rem 1rem; background: #27ae60; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: .9rem;">💾 저장</button>
          <button id="btn-close-guide-modal" style="padding: .4rem 1rem; background: #e74c3c; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: .9rem;">닫기</button>
        </div>
      </div>
      <div style="font-size: .85rem; color: #666; margin-bottom: 1rem; padding: .75rem; background: #f8f9fa; border-radius: 6px;">
        모든 Step(1~7)의 작업 지침과 JSON 스타일 가이드를 한 곳에서 관리합니다. 수정 후 <strong>💾 저장</strong> 버튼을 눌러주세요.
      </div>
      <div id="modal-guide-container" style="flex: 1; overflow-y: auto; padding-right: .5rem;">
        <p style="color: #999; text-align: center; padding: 2rem;">작업 박스를 추가하면 여기에 표시됩니다.</p>
      </div>
    </div>
  </div>

  <!-- 영상 시간 관리 모달 -->
  <div id="modal-categories" class="modal">
    <div class="modal-content">
      <div class="modal-title">영상 시간 관리</div>
      <input type="text" id="new-cat-label" placeholder="표시 이름 (예: 90분, 120분)" style="margin-bottom: .5rem;">
      <button id="btn-add-category" class="primary" style="width: 100%; margin-bottom: 1rem;">추가</button>
      <div id="categories-list" style="max-height: 300px; overflow-y: auto;"></div>
      <div class="modal-buttons">
        <button id="btn-close-categories">닫기</button>
      </div>
    </div>
  </div>

  <!-- 처리 단계 관리 모달 -->
  <div id="modal-steps" class="modal">
    <div class="modal-content">
      <div class="modal-title">처리 단계 관리</div>
      <p style="font-size: .85rem; color: #666; margin-bottom: .5rem;">
        스타일: <strong id="modal-steps-style"></strong>
      </p>
      <input type="text" id="new-step-name" placeholder="단계 이름 (예: 캐릭터 설정, 스토리라인, 대사 작성)" style="margin-bottom: .5rem;">
      <button id="btn-add-step" class="primary" style="width: 100%; margin-bottom: 1rem;">추가</button>
      <div id="steps-list" style="max-height: 300px; overflow-y: auto;"></div>
      <div class="modal-buttons">
        <button id="btn-close-steps">닫기</button>
      </div>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

  <!-- Drama Lab 모듈화된 JavaScript 파일 -->
  <!-- 유틸리티 함수 -->
  <script src="/static/js/drama-utils.js"></script>
  <!-- 메인 로직 (Firebase, 전역변수, 세션관리) -->
  <script src="/static/js/drama-main.js"></script>
  <!-- Q&A 대화 기록 -->
  <script src="/static/js/drama-session.js"></script>
  <!-- Step1: 대본 생성 -->
  <script src="/static/js/drama-step1.js"></script>
  <!-- Step2: 이미지 생성 -->
  <script src="/static/js/drama-step2.js"></script>
  <!-- Step3: TTS 음성합성 -->
  <script src="/static/js/drama-step3.js"></script>
  <!-- Step4: 영상 제작 -->
  <script src="/static/js/drama-step4.js"></script>
  <!-- Step5: 유튜브 업로드 - 비활성화됨
  <script src="/static/js/drama-step5.js"></script>
  -->

  <script>
  // ===== 추가 초기화 및 호환성 코드 =====

  // 전역 변수 참조 (모듈에서 노출)
  let guideUnlocked = window.DramaMain?.guideUnlocked || false;
  let gptProUnlocked = window.DramaMain?.gptProUnlocked || false;
  let currentCategory = window.DramaMain?.currentCategory || '10min';
  let currentGuideStep = '';
  let stepResults = window.stepResults || {};

  // ===== Step 네비게이션 함수 =====
  function scrollToStep(containerId) {
    const container = document.getElementById(containerId);
    if (container) {
      container.scrollIntoView({ behavior: 'smooth', block: 'start' });

      // 네비게이션 버튼 활성화 상태 업데이트
      const stepNum = containerId.replace('-container', '');
      updateStepNavActive(stepNum);
    }
  }

  function updateStepNavActive(stepNum) {
    document.querySelectorAll('.step-nav-btn').forEach(btn => {
      btn.classList.remove('active');
      if (btn.dataset.step === stepNum) {
        btn.classList.add('active');
      }
    });
  }

  function updateStepNavCompleted(stepNum, completed = true) {
    const btn = document.querySelector(`.step-nav-btn[data-step="${stepNum}"]`);
    if (btn) {
      if (completed) {
        btn.classList.add('completed');
        btn.querySelector('.step-status').textContent = '✓';
      } else {
        btn.classList.remove('completed');
        btn.querySelector('.step-status').textContent = '○';
      }
    }
  }

  // 스크롤 위치에 따라 현재 Step 감지
  function detectCurrentStep() {
    const steps = ['step1', 'step2', 'step3', 'step4', 'step5', 'step6', 'step7'];
    const contentArea = document.querySelector('.content-area');
    if (!contentArea) return;

    const scrollTop = contentArea.scrollTop;
    let currentStep = 'step1';

    for (const step of steps) {
      const container = document.getElementById(`${step}-container`);
      if (container && container.offsetTop <= scrollTop + 100) {
        currentStep = step;
      }
    }

    updateStepNavActive(currentStep);
  }

  // content-area 스크롤 이벤트 리스너
  document.addEventListener('DOMContentLoaded', () => {
    const contentArea = document.querySelector('.content-area');
    if (contentArea) {
      contentArea.addEventListener('scroll', detectCurrentStep);
    }
  });

  // ===== 워크플로우 세션 관리 시스템 =====
  // 모든 Step이 공유하는 단일 세션 데이터
  let workflowSession = {
    sessionId: null,
    createdAt: null,
    updatedAt: null,
    category: '10min',
    contentType: 'testimony',

    // YouTube 메타데이터 (Step3에서 생성 → Step7에서 사용)
    metadata: {
      title: '',
      description: '',
      tags: [],
      thumbnail: { prompt: '', url: '' }
    },

    step1: { topic: '', mainCharacter: '', benchmark: {} },
    step2: { character: {}, storyline: {}, scene: {}, dialogue: {} },
    step3: { guide: '', script: '', scenes: [] },
    step4: { provider: 'flux', aspectRatio: '16:9', images: [] },
    step5: { provider: 'google', voices: {}, audioFiles: [] },
    step6: { videoUrl: '', duration: '', format: 'mp4' },
    step7: { status: 'draft', youtubeId: '', youtubeUrl: '', scheduledAt: '' }
  };

  // 세션 초기화
  function initWorkflowSession() {
    workflowSession.sessionId = 'session_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);
    workflowSession.createdAt = new Date().toISOString();
    workflowSession.updatedAt = new Date().toISOString();
    console.log('[SESSION] 새 세션 생성:', workflowSession.sessionId);
    return workflowSession;
  }

  // 세션 데이터 업데이트
  function updateSession(path, value) {
    const keys = path.split('.');
    let obj = workflowSession;
    for (let i = 0; i < keys.length - 1; i++) {
      if (!obj[keys[i]]) obj[keys[i]] = {};
      obj = obj[keys[i]];
    }
    obj[keys[keys.length - 1]] = value;
    workflowSession.updatedAt = new Date().toISOString();
    saveSessionToStorage();
    console.log(`[SESSION] 업데이트: ${path}`, value);
  }

  // 세션 데이터 조회
  function getSession(path, defaultValue = null) {
    const keys = path.split('.');
    let value = workflowSession;
    try {
      for (const key of keys) {
        value = value[key];
      }
      return value !== undefined ? value : defaultValue;
    } catch {
      return defaultValue;
    }
  }

  // 메타데이터 업데이트 (Step3 → Step7 연동용)
  function updateMetadata(data) {
    if (data.title) workflowSession.metadata.title = data.title;
    if (data.description) workflowSession.metadata.description = data.description;
    if (data.tags) workflowSession.metadata.tags = data.tags;
    if (data.thumbnail) workflowSession.metadata.thumbnail = data.thumbnail;
    workflowSession.updatedAt = new Date().toISOString();
    saveSessionToStorage();
    console.log('[SESSION] 메타데이터 업데이트:', workflowSession.metadata);

    // Step7 UI 자동 업데이트
    syncMetadataToStep7();
  }

  // Step7 UI에 메타데이터 동기화
  function syncMetadataToStep7() {
    const titleInput = document.getElementById('youtube-title');
    const descInput = document.getElementById('youtube-description');
    const tagsInput = document.getElementById('youtube-tags');

    if (titleInput && workflowSession.metadata.title) {
      titleInput.value = workflowSession.metadata.title;
    }
    if (descInput && workflowSession.metadata.description) {
      descInput.value = workflowSession.metadata.description;
    }
    if (tagsInput && workflowSession.metadata.tags?.length) {
      tagsInput.value = workflowSession.metadata.tags.join(', ');
    }
  }

  // 세션 저장 (localStorage)
  function saveSessionToStorage() {
    try {
      localStorage.setItem('_drama-workflow-session', JSON.stringify(workflowSession));
    } catch (e) {
      console.warn('[SESSION] 저장 실패:', e);
    }
  }

  // 세션 로드 (localStorage)
  function loadSessionFromStorage() {
    try {
      const saved = localStorage.getItem('_drama-workflow-session');
      if (saved) {
        const parsed = JSON.parse(saved);
        // 기존 구조 유지하면서 저장된 값으로 업데이트
        workflowSession = { ...workflowSession, ...parsed };
        console.log('[SESSION] 로드 완료:', workflowSession.sessionId);
        return true;
      }
    } catch (e) {
      console.warn('[SESSION] 로드 실패:', e);
    }
    return false;
  }

  // 세션 초기화 (새로 시작)
  function resetSession() {
    if (confirm('현재 작업 내용이 모두 초기화됩니다. 계속하시겠습니까?')) {
      localStorage.removeItem('_drama-workflow-session');
      initWorkflowSession();
      location.reload();
    }
  }

  // 세션 전체 조회 (디버깅/AI 컨텍스트용)
  function getFullSession() {
    return JSON.parse(JSON.stringify(workflowSession));
  }

  // 세션을 AI 컨텍스트로 변환 (프롬프트에 포함용)
  function getSessionContext() {
    return `【 현재 작업 세션 정보 】
- 카테고리: ${workflowSession.category}
- 콘텐츠 유형: ${workflowSession.contentType === 'testimony' ? '간증' : '드라마'}
- 주제: ${workflowSession.step1.topic || '(미설정)'}
- 주인공: ${workflowSession.step1.mainCharacter || '(미설정)'}
- 제목: ${workflowSession.metadata.title || '(미생성)'}
`;
  }

  // 대본에서 메타데이터 자동 생성
  async function generateMetadataFromScript(script, contentType) {
    if (!script) return;

    console.log('[METADATA] 메타데이터 생성 시작...');
    showStatus('🏷️ 메타데이터 생성 중...');

    try {
      const response = await fetch('/api/drama/generate-metadata', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ script, contentType })
      });

      const data = await response.json();

      if (data.ok && data.metadata) {
        // 세션에 메타데이터 저장
        updateMetadata({
          title: data.metadata.title,
          description: data.metadata.description,
          tags: data.metadata.tags
        });

        console.log('[METADATA] 생성 완료:', data.metadata);
        showStatus('✅ 메타데이터 자동 생성 완료!');

        // 사용자에게 알림
        showMetadataNotification(data.metadata);
      } else {
        console.warn('[METADATA] 생성 실패:', data.error);
      }
    } catch (err) {
      console.error('[METADATA] 오류:', err);
    }

    setTimeout(hideStatus, 3000);
  }

  // ⭐ Step1 결과에서 나레이션 텍스트 추출
  function extractNarrationFromResult(resultText) {
    try {
      // JSON으로 파싱 시도
      let data;
      const jsonMatch = resultText.match(/```json\s*([\s\S]*?)\s*```/);
      if (jsonMatch) {
        data = JSON.parse(jsonMatch[1]);
      } else {
        data = JSON.parse(resultText);
      }

      let narrationText = '';

      // 하이라이트 나레이션 추출
      if (data.highlight && data.highlight.scenes) {
        data.highlight.scenes.forEach(scene => {
          if (scene.preview_text) {
            narrationText += scene.preview_text + '\n\n';
          }
          if (scene.narration) {
            narrationText += scene.narration + '\n\n';
          }
        });
      }

      // 본문 씬별 나레이션 추출
      if (data.script && data.script.scenes) {
        data.script.scenes.forEach((scene, idx) => {
          if (scene.narration) {
            narrationText += scene.narration + '\n\n';
          }
        });
      }

      return narrationText.trim();
    } catch (e) {
      console.warn('[extractNarration] JSON 파싱 실패, 원본 텍스트 반환:', e);
      return resultText;
    }
  }

  // ⭐ Step1 대본 뷰어 표시
  function displayStep1ScriptViewer(resultText) {
    // Step3 결과 컨테이너에 결과 표시 (재사용)
    const resultContainer = document.getElementById('step3-result-container');
    const resultTextarea = document.getElementById('step3-result');
    const scriptViewer = document.getElementById('step3-script-viewer');
    const scriptContent = document.getElementById('step3-script-content');

    if (!resultContainer || !resultTextarea) return;

    // JSON 원본 표시
    resultTextarea.value = resultText;
    resultContainer.style.display = 'block';

    // 대본 뷰어에 보기 좋게 표시
    if (scriptViewer && scriptContent) {
      const formattedHtml = formatScriptToText(resultText);
      scriptContent.innerHTML = formattedHtml;
      // 기본적으로 대본 뷰어 표시
      scriptViewer.style.display = 'block';
      resultTextarea.style.display = 'none';
      isScriptViewerOpen = true;
      const btnToggle = document.getElementById('btn-toggle-script-view');
      if (btnToggle) btnToggle.textContent = '📋 JSON 보기';
    }

    // 컨테이너로 스크롤
    resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });

    console.log('[Step1] 대본 뷰어 표시 완료');
  }

  // 메타데이터 생성 알림 표시 및 Step5 필드 자동 채우기
  function showMetadataNotification(metadata) {
    // ⭐ Step5(유튜브 업로드) 필드에 자동으로 값 채우기
    const titleField = document.getElementById('step7-title');
    const descField = document.getElementById('step7-description');
    const tagsField = document.getElementById('step7-tags');

    if (titleField && metadata.title) {
      titleField.value = metadata.title;
    }
    if (descField && metadata.description) {
      descField.value = metadata.description;
    }
    if (tagsField && metadata.tags) {
      tagsField.value = metadata.tags;
    }

    console.log('[METADATA] Step5 필드 자동 채움 완료:', metadata);

    const notification = document.createElement('div');
    notification.className = 'metadata-notification';
    notification.innerHTML = `
      <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
                  border: 1px solid #4CAF50; border-radius: 12px; padding: 16px;
                  position: fixed; bottom: 20px; right: 20px; z-index: 10000;
                  max-width: 400px; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
        <div style="color: #4CAF50; font-weight: bold; margin-bottom: 8px;">
          🏷️ YouTube 메타데이터 자동 생성 완료
        </div>
        <div style="color: #aaa; font-size: 13px; margin-bottom: 4px;">
          <strong>제목:</strong> ${metadata.title}
        </div>
        <div style="color: #888; font-size: 12px;">
          ✅ Step5 업로드 필드에 자동 입력되었습니다
        </div>
        <button onclick="this.parentElement.parentElement.remove()"
                style="position: absolute; top: 8px; right: 8px; background: none;
                       border: none; color: #666; cursor: pointer; font-size: 16px;">×</button>
      </div>
    `;
    document.body.appendChild(notification);

    // 5초 후 자동 제거
    setTimeout(() => notification.remove(), 5000);
  }

  // 워크플로우 박스 시스템
  let workflowBoxes = [];
  let nextBoxId = 1;
  let nextStep1BoxNum = 1;
  let nextStep2BoxNum = 1;
  let step1Collapsed = false;
  let step2Collapsed = false;
  let customDurationText = localStorage.getItem('_drama-duration-text') || '';

  // 영상 카테고리 설정
  const videoCategories = ['간증', '드라마', '명언', '마음', '철학', '인간관계'];
  let selectedCategory = localStorage.getItem('_drama-video-category') || '간증';

  // 사용자 지침 (선택사항) - 예: "쇼팬하우어 명언"
  let customDirective = localStorage.getItem('_drama-custom-directive') || '';

  // 기본 설정
  let config = {
    categories: [
      {value: "10min", label: "10분"},
      {value: "20min", label: "20분"},
      {value: "30min", label: "30분"}
    ],
    // 통합된 처리 단계 (모든 시간대에 동일)
    unifiedSteps: [
      {id: "character", name: "캐릭터 설정", order: 1},
      {id: "storyline", name: "스토리라인", order: 2},
      {id: "scene", name: "장면 구성", order: 3},
      {id: "dialogue", name: "대사 작성", order: 4}
    ],
    categorySettings: {
      "10min": {
        masterGuide: ""
      },
      "20min": {
        masterGuide: ""
      },
      "30min": {
        masterGuide: ""
      }
    }
  };

  // ===== JSON 지침 로드 시스템 =====
  let dramaGuidelines = null;

  async function loadDramaGuidelines() {
    try {
      const response = await fetch('/api/drama/guidelines');
      const data = await response.json();
      if (data.ok && data.guidelines) {
        dramaGuidelines = data.guidelines;
        console.log('[GUIDELINES] 지침 로드 완료:', dramaGuidelines.version);
        // 지침 로드 후 contentTypePrompts 업데이트
        updateContentTypePromptsFromGuidelines();
        return true;
      }
    } catch (error) {
      console.warn('[GUIDELINES] 지침 로드 실패, 기본값 사용:', error);
    }
    return false;
  }

  function updateContentTypePromptsFromGuidelines() {
    if (!dramaGuidelines?.contentTypes) return;

    // 서버에서 로드한 지침으로 업데이트
    for (const [key, value] of Object.entries(dramaGuidelines.contentTypes)) {
      if (contentTypePrompts[key]) {
        contentTypePrompts[key].name = value.name || contentTypePrompts[key].name;
        contentTypePrompts[key].systemPrompt = value.systemPrompt || contentTypePrompts[key].systemPrompt;
        contentTypePrompts[key].userPromptSuffix = value.userPromptSuffix || contentTypePrompts[key].userPromptSuffix;
      }
    }
    console.log('[GUIDELINES] contentTypePrompts 업데이트 완료');

    // 카테고리 설정 업데이트 (masterGuide)
    if (dramaGuidelines?.categories) {
      for (const [key, value] of Object.entries(dramaGuidelines.categories)) {
        const configKey = key === '10min' ? '10min' : key === 'shorts' ? 'shorts' : key;
        if (config.categorySettings[configKey]) {
          config.categorySettings[configKey].masterGuide = value.masterGuide || '';
        }
      }
      console.log('[GUIDELINES] categorySettings 업데이트 완료');
    }
  }

  // 지침에서 특정 값 가져오기 (점 표기법 지원)
  function getGuideline(path, defaultValue = null) {
    if (!dramaGuidelines) return defaultValue;
    const keys = path.split('.');
    let value = dramaGuidelines;
    try {
      for (const key of keys) {
        value = value[key];
      }
      return value !== undefined ? value : defaultValue;
    } catch {
      return defaultValue;
    }
  }

  // ===== 콘텐츠 유형별 Step3 프롬프트 (초기값 - 서버 로드 시 업데이트됨) =====
  let contentTypePrompts = {
    testimony: {
      name: '간증',
      systemPrompt: `당신은 감동적인 간증 콘텐츠 전문 작가입니다.

【 간증 콘텐츠의 핵심 】
간증은 실제 경험을 바탕으로 한 이야기입니다. 시청자가 "이건 진짜 이야기구나"라고 느끼도록 생생하고 구체적으로 작성해야 합니다.

【 필수 요소 】
1. 실제감 있는 상황 묘사
   - 추상적 표현 금지 (X: "힘든 시간을 보냈다" → O: "새벽 3시, 텅 빈 사무실에서 해고 통보 메일을 읽었다")
   - 구체적인 시간, 장소, 감각 묘사 포함
   - 실제 대화처럼 자연스러운 대사

2. 감정의 깊이와 솔직함
   - 겉치레 없는 날것의 감정 표현
   - 고통, 절망, 분노, 의심 등 부정적 감정도 솔직하게
   - 눈물, 떨림, 심장 박동 등 신체 반응 묘사

3. 갈등과 전환점 구조
   - 시작: 평범한 일상 또는 위기의 시작
   - 고난: 점점 깊어지는 어둠, 막다른 골목
   - 전환점: 하나님의 개입, 깨달음의 순간 (구체적 사건으로)
   - 변화: 이전과 확실히 달라진 모습

4. 공감 포인트
   - "나도 저런 적 있어"라고 느끼게 하는 보편적 상황
   - 완벽한 사람이 아닌, 약하고 실수하는 인간의 모습

【 금지 사항 】
- 설교조의 일반적인 교훈 나열
- "하나님은 선하십니다" 같은 진부한 결론
- 너무 빠른 해결, 현실성 없는 기적
- 감정 없이 사건만 나열

【 출력 형식 】
- 마크다운 기호(#, *, -, **) 사용 금지
- 나레이션과 대사를 자연스럽게 섞어서 구성
- 지문은 괄호 () 안에 작성`,

      userPromptSuffix: `

⚠️ 중요: 이것은 간증 콘텐츠입니다.
- 시청자가 처음부터 끝까지 몰입할 수 있도록 긴장감 있게 전개하세요
- 고난의 깊이가 깊을수록, 은혜의 감동도 커집니다
- "이건 진짜 이야기구나"라고 느끼게 하는 구체적인 디테일을 넣으세요
- 결말이 너무 뻔하거나 교훈적이면 안 됩니다`
    },

    drama: {
      name: '드라마',
      systemPrompt: `당신은 전문 드라마 대본 작가입니다.

【 드라마 대본의 핵심 】
시청자를 화면 속으로 끌어들이는 몰입감 있는 스토리를 만들어야 합니다.

【 필수 요소 】
1. 캐릭터의 입체성
   - 주인공의 명확한 목표와 내면의 갈등
   - 각 인물만의 말투, 습관, 가치관
   - 캐릭터 간의 긴장감 있는 관계

2. 장면 구성
   - 각 장면의 목적이 분명해야 함
   - 시각적으로 그려지는 공간 묘사
   - 적절한 장면 전환과 템포

3. 대사의 힘
   - 캐릭터의 성격이 드러나는 대사
   - 서브텍스트 (말하지 않은 것의 힘)
   - 기억에 남는 명대사

4. 갈등과 긴장
   - 외적 갈등 (인물 vs 인물, 상황)
   - 내적 갈등 (인물 내면의 싸움)
   - 예상치 못한 반전과 전개

【 대본 형식 】
S#1. 장소 / 시간

(장면 설명 - 공간, 분위기, 인물 배치)

인물명: 대사
인물명: (감정/행동) 대사

【 금지 사항 】
- 마크다운 기호(#, *, -, **) 사용 금지
- 지루한 설명이나 독백
- 캐릭터 행동의 일관성 부재
- 결말로 향하는 긴장감 없이 늘어지는 전개`,

      userPromptSuffix: `

⚠️ 중요: 이것은 드라마 대본입니다.
- 시청자가 다음 장면이 궁금해지도록 긴장감을 유지하세요
- 각 캐릭터의 목소리가 구분되어야 합니다
- 장면 전환이 자연스럽고 목적이 있어야 합니다
- 촬영 가능한 수준의 구체적인 지문을 작성하세요`
    }
  };

  // 현재 선택된 콘텐츠 유형의 프롬프트 가져오기
  function getCurrentPrompt() {
    const contentType = document.getElementById('content-type')?.value || 'testimony';
    return contentTypePrompts[contentType] || contentTypePrompts.testimony;
  }

  // 프롬프트 미리보기 업데이트
  function updatePromptPreview() {
    const prompt = getCurrentPrompt();
    const previewEl = document.getElementById('prompt-preview-content');
    if (previewEl) {
      previewEl.textContent = `【 ${prompt.name} 모드 시스템 프롬프트 】\n\n${prompt.systemPrompt}\n\n【 추가 지시사항 】${prompt.userPromptSuffix}`;
    }
  }

  // 프롬프트 미리보기 토글
  document.getElementById('btn-toggle-prompt-preview')?.addEventListener('click', function() {
    const container = document.getElementById('prompt-preview-container');
    if (container) {
      const isHidden = container.style.display === 'none';
      container.style.display = isHidden ? 'block' : 'none';
      this.textContent = isHidden ? '📝 Step3 프롬프트 미리보기 ▲' : '📝 Step3 프롬프트 미리보기 ▼';
      if (isHidden) updatePromptPreview();
    }
  });

  // 콘텐츠 유형 변경 시 프롬프트 업데이트
  document.getElementById('content-type')?.addEventListener('change', updatePromptPreview);

  // ===== 한글 → 영문 ID 자동 생성 =====
  function koreanToId(korean) {
    const map = {
      '캐릭터': 'character',
      '스토리': 'storyline',
      '줄거리': 'plot',
      '대사': 'dialogue',
      '장면': 'scene',
      '구성': 'structure',
      '설정': 'setting',
      '분석': 'analysis',
      '개요': 'outline',
      '노래': 'song',
      '안무': 'choreography',
      '연출': 'direction'
    };

    for (const [key, value] of Object.entries(map)) {
      if (korean.includes(key)) {
        return value + '_' + Date.now().toString(36);
      }
    }

    return 'step_' + Date.now().toString(36);
  }

  // ===== 유틸리티 =====
  function showStatus(msg) {
    const statusBar = document.getElementById('status-bar');
    if (statusBar) {
      statusBar.textContent = msg;
      statusBar.style.display = 'block';
    }
  }

  function hideStatus() {
    const statusBar = document.getElementById('status-bar');
    if (statusBar) {
      statusBar.style.display = 'none';
    }
  }

  // 로딩 오버레이 표시
  function showLoadingOverlay(text = 'AI 작업 중', subtext = '잠시만 기다려주세요...') {
    const overlay = document.getElementById('loading-overlay');
    if (overlay) {
      const textEl = overlay.querySelector('.loading-text');
      const subtextEl = overlay.querySelector('.loading-subtext');
      if (textEl) textEl.textContent = text;
      if (subtextEl) subtextEl.textContent = subtext;
      overlay.classList.add('show');
    }
  }

  // 로딩 오버레이 숨김
  function hideLoadingOverlay() {
    const overlay = document.getElementById('loading-overlay');
    if (overlay) {
      overlay.classList.remove('show');
    }
  }

  function autoResize(el) {
    if (!el) return;
    el.style.height = 'auto';
    el.style.height = el.scrollHeight + 'px';
  }

  // ===== Firebase 함수 =====
  async function loadFromFirebase() {
    try {
      const snapshot = await db.collection('users').doc(USER_CODE).collection(PAGE_NAME).get();

      if (!snapshot.empty) {
        snapshot.forEach(doc => {
          localStorage.setItem(doc.id, doc.data().value);
        });

        const configData = localStorage.getItem(CONFIG_KEY);
        if (configData) {
          config = JSON.parse(configData);
        }
        console.log('✅ Firebase 동기화 완료');
        return true;
      }
      return false;
    } catch (err) {
      console.error('Firebase 로드 실패:', err);
      return false;
    }
  }

  async function saveToFirebase(key, value) {
    try {
      await db.collection('users').doc(USER_CODE).collection(PAGE_NAME).doc(key).set({
        value: value,
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      });
      return true;
    } catch (err) {
      console.error('Firebase 저장 실패:', err);
      return false;
    }
  }

  async function saveConfig() {
    const configStr = JSON.stringify(config);
    localStorage.setItem(CONFIG_KEY, configStr);
    await saveToFirebase(CONFIG_KEY, configStr);
  }

  // ===== 총괄 지침 관리 =====
  function loadMasterGuide(category) {
    const settings = config.categorySettings[category];
    const textarea = document.getElementById('master-guide-text');
    if (textarea) {
      if (settings && settings.masterGuide) {
        textarea.value = settings.masterGuide;
      } else {
        textarea.value = '';
      }
      autoResize(textarea);
    }
  }

  async function saveMasterGuide() {
    const textarea = document.getElementById('master-guide-text');
    if (!textarea) return;

    const value = textarea.value;
    const settings = config.categorySettings[currentCategory];

    if (settings) {
      settings.masterGuide = value;
      await saveConfig();

      showStatus('✅ 총괄 지침 저장 완료!');
      setTimeout(hideStatus, 2000);
    }
  }

  const saveMasterGuideBtn = document.getElementById('save-master-guide');
  if (saveMasterGuideBtn) {
    saveMasterGuideBtn.addEventListener('click', saveMasterGuide);
  }

  const toggleMasterGuideBtn = document.getElementById('toggle-master-guide');
  if (toggleMasterGuideBtn) {
    toggleMasterGuideBtn.addEventListener('click', () => {
      const content = document.getElementById('master-guide-content');
      const btn = document.getElementById('toggle-master-guide');

      if (content && btn) {
        if (content.style.display === 'none') {
          content.style.display = 'block';
          btn.textContent = '닫기';
          loadMasterGuide(currentCategory);
        } else {
          content.style.display = 'none';
          btn.textContent = '열기';
        }
      }
    });
  }

  // ===== 지침 관리 =====
  function getGuideKey(category, stepId) {
    return `guide-${category}-${stepId}`;
  }

  function loadGuide(category, stepId) {
    const key = getGuideKey(category, stepId);
    const stored = localStorage.getItem(key) || '';
    const textarea = document.getElementById('guide-text');
    if (textarea) {
      textarea.value = stored;
      autoResize(textarea);
    }

    let info = `유형: ${getCategoryLabel(category)} | 단계: ${getStepName(stepId)}`;
    const infoEl = document.getElementById('current-guide-info');
    if (infoEl) {
      infoEl.textContent = info;
    }
  }

  async function saveGuide() {
    const textarea = document.getElementById('guide-text');
    if (!textarea) return;

    const key = getGuideKey(currentCategory, currentGuideStep);
    const value = textarea.value;

    localStorage.setItem(key, value);

    showStatus('💾 저장 중...');
    const success = await saveToFirebase(key, value);

    if (success) {
      showStatus('✅ 지침 저장 완료!');
    } else {
      showStatus('⚠️ 로컬에만 저장됨');
    }

    setTimeout(hideStatus, 2000);
  }

  // ===== 헬퍼 함수 =====
  function getCategoryLabel(value) {
    const cat = config.categories.find(c => c.value === value);
    return cat ? cat.label : value;
  }

  function getCurrentSteps() {
    if (!config.unifiedSteps) return [];
    return config.unifiedSteps.sort((a, b) => a.order - b.order);
  }

  function getStepName(stepId) {
    const steps = getCurrentSteps();
    const step = steps.find(s => s.id === stepId);
    return step ? step.name : stepId;
  }

  // ===== GPT PRO 초안 구성 유틸 =====
  function assembleGptProDraft() {
    const steps = getCurrentSteps();
    const benchmarkScript = document.getElementById('benchmark-script').value.trim();
    const mainCharacter = document.getElementById('main-character').value.trim();

    if (steps.length === 0) {
      return { error: '처리된 단계가 없습니다.' };
    }

    const completedSteps = steps.filter(step => stepResults[step.id]);

    if (completedSteps.length === 0) {
      return { error: '완성된 단계가 없습니다. 먼저 각 단계를 실행해주세요.' };
    }

    const categoryLabel = getCategoryLabel(currentCategory);

    let fullText = `====================================\n`;
    fullText += `🎭 드라마 스크립트 초안 자료 (GPT-5.1 작성용)\n`;
    fullText += `====================================\n\n`;
    fullText += `⚠️ 중요: 이 자료는 gpt-4o-mini가 만든 '초안'입니다.\n`;
    fullText += `GPT-5.1은 이 자료를 참고하되, 처음부터 새로 작성해주세요.\n`;
    fullText += `mini가 만든 문장을 그대로 복사하지 말고, 자연스러운 드라마 스크립트로 재작성하세요.\n\n`;
    fullText += `${'='.repeat(50)}\n\n`;
    fullText += `📌 기본 정보\n`;
    fullText += `- 영상 시간: ${categoryLabel}\n`;
    if (mainCharacter) {
      fullText += `- 주인공: ${mainCharacter}\n`;
    }
    if (benchmarkScript) {
      fullText += `- 벤치마킹 대본: 첨부됨\n`;
    }
    fullText += `- 작성일: ${new Date().toLocaleDateString('ko-KR')}\n`;
    fullText += `\n${'='.repeat(50)}\n\n`;

    if (benchmarkScript) {
      fullText += `【 벤치마킹 대본 】\n\n`;
      fullText += benchmarkScript;
      fullText += `\n\n${'='.repeat(50)}\n\n`;
    }

    let sectionIndex = 1;
    completedSteps.forEach(step => {
      fullText += `【 ${sectionIndex}. ${step.name} 】\n\n`;
      fullText += stepResults[step.id];
      fullText += `\n\n${'='.repeat(50)}\n\n`;
      sectionIndex += 1;
    });

    fullText += `\n📝 작성 지침:\n`;
    fullText += `위의 초안 자료를 참고하여, 완성도 높은 드라마 스크립트를 처음부터 새로 작성해주세요.\n`;

    return {
      error: null,
      fullText,
      draftContent: fullText,
      meta: {
        benchmarkScript,
        mainCharacter,
        categoryLabel
      }
    };
  }

  // ===== 전체 복사 기능 =====
  const btnCopyAll = document.getElementById('btn-copy-all');
  if (btnCopyAll) {
    btnCopyAll.addEventListener('click', () => {
      const draft = assembleGptProDraft();
      if (draft.error) {
        alert(draft.error);
        return;
      }

      const tempTextarea = document.createElement('textarea');
      tempTextarea.value = draft.fullText;
      tempTextarea.style.position = 'fixed';
      tempTextarea.style.opacity = '0';
      document.body.appendChild(tempTextarea);
      tempTextarea.select();

      try {
        document.execCommand('copy');
        showStatus('✅ GPT-5.1에 붙여넣을 준비 완료!');
        setTimeout(hideStatus, 2000);
      } catch (err) {
        alert('복사 실패: ' + err.message);
      } finally {
        document.body.removeChild(tempTextarea);
      }
    });
  }

  // ===== GPT PRO 처리 기능 =====
  async function executeGptPro() {
    const draft = assembleGptProDraft();
    if (draft.error) {
      alert(draft.error);
      return;
    }

    // ===== 1단계: 전체 복사 =====
    const tempTextarea = document.createElement('textarea');
    tempTextarea.value = draft.fullText;
    tempTextarea.style.position = 'fixed';
    tempTextarea.style.opacity = '0';
    document.body.appendChild(tempTextarea);
    tempTextarea.select();

    try {
      document.execCommand('copy');
      showStatus('📋 전체 복사 완료! GPT PRO 처리 중...');
    } catch (err) {
      console.error('복사 실패:', err);
    } finally {
      document.body.removeChild(tempTextarea);
    }

    // ===== 2단계: GPT-5.1로 스크립트 작성 =====
    showStatus('🚀 GPT PRO 처리 중... (약 30초 소요)');

    try {
      const response = await fetch('/api/drama/gpt-pro', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          mainCharacter: draft.meta.mainCharacter,
          category: draft.meta.categoryLabel,
          draftContent: draft.draftContent
        })
      });

      const data = await response.json();

      if (data.ok) {
        const resultTextarea = document.getElementById('gpt-pro-result');
        const resultContainer = document.getElementById('gpt-pro-result-container');

        if (resultTextarea && resultContainer) {
          resultTextarea.value = data.result;
          autoResize(resultTextarea);
          resultContainer.style.display = 'block';

          // 결과 박스로 스크롤
          resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        showStatus('✅ 전체 복사 + GPT PRO 완성!');
      } else {
        alert(`오류: ${data.error}`);
        showStatus('❌ 실패');
      }
    } catch (err) {
      alert(`네트워크 오류: ${err.message}`);
      showStatus('❌ 오류');
    } finally {
      setTimeout(hideStatus, 3000);
    }
  }

  const btnGptPro = document.getElementById('btn-gpt-pro');
  if (btnGptPro) {
    btnGptPro.addEventListener('click', () => {
      if (!gptProUnlocked) {
        // 패스워드 모달 표시
        const modal = document.getElementById('modal-gpt-pro-password');
        if (modal) modal.classList.add('show');
        const input = document.getElementById('gpt-pro-password-input');
        if (input) {
          input.value = '';
          input.focus();
        }
      } else {
        // 이미 잠금 해제된 경우 바로 실행
        executeGptPro();
      }
    });
  }

  // GPT PRO 결과 복사
  const btnCopyGptPro = document.getElementById('btn-copy-gpt-pro');
  if (btnCopyGptPro) {
    btnCopyGptPro.addEventListener('click', () => {
      const textarea = document.getElementById('gpt-pro-result');
      if (textarea && textarea.value) {
        textarea.select();
        document.execCommand('copy');
        const orig = btnCopyGptPro.textContent;
        btnCopyGptPro.textContent = '✅ 복사됨!';
        setTimeout(() => btnCopyGptPro.textContent = orig, 1500);
      }
    });
  }

  // ===== 전체 진행 상황 관리 =====
  const completedSteps = new Set();

  function updateProgressIndicator(stepName) {
    completedSteps.add(stepName);

    // 사이드바 진행 상황 업데이트
    document.querySelectorAll('.progress-step-sidebar').forEach(stepEl => {
      const step = stepEl.dataset.step;
      const indicator = stepEl.querySelector('.step-indicator');
      const statusIcon = stepEl.querySelector('.step-status-icon');
      const substatus = stepEl.querySelector('.step-substatus');
      const container = stepEl.querySelector('div');

      if (completedSteps.has(step)) {
        // 완료 상태
        indicator.style.background = '#10b981';
        indicator.style.color = 'white';
        statusIcon.textContent = '✓';
        statusIcon.style.color = '#10b981';
        substatus.textContent = '완료';
        substatus.style.color = 'rgba(16, 185, 129, 0.9)';
        container.style.borderLeftColor = '#10b981';
        container.style.background = 'rgba(16, 185, 129, 0.2)';
      }
    });

    // 상태 텍스트 업데이트
    const statusEl = document.getElementById('progress-status');
    const stepMessages = {
      step1: 'Step2로 진행하세요',
      step2: 'Step1 대본 완성을 실행하세요',
      step3: 'Step2(이미지) + Step3(음성)을 진행하세요',
      step4: completedSteps.has('step5') ? 'Step4 영상 생성 가능!' : 'Step3 음성 생성을 진행하세요',
      step5: completedSteps.has('step4') ? 'Step4 영상 생성 가능!' : 'Step2 이미지 생성을 진행하세요',
      step6: 'Step5 YouTube 업로드 가능!',
      step7: '모든 단계 완료!'
    };
    if (statusEl) {
      const messageDiv = statusEl.querySelector('div') || statusEl;
      messageDiv.textContent = stepMessages[stepName] || '';
    }
  }

  // Step3 완료 후 Step4/Step5 자동 활성화
  function activateNextSteps(scriptContent) {
    // Step4 컨테이너 표시
    const step4Container = document.getElementById('step4-container');
    if (step4Container) {
      step4Container.style.display = 'block';
    }

    // Step5 TTS 텍스트 자동 채우기 (지문만 추출)
    if (scriptContent) {
      const ttsTextarea = document.getElementById('step5-script-text');
      if (ttsTextarea && !ttsTextarea.value.trim()) {
        // JSON에서 나레이션만 추출
        const narrationText = extractNarrationFromScript(scriptContent);
        if (narrationText) {
          ttsTextarea.value = narrationText;
        }
      }
    }

    // 🎤 성별에 따른 TTS 음성 자동 선택 (대본에서 주인공 성별 자동 감지)
    autoSelectVoiceByGender(scriptContent);

    // 안내 토스트 표시
    showNextStepGuide();
  }

  // 🎤 성별에 따른 TTS 음성 자동 선택 (대본 JSON에서 자동 감지 포함)
  function autoSelectVoiceByGender(scriptContent = null) {
    let targetVoice = null;
    let detectedGender = null;

    // 1. 대본 JSON에서 주인공 성별 자동 감지 시도
    if (scriptContent) {
      try {
        let jsonStr = scriptContent;
        const jsonMatch = scriptContent.match(/```json\s*([\s\S]*?)\s*```/);
        if (jsonMatch) {
          jsonStr = jsonMatch[1];
        }
        const data = JSON.parse(jsonStr);

        // characters 배열에서 주인공(role이 '주인공') 찾기
        const characters = data.characters || [];
        const protagonist = characters.find(c => c.role === '주인공' || c.role?.includes('주인공'));

        if (protagonist && protagonist.gender) {
          detectedGender = protagonist.gender;
          console.log('[TTS] 대본에서 주인공 성별 감지:', detectedGender);
        }
      } catch (e) {
        console.log('[TTS] 대본 파싱 실패, 라디오 버튼 확인');
      }
    }

    // 2. 대본에서 감지 못했으면 라디오 버튼 확인
    if (!detectedGender) {
      const maleRadio = document.getElementById('gender-male');
      const femaleRadio = document.getElementById('gender-female');

      if (femaleRadio && femaleRadio.checked) {
        detectedGender = '여성';
      } else if (maleRadio && maleRadio.checked) {
        detectedGender = '남성';
      }
    }

    // 3. 성별에 따라 목소리 선택
    if (detectedGender && (detectedGender.includes('여') || detectedGender.toLowerCase().includes('female'))) {
      targetVoice = 'ko-KR-Wavenet-B';
      console.log('[TTS] 여성 주인공 → 여성B 음성 자동 선택');
    } else if (detectedGender && (detectedGender.includes('남') || detectedGender.toLowerCase().includes('male'))) {
      targetVoice = 'ko-KR-Wavenet-C';
      console.log('[TTS] 남성 주인공 → 남성A 음성 자동 선택');
    }

    if (targetVoice) {
      // Google TTS 프로바이더로 설정
      step5TtsProvider = 'google';
      step5SelectedVoice = targetVoice;

      // UI 업데이트
      const googleContainer = document.getElementById('step5-voice-google');
      const naverContainer = document.getElementById('step5-voice-naver');
      if (googleContainer) googleContainer.style.display = 'grid';
      if (naverContainer) naverContainer.style.display = 'none';

      // 음성 옵션 선택 표시
      document.querySelectorAll('#step5-voice-google .step5-voice-option').forEach(opt => {
        opt.classList.remove('selected');
        if (opt.dataset.voice === targetVoice) {
          opt.classList.add('selected');
        }
      });

      // 라벨 업데이트
      const voiceLabel = document.getElementById('step5-voice-label');
      if (voiceLabel) {
        const genderText = targetVoice === 'ko-KR-Wavenet-B' ? '여성B' : '남성A';
        voiceLabel.innerHTML = `🎤 음성 선택 (Google Cloud) <span style="font-size: .75rem; font-weight: normal; color: rgba(255,255,255,0.7);">- ${genderText} 자동 선택됨 (${detectedGender} 주인공)</span>`;
      }

      showStatus(`🎤 ${detectedGender} 주인공 감지 → ${targetVoice === 'ko-KR-Wavenet-B' ? '여성B' : '남성A'} 음성 자동 선택`);
      setTimeout(hideStatus, 3000);
    }
  }

  // 대본에서 지문(나레이션) 추출 - JSON 파싱 지원 (개선 버전)
  function extractNarrationFromScript(script) {
    // 1. JSON 형태인지 확인하고 파싱 시도
    try {
      // ```json ... ``` 블록 추출
      let jsonStr = script;
      const jsonMatch = script.match(/```json\s*([\s\S]*?)\s*```/);
      if (jsonMatch) {
        jsonStr = jsonMatch[1];
      }

      // JSON 파싱
      const data = JSON.parse(jsonStr);
      const narrations = [];

      // 다양한 JSON 구조 지원
      // 1) data.script.scenes 구조 (가장 일반적)
      let scenes = null;
      if (data.script && data.script.scenes && Array.isArray(data.script.scenes)) {
        scenes = data.script.scenes;
      } else if (data.scenes && Array.isArray(data.scenes)) {
        scenes = data.scenes;
      }

      if (scenes && scenes.length > 0) {
        scenes.forEach((scene, idx) => {
          if (scene.narration) {
            narrations.push(scene.narration);
          }
          if (scene.scene_narration) {
            narrations.push(scene.scene_narration);
          }
        });

        if (narrations.length > 0) {
          console.log('[extractNarration] JSON에서 나레이션 추출 성공:', narrations.length + '개');
          return narrations.join('\n\n');
        }
      }

      // 2) highlight 씬의 나레이션도 추출 (선택적)
      if (data.highlight && data.highlight.scenes) {
        data.highlight.scenes.forEach(scene => {
          if (scene.preview_text || scene.narration) {
            // 하이라이트는 중복될 수 있으므로 별도로 처리하지 않음
          }
        });
      }

      console.log('[extractNarration] JSON 파싱 성공했으나 narration 필드 없음, 기존 방식으로 처리');
      console.log('[extractNarration] JSON 구조:', Object.keys(data));
    } catch (e) {
      console.log('[extractNarration] JSON 파싱 실패, 기존 텍스트 방식으로 처리:', e.message);
    }

    // 2. 기존 텍스트 기반 추출 방식 (fallback)
    const lines = script.split('\n');
    const narrations = [];

    for (const line of lines) {
      const trimmed = line.trim();
      // 괄호로 시작하는 지문 (예: (어두운 방 안...))
      if (trimmed.startsWith('(') && trimmed.endsWith(')')) {
        narrations.push(trimmed.slice(1, -1));
      }
      // 대괄호 지문 (예: [나레이션] 또는 [장면 설명])
      else if (trimmed.startsWith('[') && (trimmed.includes('나레이션') || trimmed.includes('장면'))) {
        const content = trimmed.replace(/\[.*?\]/g, '').trim();
        if (content) narrations.push(content);
      }
      // "지문:" 또는 "나레이션:" 으로 시작하는 줄
      else if (trimmed.startsWith('지문:') || trimmed.startsWith('나레이션:')) {
        narrations.push(trimmed.replace(/^(지문|나레이션):?\s*/, ''));
      }
    }

    // 3. 아무것도 추출되지 않았으면 경고
    if (narrations.length === 0) {
      console.warn('[extractNarration] 나레이션을 추출할 수 없습니다. JSON 구조를 확인해주세요.');
    }

    return narrations.join('\n\n');
  }

  // 다음 단계 안내 가이드 표시
  function showNextStepGuide() {
    // 안내 배너 생성
    const guideEl = document.createElement('div');
    guideEl.id = 'next-step-guide';
    guideEl.innerHTML = `
      <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); padding: 1rem; border-radius: 8px; margin: .75rem 0; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
        <div style="color: white; font-weight: 700; font-size: 1rem; margin-bottom: .5rem;">다음 단계로 진행하세요!</div>
        <div style="color: rgba(255,255,255,0.95); font-size: .85rem; line-height: 1.5;">
          <div style="margin-bottom: .3rem;"><strong>Step2:</strong> 대본에서 인물을 추출하고 이미지를 생성하세요</div>
          <div><strong>Step3:</strong> TTS 음성과 자막을 생성하세요 (텍스트가 자동 입력됨)</div>
          <div style="margin-top: .5rem; font-size: .75rem; opacity: 0.8;">Step4와 Step5는 동시에 진행할 수 있습니다</div>
        </div>
        <button onclick="this.parentElement.parentElement.remove()" style="position: absolute; top: .5rem; right: .5rem; background: rgba(255,255,255,0.3); border: none; color: white; padding: .25rem .5rem; border-radius: 4px; cursor: pointer; font-size: .75rem;">닫기</button>
      </div>
    `;
    guideEl.style.position = 'relative';

    // Step4 컨테이너 앞에 삽입
    const step4Container = document.getElementById('step4-container');
    if (step4Container && step4Container.parentNode) {
      step4Container.parentNode.insertBefore(guideEl, step4Container);

      // 5초 후 자동 제거
      setTimeout(() => {
        guideEl.remove();
      }, 8000);

      // Step4로 스크롤
      setTimeout(() => {
        step4Container.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }, 500);
    }
  }

  // ===== Step3 (OpenRouter) 대본 완성 기능 =====
  async function executeStep3() {
    // Step2 결과만 수집 (Step2에서 새로운 대본 제작한 결과)
    let draftContent = '';
    let hasResults = false;

    // 디버그: workflowBoxes 상태 확인
    console.log('[Step3 Debug] workflowBoxes 전체:', workflowBoxes);
    console.log('[Step3 Debug] Step2 박스 목록:', workflowBoxes.filter(b => b.stepType === 'step2'));
    workflowBoxes.forEach(box => {
      console.log(`[Step3 Debug] Box ${box.id}: stepType=${box.stepType}, hasResult=${!!box.result}, resultLength=${box.result?.length || 0}`);
    });

    workflowBoxes.forEach(box => {
      // Step2 박스만 수집
      if (box.stepType === 'step2' && box.result) {
        hasResults = true;
        draftContent += `\n\n${'='.repeat(50)}\n`;
        draftContent += `[Step2] ${box.name}\n`;
        draftContent += `${'='.repeat(50)}\n\n`;
        draftContent += box.result;
      }
    });

    console.log('[Step3 Debug] hasResults:', hasResults);
    console.log('[Step3 Debug] draftContent length:', draftContent.length);
    console.log('[Step3 Debug] draftContent preview:', draftContent.substring(0, 500));

    // 기본 정보 수집
    const categorySelect = document.getElementById('drama-category');
    const durationLabel = (customDurationText || '').trim() || (categorySelect ? categorySelect.options[categorySelect.selectedIndex].text : '');
    const videoCategory = selectedCategory || '간증';  // 영상 카테고리 (간증, 드라마, 명언 등)
    const mainCharacterInput = document.getElementById('main-character');
    const mainCharacter = mainCharacterInput ? mainCharacterInput.value : '';
    const benchmarkScript = document.getElementById('benchmark-script')?.value || '';
    const analysisResult = document.getElementById('analysis-result')?.textContent || '';

    // ⭐ 모달 textarea에서 최신 step3Guide 값을 가져옴 (저장 안해도 반영되도록)
    const step3GuideTextarea = document.getElementById('modal-guide-step3');
    const currentStep3Guide = step3GuideTextarea ? step3GuideTextarea.value : step3Guide;

    // 디버그: step3Guide 값 확인
    console.log('[Step3 Debug] textarea exists:', !!step3GuideTextarea);
    console.log('[Step3 Debug] textarea value:', step3GuideTextarea?.value);
    console.log('[Step3 Debug] global step3Guide:', step3Guide);
    console.log('[Step3 Debug] currentStep3Guide to send:', currentStep3Guide);

    // 콘텐츠 유형 가져오기 (간증/드라마)
    const contentType = document.getElementById('content-type')?.value || 'testimony';
    const promptData = contentTypePrompts[contentType] || contentTypePrompts.testimony;

    // ⭐ 모달 textarea에서 최신 JSON 지침 값을 가져옴 (저장 안해도 반영되도록)
    const jsonGuideTextarea = document.getElementById('modal-guide-json');
    const currentJsonGuide = jsonGuideTextarea ? jsonGuideTextarea.value : dramaJsonGuide;

    try {
      // ===== GPT-4o-mini 2단계 기획 먼저 실행 =====
      let gptPlanResult = '';

      // Step1: GPT-4o-mini 기획 (스토리 컨셉)
      showLoadingOverlay('GPT 기획 중 (1/3)', 'GPT-4o-mini가 스토리 컨셉을 기획하고 있습니다...');
      showStatus('🎯 Step 0-1: GPT-4o-mini 스토리 기획 중...');

      const planStep1Response = await fetch('/api/drama/gpt-plan-step1', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          videoCategory: videoCategory,
          duration: durationLabel,
          customDirective: customDirective
        })
      });

      const planStep1Data = await planStep1Response.json();
      if (!planStep1Data.ok) {
        throw new Error('GPT 기획 1단계 실패: ' + (planStep1Data.error || '알 수 없는 오류'));
      }

      console.log('[GPT-PLAN-1] 완료:', planStep1Data.result.substring(0, 200));

      // Step2: GPT-4o-mini 구조화 (장면 구성)
      showLoadingOverlay('GPT 구조화 중 (2/3)', 'GPT-4o-mini가 장면 구성을 만들고 있습니다...');
      showStatus('📐 Step 0-2: GPT-4o-mini 장면 구조화 중...');

      const planStep2Response = await fetch('/api/drama/gpt-plan-step2', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          videoCategory: videoCategory,
          duration: durationLabel,
          customDirective: customDirective,
          step1Result: planStep1Data.result
        })
      });

      const planStep2Data = await planStep2Response.json();
      if (!planStep2Data.ok) {
        throw new Error('GPT 기획 2단계 실패: ' + (planStep2Data.error || '알 수 없는 오류'));
      }

      console.log('[GPT-PLAN-2] 완료:', planStep2Data.result.substring(0, 200));

      // GPT 기획 결과 합치기
      gptPlanResult = `【 GPT-4o-mini 기획 결과 】\n\n`;
      gptPlanResult += `=== Step1: 스토리 컨셉 ===\n${planStep1Data.result}\n\n`;
      gptPlanResult += `=== Step2: 장면 구성 ===\n${planStep2Data.result}`;

      // Step2 결과가 없으면 GPT 기획 결과를 draftContent로 사용
      if (!hasResults) {
        draftContent = gptPlanResult;
        hasResults = true;
      } else {
        // Step2 결과가 있으면 GPT 기획을 앞에 추가
        draftContent = gptPlanResult + '\n\n' + draftContent;
      }

      // Step3: Claude 4.5로 최종 대본 작성
      showLoadingOverlay('Claude 대본 작성 중 (3/3)', 'Claude Sonnet 4.5가 대본을 작성하고 있습니다...');
      showStatus('🎬 Step 1: Claude Sonnet 4.5 대본 완성 중... (약 30-60초 소요)');

      const response = await fetch('/api/drama/claude-step3', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          category: durationLabel,
          videoCategory: videoCategory,  // 영상 카테고리 (간증, 드라마, 명언, 마음, 철학, 인간관계)
          customDirective: customDirective,  // 사용자 지침 (선택) - 최우선 반영
          draftContent: draftContent,
          mainCharacter: { name: mainCharacter },
          benchmarkScript: benchmarkScript,
          aiAnalysis: analysisResult,
          step3Guide: currentStep3Guide,  // ⭐ 최신 값 사용
          model: aiModelSettings.step3,  // 선택된 모델 전달
          contentType: contentType,  // 콘텐츠 유형 (testimony/drama)
          contentTypePrompt: promptData,  // 유형별 프롬프트 데이터
          durationText: customDurationText,
          autoStoryMode: !hasResults,
          customJsonGuide: currentJsonGuide  // ⭐ 커스텀 JSON 지침
        })
      });

      const data = await response.json();

      if (data.ok) {
        const resultTextarea = document.getElementById('step3-result');
        const resultContainer = document.getElementById('step3-result-container');
        const tokenInfo = document.getElementById('step3-token-info');

        if (resultTextarea && resultContainer) {
          resultTextarea.value = data.result;
          autoResize(resultTextarea);
          resultContainer.style.display = 'block';

          // ⭐ Step3 결과 저장 (페이지 새로고침 후에도 유지)
          step3Result = data.result;
          localStorage.setItem('_drama-step3-result', step3Result);
          saveToFirebase('_drama-step3-result', step3Result);

          // ⭐ 세션에 대본 저장
          updateSession('step3.script', step3Result);

          // ⭐ 메타데이터 자동 생성 (백그라운드에서 실행)
          generateMetadataFromScript(step3Result, contentType);

          // 토큰 정보 및 비용 표시
          if (data.usage && tokenInfo) {
            document.getElementById('step3-input-tokens').textContent = data.usage.input_tokens?.toLocaleString() || '0';
            document.getElementById('step3-output-tokens').textContent = data.usage.output_tokens?.toLocaleString() || '0';
            // 비용 계산
            const cost = calculateCost(aiModelSettings.step3, data.usage.input_tokens || 0, data.usage.output_tokens || 0);
            document.getElementById('step3-cost').textContent = cost ? '₩' + cost.totalCostKRW : '-';
            tokenInfo.style.display = 'block';
          }

          // 결과 박스로 스크롤
          resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });

          // Step4/Step5 자동 활성화 및 안내
          activateNextSteps(step3Result);
        }

        showStatus('✅ Step1: OpenRouter 대본 완성!');
        updateProgressIndicator('step3');

        // 🚀 전체 자동화 시작: 대본 → 이미지 → TTS → 영상
        hideLoadingOverlay();
        console.log('[AUTO] 대본 생성 완료, 전체 자동화 시작...');
        showStatus('🚀 자동화: 이미지 생성 시작...');

        // 2초 후 자동화 시작 (UI 업데이트 대기)
        setTimeout(async () => {
          isFullAutoMode = true;
          await generateAllAuto(true);  // confirm 건너뛰기
        }, 2000);

      } else {
        alert(`오류: ${data.error}`);
        showStatus('❌ Step3 실패');
      }
    } catch (err) {
      alert(`네트워크 오류: ${err.message}`);
      showStatus('❌ Step3 오류');
    } finally {
      hideLoadingOverlay();
    }
  }

  // Step3 실행 버튼 이벤트
  const btnExecuteStep3 = document.getElementById('btn-execute-step3');
  if (btnExecuteStep3) {
    btnExecuteStep3.addEventListener('click', executeStep3);
  }

  // Sonnet 4.5 버튼은 항상 해당 모델을 사용하도록 강제 설정
  if (btnExecuteStep3) {
    btnExecuteStep3.addEventListener('click', () => {
      if (aiModelSettings.step3 !== 'anthropic/claude-sonnet-4.5') {
        aiModelSettings.step3 = 'anthropic/claude-sonnet-4.5';
        localStorage.setItem('_drama-ai-models', JSON.stringify(aiModelSettings));
        saveToFirebase('_drama-ai-models', JSON.stringify(aiModelSettings));
      }
    }, { capture: true });
  }

  // Step3 결과 복사 버튼 이벤트
  const btnCopyStep3Result = document.getElementById('btn-copy-step3-result');
  if (btnCopyStep3Result) {
    btnCopyStep3Result.addEventListener('click', () => {
      const textarea = document.getElementById('step3-result');
      if (textarea && textarea.value) {
        textarea.select();
        document.execCommand('copy');
        const orig = btnCopyStep3Result.textContent;
        btnCopyStep3Result.textContent = '✅ 복사됨!';
        setTimeout(() => btnCopyStep3Result.textContent = orig, 1500);
        showStatus('✅ Step3 결과 복사 완료!');
        setTimeout(hideStatus, 2000);
      } else {
        alert('복사할 결과가 없습니다.');
      }
    });
  }

  // Step3 결과 지우기 버튼 이벤트
  const btnClearStep3Result = document.getElementById('btn-clear-step3-result');
  if (btnClearStep3Result) {
    btnClearStep3Result.addEventListener('click', () => {
      if (confirm('Step3 결과를 지우시겠습니까?')) {
        const resultTextarea = document.getElementById('step3-result');
        const resultContainer = document.getElementById('step3-result-container');
        const tokenInfo = document.getElementById('step3-token-info');

        if (resultTextarea) resultTextarea.value = '';
        if (resultContainer) resultContainer.style.display = 'none';
        if (tokenInfo) tokenInfo.style.display = 'none';

        // ⭐ 저장된 Step3 결과도 삭제
        step3Result = '';
        localStorage.removeItem('_drama-step3-result');
        saveToFirebase('_drama-step3-result', '');

        showStatus('🗑️ Step3 결과가 지워졌습니다.');
        setTimeout(hideStatus, 2000);
      }
    });
  }

  // ===== 대본 보기 토글 기능 =====
  let isScriptViewerOpen = false;

  // JSON 대본을 읽기 쉬운 텍스트로 변환하는 함수
  function formatScriptToText(jsonStr) {
    try {
      const data = JSON.parse(jsonStr);
      let html = '';

      // 메타데이터
      if (data.metadata) {
        html += `<div style="background: #f0f9ff; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; border-left: 4px solid #3b82f6;">`;
        html += `<h2 style="margin: 0 0 .5rem 0; color: #1e40af;">📺 ${data.metadata.title || '제목 없음'}</h2>`;
        if (data.metadata.duration_minutes) html += `<div style="color: #64748b;">⏱️ 분량: ${data.metadata.duration_minutes}분</div>`;
        if (data.metadata.total_scenes) html += `<div style="color: #64748b;">🎬 총 씬: ${data.metadata.total_scenes}개</div>`;
        if (data.metadata.total_characters) html += `<div style="color: #64748b;">👥 등장인물: ${data.metadata.total_characters}명</div>`;
        html += `</div>`;
      }

      // 등장인물
      if (data.characters && data.characters.length > 0) {
        html += `<div style="background: #fef3c7; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; border-left: 4px solid #f59e0b;">`;
        html += `<h3 style="margin: 0 0 .75rem 0; color: #b45309;">👥 등장인물</h3>`;
        data.characters.forEach(char => {
          html += `<div style="margin-bottom: .75rem; padding: .5rem; background: rgba(255,255,255,0.7); border-radius: 6px;">`;
          html += `<strong style="color: #92400e;">${char.name || char.id}</strong>`;
          // 성별, 나이, 역할 표시
          const charInfo = [];
          if (char.gender) charInfo.push(char.gender);
          if (char.age) charInfo.push(char.age);
          if (char.role) charInfo.push(char.role);
          if (charInfo.length > 0) html += ` <span style="color: #78716c; font-size: .85rem;">(${charInfo.join(', ')})</span>`;
          // 직업 표시
          if (char.occupation) html += `<div style="font-size: .85rem; color: #78716c; margin-top: .25rem;">직업: ${char.occupation}</div>`;
          if (char.appearance) {
            const app = char.appearance;
            const details = [app.height, app.body_type, app.face, app.hair, app.skin].filter(Boolean).join(', ');
            if (details) html += `<div style="font-size: .85rem; color: #78716c; margin-top: .25rem;">외모: ${details}</div>`;
          }
          if (char.voice_characteristics) html += `<div style="font-size: .85rem; color: #78716c;">음성: ${char.voice_characteristics}</div>`;
          html += `</div>`;
        });
        html += `</div>`;
      }

      // 하이라이트
      if (data.highlight && data.highlight.scenes) {
        html += `<div style="background: #fce7f3; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; border-left: 4px solid #ec4899;">`;
        html += `<h3 style="margin: 0 0 .75rem 0; color: #be185d;">✨ 하이라이트 (${data.highlight.type === 'climax_preview' ? '클라이맥스 미리보기' : '호기심 유발'})</h3>`;
        data.highlight.scenes.forEach((scene, idx) => {
          html += `<div style="margin-bottom: .5rem; padding: .5rem; background: rgba(255,255,255,0.7); border-radius: 6px;">`;
          html += `<div style="font-weight: 600; color: #9d174d;">[하이라이트 ${idx + 1}]</div>`;
          if (scene.preview_text || scene.narration) html += `<div style="margin-top: .25rem; color: #333;">"${scene.preview_text || scene.narration}"</div>`;
          html += `</div>`;
        });
        html += `</div>`;
      }

      // 대본 (씬별)
      if (data.script && data.script.scenes) {
        html += `<div style="background: #ecfdf5; padding: 1rem; border-radius: 8px; border-left: 4px solid #10b981;">`;
        html += `<h3 style="margin: 0 0 1rem 0; color: #047857;">📜 대본</h3>`;

        data.script.scenes.forEach((scene, idx) => {
          const meta = scene.scene_meta || {};
          html += `<div style="margin-bottom: 1.5rem; padding: 1rem; background: rgba(255,255,255,0.8); border-radius: 8px; border: 1px solid #d1fae5;">`;

          // 씬 헤더
          html += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .75rem; padding-bottom: .5rem; border-bottom: 2px solid #10b981;">`;
          html += `<h4 style="margin: 0; color: #065f46;">🎬 씬 ${idx + 1}</h4>`;
          if (meta.location) html += `<span style="font-size: .85rem; color: #64748b;">📍 ${meta.location.place || meta.location}</span>`;
          html += `</div>`;

          // 씬 메타 정보
          if (meta.time || meta.atmosphere) {
            html += `<div style="display: flex; gap: 1rem; margin-bottom: .75rem; font-size: .85rem; color: #64748b;">`;
            if (meta.time) html += `<span>🕐 ${meta.time.period || meta.time}</span>`;
            if (meta.atmosphere) html += `<span>🎭 ${meta.atmosphere.mood || meta.atmosphere}</span>`;
            html += `</div>`;
          }

          // 등장인물 상태
          if (meta.character_states) {
            html += `<div style="background: #fefce8; padding: .5rem; border-radius: 6px; margin-bottom: .75rem; font-size: .85rem;">`;
            html += `<strong style="color: #ca8a04;">👥 등장인물:</strong> `;
            const charNames = Object.keys(meta.character_states);
            html += charNames.map(name => {
              const state = meta.character_states[name];
              return `${name}${state.emotion ? ' (' + state.emotion + ')' : ''}`;
            }).join(', ');
            html += `</div>`;
          }

          // 나레이션
          if (scene.narration) {
            html += `<div style="padding: .75rem; background: linear-gradient(135deg, #f0fdfa, #ecfdf5); border-radius: 8px; font-size: 1rem; line-height: 1.8; color: #1f2937; border-left: 3px solid #14b8a6;">`;
            html += scene.narration;
            html += `</div>`;
          }

          html += `</div>`;
        });
        html += `</div>`;
      }

      return html || '<div style="color: #999; text-align: center; padding: 2rem;">대본 구조를 분석할 수 없습니다. JSON 형식을 확인해주세요.</div>';
    } catch (e) {
      console.error('대본 파싱 오류:', e);
      return `<div style="color: #ef4444; text-align: center; padding: 2rem;">⚠️ JSON 파싱 오류: ${e.message}<br><br>원본 JSON을 확인해주세요.</div>`;
    }
  }

  // 대본 보기 토글 버튼 이벤트
  const btnToggleScriptView = document.getElementById('btn-toggle-script-view');
  if (btnToggleScriptView) {
    btnToggleScriptView.addEventListener('click', () => {
      const jsonTextarea = document.getElementById('step3-result');
      const scriptViewer = document.getElementById('step3-script-viewer');
      const scriptContent = document.getElementById('step3-script-content');

      if (!jsonTextarea || !scriptViewer || !scriptContent) return;

      isScriptViewerOpen = !isScriptViewerOpen;

      if (isScriptViewerOpen) {
        // 대본 텍스트 뷰 표시
        const jsonStr = jsonTextarea.value;
        if (jsonStr.trim()) {
          scriptContent.innerHTML = formatScriptToText(jsonStr);
          jsonTextarea.style.display = 'none';
          scriptViewer.style.display = 'block';
          btnToggleScriptView.textContent = '📄 JSON 보기';
          btnToggleScriptView.style.background = 'linear-gradient(135deg, #10b981, #059669)';
        } else {
          alert('표시할 대본이 없습니다.');
          isScriptViewerOpen = false;
        }
      } else {
        // JSON 원본 뷰 표시
        jsonTextarea.style.display = 'block';
        scriptViewer.style.display = 'none';
        btnToggleScriptView.textContent = '📖 대본 보기';
        btnToggleScriptView.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
      }
    });
  }

  // ===== Step4: 이미지 생성 기능 (업그레이드 버전) =====
  let step4GeneratedImages = JSON.parse(localStorage.getItem('_drama-step4-images') || '[]');
  let step4Characters = JSON.parse(localStorage.getItem('_drama-step4-characters') || '[]');
  let step4CharacterImages = JSON.parse(localStorage.getItem('_drama-step4-character-images') || '{}');
  let step4Scenes = JSON.parse(localStorage.getItem('_drama-step4-scenes') || '[]');
  let step4ImageProvider = 'gemini';  // 기본: Gemini (OpenRouter)
  let isFullAutoMode = false;  // 🚀 대본→영상 전체 자동화 모드 플래그

  // 이미지 모델 선택 이벤트
  document.querySelectorAll('.step4-image-provider').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.step4-image-provider').forEach(b => {
        b.classList.remove('selected');
        b.style.border = '2px solid #ddd';
        b.style.background = 'white';
      });
      btn.classList.add('selected');
      btn.style.border = '2px solid #10b981';
      btn.style.background = 'rgba(16,185,129,0.2)';

      step4ImageProvider = btn.dataset.provider;

      // 버튼 텍스트 업데이트
      const btnGenerateImage = document.getElementById('btn-generate-image');
      if (btnGenerateImage) {
        const modelName = step4ImageProvider === 'gemini' ? 'Gemini' : (step4ImageProvider === 'flux' ? 'FLUX.1 Pro' : 'DALL-E 3');
        btnGenerateImage.textContent = `🖼️ 씬 이미지 생성 (${modelName})`;
      }
    });
  });

  // Step3 결과가 있으면 Step4 컨테이너 표시
  function updateStep4Visibility() {
    const step4Container = document.getElementById('step4-container');
    const step3Result = document.getElementById('step3-result')?.value || '';
    if (step4Container) {
      step4Container.style.display = step3Result.trim() ? 'block' : 'none';
    }
  }

  // Step3 결과 변경 감지
  const step3ResultTextarea = document.getElementById('step3-result');
  if (step3ResultTextarea) {
    const observer = new MutationObserver(updateStep4Visibility);
    observer.observe(step3ResultTextarea, { attributes: true, childList: true, subtree: true });
    setInterval(updateStep4Visibility, 1000);
  }

  // 1단계: 등장인물 분석
  async function analyzeCharacters() {
    const step3Result = document.getElementById('step3-result')?.value || '';
    if (!step3Result.trim()) {
      alert('먼저 Step1 대본 완성을 실행해주세요.');
      return;
    }

    const btn = document.getElementById('btn-analyze-characters');
    if (btn) {
      btn.disabled = true;
      btn.textContent = '⏳ 분석 중...';
    }

    showStatus('🔍 대본에서 등장인물 분석 중...');
    showLoadingOverlay();

    try {
      const response = await fetch('/api/drama/analyze-characters', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ script: step3Result })
      });

      const data = await response.json();

      if (data.ok) {
        step4Characters = data.characters || [];
        step4Scenes = data.scenes || [];
        localStorage.setItem('_drama-step4-characters', JSON.stringify(step4Characters));
        localStorage.setItem('_drama-step4-scenes', JSON.stringify(step4Scenes));

        renderCharactersList();
        updateCharacterSelect();
        updateSceneSelect();
        updateSceneCharacterCheckboxes();

        showStatus(`✅ ${step4Characters.length}명의 등장인물, ${step4Scenes.length}개의 씬 분석 완료!`);
      } else {
        alert(`오류: ${data.error}`);
        showStatus('❌ 분석 실패');
      }
    } catch (err) {
      alert(`네트워크 오류: ${err.message}`);
      showStatus('❌ 분석 오류');
    } finally {
      hideLoadingOverlay();
      setTimeout(hideStatus, 3000);
      if (btn) {
        btn.disabled = false;
        btn.textContent = '🔍 대본에서 인물 추출';
      }
    }
  }

  // 등장인물 목록 렌더링
  function renderCharactersList() {
    const container = document.getElementById('step4-characters-list');
    if (!container) return;

    if (step4Characters.length === 0) {
      container.innerHTML = '<div style="color: #999; text-align: center; font-size: .85rem;">대본을 분석하면 등장인물이 여기에 표시됩니다</div>';
      return;
    }

    container.innerHTML = step4Characters.map((char, idx) => `
      <div style="background: #f8f9fa; padding: .5rem; border-radius: 6px; margin-bottom: .5rem; border-left: 4px solid #27ae60;">
        <div style="font-weight: 600; color: #333; margin-bottom: .25rem;">
          👤 ${char.name}
          ${step4CharacterImages[char.name] ? '<span style="color: #27ae60; font-size: .8rem;">✅ 이미지 생성됨</span>' : ''}
        </div>
        <div style="font-size: .85rem; color: #666;">${char.description}</div>
        <div style="font-size: .8rem; color: #888; margin-top: .25rem;">
          <strong>프롬프트:</strong> ${char.imagePrompt || '(생성 전)'}
        </div>
      </div>
    `).join('');
  }

  // 인물 선택 드롭다운 업데이트
  function updateCharacterSelect() {
    const select = document.getElementById('step4-character-select');
    if (!select) return;

    select.innerHTML = '<option value="">-- 인물 선택 --</option>' +
      step4Characters.map((char, idx) => `<option value="${idx}">${char.name}</option>`).join('');
  }

  // 인물 선택 시 프롬프트 표시
  document.getElementById('step4-character-select')?.addEventListener('change', function() {
    const idx = parseInt(this.value);
    const promptArea = document.getElementById('step4-character-prompt');
    if (!isNaN(idx) && step4Characters[idx] && promptArea) {
      promptArea.value = step4Characters[idx].imagePrompt || '';
    }
  });

  // 2단계: 인물 이미지 생성
  async function generateCharacterImage() {
    const selectEl = document.getElementById('step4-character-select');
    const idx = parseInt(selectEl?.value);

    if (isNaN(idx) || !step4Characters[idx]) {
      alert('인물을 선택해주세요.');
      return;
    }

    const characterPrompt = document.getElementById('step4-character-prompt')?.value || step4Characters[idx].imagePrompt;
    if (!characterPrompt?.trim()) {
      alert('인물 프롬프트가 없습니다.');
      return;
    }

    const btn = document.getElementById('btn-generate-character-image');
    if (btn) {
      btn.disabled = true;
      btn.textContent = '⏳ 생성 중...';
    }

    showStatus(`🖼️ ${step4Characters[idx].name} 이미지 생성 중...`);
    showLoadingOverlay();

    try {
      const response = await fetch('/api/drama/generate-image', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt: characterPrompt + ', portrait style, high quality, detailed face, professional lighting',
          size: '1024x1024',
          imageProvider: step4ImageProvider
        })
      });

      const data = await response.json();

      if (data.ok) {
        // 인물 이미지 저장 (메모리에만 - base64는 localStorage에 저장하지 않음)
        step4CharacterImages[step4Characters[idx].name] = {
          url: data.imageUrl,
          prompt: characterPrompt,
          createdAt: new Date().toISOString()
        };

        // base64가 아닌 외부 URL만 localStorage에 저장
        if (!data.imageUrl.startsWith('data:')) {
          try {
            localStorage.setItem('_drama-step4-character-images', JSON.stringify(step4CharacterImages));
            // Firebase에도 백업
            saveToFirebase('_drama-step4-character-images', JSON.stringify(step4CharacterImages));
          } catch (e) {
            console.warn('localStorage 저장 실패 (용량 초과):', e.message);
          }
        }

        // 인물 이미지 표시
        renderCharacterImages();
        renderCharactersList();

        showStatus(`✅ ${step4Characters[idx].name} 이미지 생성 완료!`);
      } else {
        alert(`오류: ${data.error}`);
        showStatus('❌ 이미지 생성 실패');
      }
    } catch (err) {
      alert(`네트워크 오류: ${err.message}`);
      showStatus('❌ 이미지 생성 오류');
    } finally {
      hideLoadingOverlay();
      setTimeout(hideStatus, 3000);
      if (btn) {
        btn.disabled = false;
        btn.textContent = '🖼️ 인물 이미지 생성';
      }
    }
  }

  // 인물 이미지 렌더링
  function renderCharacterImages() {
    const container = document.getElementById('step4-character-images');
    if (!container) return;

    const images = Object.entries(step4CharacterImages);
    if (images.length === 0) {
      container.innerHTML = '';
      return;
    }

    container.innerHTML = images.map(([name, data]) => `
      <div style="background: #f8f9fa; padding: .5rem; border-radius: 6px; text-align: center;">
        <img src="${data.url}" alt="${name}" style="width: 100%; max-width: 150px; border-radius: 6px; cursor: pointer;" onclick="window.open('${data.url}', '_blank')">
        <div style="font-size: .8rem; font-weight: 600; margin-top: .25rem;">${name}</div>
        <button onclick="downloadImage('${data.url}')" style="margin-top: .25rem; padding: .2rem .4rem; font-size: .7rem; cursor: pointer;">💾 저장</button>
      </div>
    `).join('');
  }

  // 씬 선택 드롭다운 업데이트
  function updateSceneSelect() {
    const select = document.getElementById('step4-scene-select');
    if (!select) return;

    select.innerHTML = '<option value="">-- 씬 선택 --</option>' +
      step4Scenes.map((scene, idx) => `<option value="${idx}">씬 ${idx + 1}: ${scene.title || scene.location || '장면'}</option>`).join('');
  }

  // 씬에 등장하는 인물 체크박스 업데이트
  function updateSceneCharacterCheckboxes() {
    const container = document.getElementById('step4-scene-characters');
    if (!container) return;

    if (step4Characters.length === 0) {
      container.innerHTML = '<span style="color: rgba(255,255,255,0.6); font-size: .85rem;">인물 분석 후 선택 가능</span>';
      return;
    }

    container.innerHTML = step4Characters.map((char, idx) => `
      <label style="display: flex; align-items: center; gap: .25rem; background: rgba(255,255,255,0.9); padding: .3rem .5rem; border-radius: 4px; cursor: pointer; font-size: .85rem;">
        <input type="checkbox" class="scene-character-checkbox" data-name="${char.name}" checked>
        ${char.name}
      </label>
    `).join('');
  }

  // 씬 선택 시 프롬프트 생성
  document.getElementById('step4-scene-select')?.addEventListener('change', function() {
    const idx = parseInt(this.value);
    if (!isNaN(idx) && step4Scenes[idx]) {
      document.getElementById('step4-background-prompt').value = step4Scenes[idx].backgroundPrompt || '';
    }
  });

  // 3단계: 씬 프롬프트 생성
  async function generateScenePrompt() {
    const sceneSelect = document.getElementById('step4-scene-select');
    const idx = parseInt(sceneSelect?.value);

    if (isNaN(idx) || !step4Scenes[idx]) {
      alert('씬을 선택해주세요.');
      return;
    }

    // 선택된 인물들 가져오기
    const selectedCharacters = [];
    document.querySelectorAll('.scene-character-checkbox:checked').forEach(cb => {
      const name = cb.dataset.name;
      if (step4CharacterImages[name]) {
        selectedCharacters.push({
          name: name,
          prompt: step4CharacterImages[name].prompt
        });
      } else {
        const char = step4Characters.find(c => c.name === name);
        if (char) {
          selectedCharacters.push({
            name: name,
            prompt: char.imagePrompt
          });
        }
      }
    });

    const btn = document.getElementById('btn-generate-scene-prompt');
    if (btn) {
      btn.disabled = true;
      btn.textContent = '⏳ 생성 중...';
    }

    showStatus('📝 씬 프롬프트 생성 중...');
    showLoadingOverlay();

    try {
      const response = await fetch('/api/drama/generate-scene-prompt', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          scene: step4Scenes[idx],
          characters: selectedCharacters,
          backgroundPrompt: document.getElementById('step4-background-prompt')?.value || ''
        })
      });

      const data = await response.json();

      if (data.ok) {
        document.getElementById('step4-combined-prompt').value = data.combinedPrompt || '';
        if (data.backgroundPrompt) {
          document.getElementById('step4-background-prompt').value = data.backgroundPrompt;
        }
        showStatus('✅ 씬 프롬프트 생성 완료!');
      } else {
        alert(`오류: ${data.error}`);
        showStatus('❌ 프롬프트 생성 실패');
      }
    } catch (err) {
      alert(`네트워크 오류: ${err.message}`);
      showStatus('❌ 프롬프트 생성 오류');
    } finally {
      hideLoadingOverlay();
      setTimeout(hideStatus, 3000);
      if (btn) {
        btn.disabled = false;
        btn.textContent = '📝 씬 프롬프트';
      }
    }
  }

  // 프롬프트 + 이미지 한번에 생성
  async function generateScenePromptAndImage() {
    const sceneSelect = document.getElementById('step4-scene-select');
    const idx = parseInt(sceneSelect?.value);

    if (isNaN(idx) || !step4Scenes[idx]) {
      alert('씬을 선택해주세요.');
      return;
    }

    // 선택된 인물들 가져오기
    const selectedCharacters = [];
    document.querySelectorAll('.scene-character-checkbox:checked').forEach(cb => {
      const name = cb.dataset.name;
      if (step4CharacterImages[name]) {
        selectedCharacters.push({
          name: name,
          prompt: step4CharacterImages[name].prompt
        });
      } else {
        const char = step4Characters.find(c => c.name === name);
        if (char) {
          selectedCharacters.push({
            name: name,
            prompt: char.imagePrompt
          });
        }
      }
    });

    const btn = document.getElementById('btn-generate-scene-all');
    if (btn) {
      btn.disabled = true;
      btn.textContent = '⏳ 프롬프트 생성 중...';
    }

    showStatus('📝 Step4: 씬 프롬프트 생성 중...');
    showLoadingOverlay();

    try {
      // 1단계: 프롬프트 생성
      const promptResponse = await fetch('/api/drama/generate-scene-prompt', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          scene: step4Scenes[idx],
          characters: selectedCharacters,
          backgroundPrompt: document.getElementById('step4-background-prompt')?.value || ''
        })
      });

      const promptData = await promptResponse.json();

      if (!promptData.ok) {
        throw new Error(promptData.error || '프롬프트 생성 실패');
      }

      document.getElementById('step4-combined-prompt').value = promptData.combinedPrompt || '';
      if (promptData.backgroundPrompt) {
        document.getElementById('step4-background-prompt').value = promptData.backgroundPrompt;
      }

      showStatus('✅ 프롬프트 완료! 🖼️ 이미지 생성 중... (약 30초)');
      if (btn) btn.textContent = '⏳ 이미지 생성 중...';

      // 2단계: 이미지 생성
      const imageSize = document.getElementById('step4-image-size')?.value || '1792x1024';
      const imageResponse = await fetch('/api/drama/generate-image', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt: promptData.combinedPrompt,
          size: imageSize,
          imageProvider: step4ImageProvider
        })
      });

      const imageData = await imageResponse.json();

      if (imageData.ok) {
        const placeholder = document.getElementById('step4-image-placeholder');
        const imageGrid = document.getElementById('step4-image-grid');
        const costInfo = document.getElementById('step4-cost-info');

        if (placeholder) placeholder.style.display = 'none';
        if (imageGrid) {
          imageGrid.style.display = 'grid';

          const imageItem = document.createElement('div');
          imageItem.className = 'step4-image-item';
          imageItem.innerHTML = `
            <img src="${imageData.imageUrl}" alt="Generated scene" loading="lazy" onclick="window.open('${imageData.imageUrl}', '_blank')">
            <div class="image-caption">
              씬 ${idx + 1}: ${step4Scenes[idx].sceneName || ''} | ${imageSize}
              <button onclick="downloadImage('${imageData.imageUrl}')" style="margin-left: .5rem; padding: .2rem .4rem; font-size: .7rem; cursor: pointer;">💾 저장</button>
            </div>
          `;
          imageGrid.insertBefore(imageItem, imageGrid.firstChild);

          step4GeneratedImages.unshift({
            url: imageData.imageUrl,
            prompt: promptData.combinedPrompt,
            sceneIndex: idx,
            sceneName: step4Scenes[idx].sceneName,
            size: imageSize,
            createdAt: new Date().toISOString()
          });

          // base64가 아닌 외부 URL만 localStorage에 저장
          if (!imageData.imageUrl.startsWith('data:')) {
            try {
              localStorage.setItem('_drama-step4-images', JSON.stringify(step4GeneratedImages.slice(0, 20)));
            } catch (e) {
              console.warn('localStorage 저장 실패 (용량 초과):', e.message);
            }
          }
        }

        if (costInfo && imageData.cost) {
          document.getElementById('step4-image-cost').textContent = '₩' + imageData.cost.toLocaleString();
          costInfo.style.display = 'block';
        }

        showStatus('✅ 씬 이미지 생성 완료!');
        updateProgressIndicator('step4');
        updateStep6Visibility();

        // 🎬 썸네일 자동 생성 (프롬프트+이미지 완료 후)
        setTimeout(() => {
          if (typeof generateYouTubeThumbnail === 'function') {
            console.log('[THUMBNAIL] 이미지 생성 완료, 썸네일 자동 생성 시작...');
            generateYouTubeThumbnail();
          }
        }, 500);
      } else {
        throw new Error(imageData.error || '이미지 생성 실패');
      }
    } catch (err) {
      alert(`오류: ${err.message}`);
      showStatus('❌ 생성 실패');
    } finally {
      hideLoadingOverlay();
      setTimeout(hideStatus, 3000);
      if (btn) {
        btn.disabled = false;
        btn.textContent = '🎬 프롬프트+이미지';
      }
    }
  }

  // 이미지 생성 함수 (씬 이미지)
  async function generateStep4Image() {
    const combinedPrompt = document.getElementById('step4-combined-prompt')?.value || '';
    if (!combinedPrompt.trim()) {
      alert('먼저 씬 프롬프트를 생성하거나 직접 입력해주세요.');
      return;
    }

    const imageSize = document.getElementById('step4-image-size')?.value || '1792x1024';
    const btnGenerateImage = document.getElementById('btn-generate-image');

    if (btnGenerateImage) {
      btnGenerateImage.disabled = true;
      btnGenerateImage.classList.add('generating');
      btnGenerateImage.textContent = '⏳ 이미지 생성 중... (약 30초)';
    }

    const modelName = step4ImageProvider === 'gemini' ? 'Gemini' : (step4ImageProvider === 'flux' ? 'FLUX.1 Pro' : 'DALL-E 3');
    showStatus(`🖼️ Step2: ${modelName} 씬 이미지 생성 중...`);
    showLoadingOverlay();

    try {
      console.log(`[DEBUG] 이미지 생성 요청 - Provider: ${step4ImageProvider}, Size: ${imageSize}`);

      const response = await fetch('/api/drama/generate-image', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt: combinedPrompt,
          size: imageSize,
          imageProvider: step4ImageProvider
        })
      });

      console.log(`[DEBUG] 응답 상태: ${response.status} ${response.statusText}`);

      // 응답이 OK가 아니면 텍스트로 읽어서 확인
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[DEBUG] 서버 오류 응답: ${errorText}`);
        throw new Error(`서버 오류 (${response.status}): ${errorText.substring(0, 100)}`);
      }

      const data = await response.json();
      console.log(`[DEBUG] 응답 데이터:`, data);

      if (data.ok) {
        const placeholder = document.getElementById('step4-image-placeholder');
        const imageGrid = document.getElementById('step4-image-grid');
        const costInfo = document.getElementById('step4-cost-info');

        if (placeholder) placeholder.style.display = 'none';
        if (imageGrid) {
          imageGrid.style.display = 'grid';

          const imageItem = document.createElement('div');
          imageItem.className = 'step4-image-item';
          imageItem.innerHTML = `
            <img src="${data.imageUrl}" alt="Generated scene" loading="lazy" onclick="window.open('${data.imageUrl}', '_blank')">
            <div class="image-caption">
              ${new Date().toLocaleString('ko-KR')} | ${imageSize}
              <button onclick="downloadImage('${data.imageUrl}')" style="margin-left: .5rem; padding: .2rem .4rem; font-size: .7rem; cursor: pointer;">💾 저장</button>
            </div>
          `;
          imageGrid.insertBefore(imageItem, imageGrid.firstChild);

          step4GeneratedImages.unshift({
            url: data.imageUrl,
            prompt: combinedPrompt,
            size: imageSize,
            createdAt: new Date().toISOString()
          });

          // base64가 아닌 외부 URL만 localStorage에 저장
          if (!data.imageUrl.startsWith('data:')) {
            try {
              localStorage.setItem('_drama-step4-images', JSON.stringify(step4GeneratedImages.slice(0, 20)));
            } catch (e) {
              console.warn('localStorage 저장 실패 (용량 초과):', e.message);
            }
          }
        }

        if (costInfo && data.cost) {
          document.getElementById('step4-image-cost').textContent = '₩' + data.cost.toLocaleString();
          costInfo.style.display = 'block';
        }

        showStatus('✅ 씬 이미지 생성 완료!');
        updateProgressIndicator('step4');
        updateStep6Visibility();

        // 🎬 썸네일 자동 생성 (씬 이미지 생성 완료 후)
        setTimeout(() => {
          if (typeof generateYouTubeThumbnail === 'function') {
            console.log('[THUMBNAIL] 씬 이미지 생성 완료, 썸네일 자동 생성 시작...');
            generateYouTubeThumbnail();
          }
        }, 500);
      } else {
        alert(`오류: ${data.error}`);
        showStatus('❌ 이미지 생성 실패');
      }
    } catch (err) {
      console.error(`[DEBUG] 이미지 생성 오류:`, err);
      console.error(`[DEBUG] 현재 Provider: ${step4ImageProvider}`);
      alert(`오류 (${step4ImageProvider}): ${err.message}`);
      showStatus('❌ 이미지 생성 오류');
    } finally {
      hideLoadingOverlay();
      setTimeout(hideStatus, 3000);
      if (btnGenerateImage) {
        btnGenerateImage.disabled = false;
        btnGenerateImage.classList.remove('generating');
        const currentModel = step4ImageProvider === 'gemini' ? 'Gemini' : (step4ImageProvider === 'flux' ? 'FLUX.1 Pro' : 'DALL-E 3');
        btnGenerateImage.textContent = `🖼️ 씬 이미지 생성 (${currentModel})`;
      }
    }
  }

  // 이미지 다운로드 함수
  function downloadImage(url) {
    const a = document.createElement('a');
    a.href = url;
    a.download = `drama-scene-${Date.now()}.png`;
    a.target = '_blank';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }

  // Step4 초기화 함수
  function clearStep4() {
    if (!confirm('Step2의 모든 데이터(인물, 씬, 이미지)를 초기화하시겠습니까?')) return;

    step4Characters = [];
    step4CharacterImages = {};
    step4Scenes = [];
    step4GeneratedImages = [];

    localStorage.removeItem('_drama-step4-characters');
    localStorage.removeItem('_drama-step4-character-images');
    localStorage.removeItem('_drama-step4-scenes');
    localStorage.removeItem('_drama-step4-images');

    document.getElementById('step4-character-prompt').value = '';
    document.getElementById('step4-background-prompt').value = '';
    document.getElementById('step4-combined-prompt').value = '';

    renderCharactersList();
    updateCharacterSelect();
    updateSceneSelect();
    updateSceneCharacterCheckboxes();
    renderCharacterImages();

    const imageGrid = document.getElementById('step4-image-grid');
    const placeholder = document.getElementById('step4-image-placeholder');
    const costInfo = document.getElementById('step4-cost-info');

    if (imageGrid) {
      imageGrid.innerHTML = '';
      imageGrid.style.display = 'none';
    }
    if (placeholder) placeholder.style.display = 'block';
    if (costInfo) costInfo.style.display = 'none';

    showStatus('🗑️ Step4가 초기화되었습니다.');
    setTimeout(hideStatus, 2000);
  }

  // Step4 버튼 이벤트 바인딩
  document.getElementById('btn-analyze-characters')?.addEventListener('click', analyzeCharacters);
  document.getElementById('btn-generate-character-image')?.addEventListener('click', generateCharacterImage);
  document.getElementById('btn-generate-scene-prompt')?.addEventListener('click', generateScenePrompt);
  document.getElementById('btn-generate-scene-all')?.addEventListener('click', generateScenePromptAndImage);
  document.getElementById('btn-generate-image')?.addEventListener('click', generateStep4Image);
  document.getElementById('btn-clear-step4')?.addEventListener('click', clearStep4);

  // ===== 전체 자동 생성 기능 =====
  let isAutoGenerating = false;

  async function generateAllAuto(skipConfirm = false) {
    if (isAutoGenerating) {
      alert('이미 자동 생성이 진행 중입니다.');
      return;
    }

    const step3Result = document.getElementById('step3-result')?.value || '';
    if (!step3Result.trim()) {
      alert('먼저 Step1 대본 완성을 실행해주세요.');
      return;
    }

    // 자동화 모드에서는 confirm 건너뛰기
    if (!skipConfirm && !isFullAutoMode) {
      if (!confirm('전체 자동 생성을 시작하시겠습니까?\n\n1. 대본에서 인물/씬 분석\n2. 모든 인물 이미지 생성\n3. 모든 씬 배경 이미지 생성 (대본 기반 인물 자동 배치)\n\n⚠️ 많은 API 호출이 발생합니다.')) {
        return;
      }
    }

    isAutoGenerating = true;
    const progressContainer = document.getElementById('auto-generate-progress');
    const progressBar = document.getElementById('auto-generate-progress-bar');
    const statusText = document.getElementById('auto-generate-status');
    const detailsText = document.getElementById('auto-generate-details');
    const btnGenerateAll = document.getElementById('btn-generate-all-auto');

    if (progressContainer) progressContainer.style.display = 'block';
    if (btnGenerateAll) {
      btnGenerateAll.disabled = true;
      btnGenerateAll.textContent = '⏳ 생성 중...';
    }

    const updateProgress = (percent, status, details = '') => {
      if (progressBar) progressBar.style.width = `${percent}%`;
      if (statusText) statusText.textContent = status;
      if (detailsText) detailsText.textContent = details;
    };

    try {
      // 1단계: 대본 분석
      updateProgress(5, '📊 대본 분석 중...', '등장인물과 씬 정보를 추출합니다');
      showStatus('🔍 대본에서 등장인물 및 씬 분석 중...');

      const analyzeResponse = await fetch('/api/drama/analyze-characters', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ script: step3Result })
      });

      const analyzeData = await analyzeResponse.json();
      if (!analyzeData.ok) throw new Error(analyzeData.error || '대본 분석 실패');

      step4Characters = analyzeData.characters || [];
      step4Scenes = analyzeData.scenes || [];
      localStorage.setItem('_drama-step4-characters', JSON.stringify(step4Characters));
      localStorage.setItem('_drama-step4-scenes', JSON.stringify(step4Scenes));

      renderCharactersList();
      updateCharacterSelect();
      updateSceneSelect();
      updateSceneCharacterCheckboxes();

      updateProgress(15, `✅ 분석 완료: ${step4Characters.length}명의 인물, ${step4Scenes.length}개의 씬`, '인물 이미지 생성을 시작합니다');

      // 2단계: 인물 이미지 생성
      const totalCharacters = step4Characters.length;
      const totalScenes = step4Scenes.length;
      const totalSteps = totalCharacters + totalScenes;
      let completedSteps = 0;

      for (let i = 0; i < step4Characters.length; i++) {
        const char = step4Characters[i];
        completedSteps++;
        const percent = 15 + (completedSteps / totalSteps) * 80;
        updateProgress(percent, `👤 인물 이미지 생성 중: ${char.name} (${i + 1}/${totalCharacters})`, char.imagePrompt?.substring(0, 50) + '...');
        showStatus(`👤 ${char.name} 이미지 생성 중... (${i + 1}/${totalCharacters})`);

        try {
          const imageResponse = await fetch('/api/drama/generate-image', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt: char.imagePrompt || `Portrait of ${char.name}, ${char.description}, Korean drama style, professional photography, soft lighting`,
              size: '1024x1024',
              imageProvider: step4ImageProvider
            })
          });

          const imageData = await imageResponse.json();
          if (imageData.ok) {
            step4CharacterImages[char.name] = {
              url: imageData.imageUrl,
              prompt: char.imagePrompt,
              createdAt: new Date().toISOString()
            };
            localStorage.setItem('_drama-step4-character-images', JSON.stringify(step4CharacterImages));
            renderCharacterImages();
          }
        } catch (imgErr) {
          console.error(`인물 이미지 생성 실패 (${char.name}):`, imgErr);
        }

        // API 과부하 방지
        await new Promise(resolve => setTimeout(resolve, 1500));
      }

      // 3단계: 씬 배경 이미지 생성 (대본 기반 인물 자동 배치)
      for (let i = 0; i < step4Scenes.length; i++) {
        const scene = step4Scenes[i];
        completedSteps++;
        const percent = 15 + (completedSteps / totalSteps) * 80;

        // 대본에서 해당 씬에 등장하는 인물 자동 추출
        const sceneCharacterNames = scene.characters || [];
        const sceneCharacters = step4Characters.filter(c => sceneCharacterNames.includes(c.name));

        updateProgress(percent, `🎬 씬 이미지 생성 중: ${scene.title || '씬 ' + (i + 1)} (${i + 1}/${totalScenes})`, `등장인물: ${sceneCharacterNames.join(', ') || '없음'}`);
        showStatus(`🎬 씬 ${i + 1} 이미지 생성 중... (${i + 1}/${totalScenes}) - 등장인물: ${sceneCharacterNames.join(', ')}`);

        try {
          // 씬 프롬프트 생성 (인물 포함)
          const promptResponse = await fetch('/api/drama/generate-scene-prompt', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              scene: scene,
              characters: sceneCharacters.map(c => ({
                name: c.name,
                prompt: c.imagePrompt || c.description
              })),
              backgroundPrompt: scene.backgroundPrompt || ''
            })
          });

          const promptData = await promptResponse.json();
          if (!promptData.ok) throw new Error(promptData.error || '프롬프트 생성 실패');

          // 씬 이미지 생성
          const imageResponse = await fetch('/api/drama/generate-image', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt: promptData.combinedPrompt,
              size: '1792x1024',
              imageProvider: step4ImageProvider
            })
          });

          const imageData = await imageResponse.json();
          if (imageData.ok) {
            const placeholder = document.getElementById('step4-image-placeholder');
            const imageGrid = document.getElementById('step4-image-grid');

            if (placeholder) placeholder.style.display = 'none';
            if (imageGrid) {
              imageGrid.style.display = 'grid';

              const imageItem = document.createElement('div');
              imageItem.className = 'step4-image-item';
              imageItem.innerHTML = `
                <img src="${imageData.imageUrl}" alt="Scene ${i + 1}" loading="lazy" onclick="window.open('${imageData.imageUrl}', '_blank')">
                <div class="image-caption">
                  씬 ${i + 1}: ${scene.title || scene.location || ''} | 등장: ${sceneCharacterNames.join(', ') || '-'}
                  <button onclick="downloadImage('${imageData.imageUrl}')" style="margin-left: .5rem; padding: .2rem .4rem; font-size: .7rem; cursor: pointer;">💾 저장</button>
                </div>
              `;
              imageGrid.appendChild(imageItem);

              step4GeneratedImages.push({
                url: imageData.imageUrl,
                prompt: promptData.combinedPrompt,
                sceneIndex: i,
                sceneName: scene.title,
                characters: sceneCharacterNames,
                size: '1792x1024',
                createdAt: new Date().toISOString()
              });

              // 첫 번째 씬 이미지를 썸네일로 표시
              if (i === 0) {
                updateThumbnailPreview(imageData.imageUrl);
              }

              if (!imageData.imageUrl.startsWith('data:')) {
                try {
                  localStorage.setItem('_drama-step4-images', JSON.stringify(step4GeneratedImages.slice(-20)));
                } catch (e) {
                  console.warn('localStorage 저장 실패:', e.message);
                }
              }
            }
          }
        } catch (sceneErr) {
          console.error(`씬 이미지 생성 실패 (씬 ${i + 1}):`, sceneErr);
        }

        // API 과부하 방지
        await new Promise(resolve => setTimeout(resolve, 2000));
      }

      updateProgress(100, '✅ 전체 자동 생성 완료!', `인물 ${totalCharacters}명, 씬 ${totalScenes}개의 이미지가 생성되었습니다`);
      showStatus('🎉 전체 자동 생성 완료!');
      updateProgressIndicator('step4');
      updateStep6Visibility();

      // 3초 후 진행 상황 숨기기
      setTimeout(() => {
        if (progressContainer) progressContainer.style.display = 'none';
      }, 5000);

      // 🎬 썸네일 자동 생성 (전체 자동 생성 완료 후)
      if (typeof generateYouTubeThumbnail === 'function') {
        console.log('[AUTO] 이미지 생성 완료, 썸네일 자동 생성 시작...');
        showStatus('🎨 썸네일 자동 생성 중...');
        await generateYouTubeThumbnail();
      }

      // 🚀 전체 자동화 모드: TTS 및 영상 자동 생성
      if (isFullAutoMode) {
        console.log('[AUTO] 이미지 생성 완료, TTS 자동 시작...');
        showStatus('🎙️ 자동화: TTS 음성 생성 시작...');
        await runAutoTTSAndVideo();
      }

    } catch (err) {
      console.error('전체 자동 생성 오류:', err);
      updateProgress(0, `❌ 오류 발생: ${err.message}`, '다시 시도해주세요');
      showStatus(`❌ 자동 생성 오류: ${err.message}`);
    } finally {
      isAutoGenerating = false;
      if (btnGenerateAll) {
        btnGenerateAll.disabled = false;
        btnGenerateAll.textContent = '🚀 전체 생성';
      }
    }
  }

  // 🚀 전체 자동화: TTS + 영상 생성
  async function runAutoTTSAndVideo() {
    try {
      // 1. 지문 추출 (자동)
      console.log('[AUTO] 지문 추출 중...');
      extractNarration();
      await new Promise(resolve => setTimeout(resolve, 500));

      const scriptText = document.getElementById('step5-script-text')?.value || '';
      if (!scriptText.trim()) {
        console.error('[AUTO] 지문 추출 실패: 텍스트 없음');
        showStatus('❌ 자동화 오류: 지문 추출 실패');
        return;
      }

      // 2. TTS 생성
      console.log('[AUTO] TTS 생성 시작...');
      showLoadingOverlay('TTS 음성 생성 중', '자동화 모드: 음성을 생성하고 있습니다...');

      const speed = document.getElementById('step5-speed')?.value || 0;
      const pitch = document.getElementById('step5-pitch')?.value || 0;
      const volume = document.getElementById('step5-volume')?.value || 0;

      const ttsResponse = await fetch('/api/drama/generate-tts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          text: scriptText,
          speaker: step5SelectedVoice,
          speed: parseInt(speed),
          pitch: parseInt(pitch),
          volume: parseInt(volume),
          ttsProvider: step5TtsProvider
        })
      });

      const ttsData = await ttsResponse.json();
      hideLoadingOverlay();

      if (!ttsData.ok) {
        throw new Error(ttsData.error || 'TTS 생성 실패');
      }

      // TTS 결과 표시
      const audioSection = document.getElementById('step5-audio-section');
      const audioPlayer = document.getElementById('step5-audio-player');
      if (audioPlayer && ttsData.audioUrl) {
        step5AudioUrl = ttsData.audioUrl;
        audioPlayer.src = ttsData.audioUrl;
        audioSection.style.display = 'block';
      }

      console.log('[AUTO] TTS 완료, SRT 자막 생성...');
      showStatus('✅ TTS 완료! SRT 자막 생성 중...');

      // 3. SRT 자막 자동 생성
      await generateSubtitleAuto();
      updateProgressIndicator('step5');

      // 4. 영상 생성을 위한 이미지 자동 선택
      console.log('[AUTO] 영상 생성용 이미지 자동 선택...');
      await autoSelectImagesForVideo();

      // 5. 영상 생성
      if (step6SelectedImages.length > 0 && step5AudioUrl) {
        console.log('[AUTO] 영상 생성 시작...');
        showStatus('🎬 자동화: 영상 생성 시작...');
        await generateVideoAuto();
      } else {
        console.error('[AUTO] 영상 생성 불가: 이미지 또는 오디오 없음');
        showStatus('⚠️ 자동화 완료 (영상 생성은 수동으로 진행해주세요)');
      }

    } catch (err) {
      console.error('[AUTO] 자동화 오류:', err);
      showStatus(`❌ 자동화 오류: ${err.message}`);
      hideLoadingOverlay();
    } finally {
      isFullAutoMode = false;
    }
  }

  // 🚀 영상 생성용 이미지 자동 선택
  async function autoSelectImagesForVideo() {
    step6SelectedImages = [];

    // 생성된 씬 이미지들을 순서대로 선택
    if (step4GeneratedImages.length > 0) {
      step4GeneratedImages.forEach(img => {
        if (img.url) {
          step6SelectedImages.push(img.url);
        }
      });
      console.log(`[AUTO] ${step6SelectedImages.length}개 씬 이미지 선택됨`);
    }

    // 씬 이미지가 없으면 인물 이미지 사용
    if (step6SelectedImages.length === 0 && Object.keys(step4CharacterImages).length > 0) {
      Object.values(step4CharacterImages).forEach(img => {
        if (img.url) {
          step6SelectedImages.push(img.url);
        }
      });
      console.log(`[AUTO] ${step6SelectedImages.length}개 인물 이미지 선택됨`);
    }

    updateStep6ImageGrid();
  }

  // 🚀 자동 영상 생성 (확인 없이)
  async function generateVideoAuto() {
    if (step6SelectedImages.length === 0) {
      console.error('[AUTO] 영상 생성 실패: 이미지 없음');
      return;
    }

    if (!step5AudioUrl) {
      console.error('[AUTO] 영상 생성 실패: 오디오 없음');
      return;
    }

    // 브라우저 알림 권한 요청 (자동화 시작 시)
    if (Notification.permission === 'default') {
      await Notification.requestPermission();
    }

    const resolution = document.getElementById('step6-resolution')?.value || '1920x1080';
    const fps = document.getElementById('step6-fps')?.value || '30';
    const transition = document.getElementById('step6-transition')?.value || 'fade';
    const includeSubtitle = document.getElementById('step6-include-subtitle')?.checked || false;
    const burnSubtitle = document.getElementById('step6-burn-subtitle')?.checked || false;

    const progressDiv = document.getElementById('step6-progress');
    const progressBar = document.getElementById('step6-progress-bar');
    const progressText = document.getElementById('step6-progress-text');

    progressDiv.style.display = 'block';
    progressBar.style.width = '5%';
    progressText.textContent = '[자동화] 이미지 업로드 준비 중...';

    showStatus('🎬 자동화: 영상 생성 시작...');

    try {
      // 1. 이미지 업로드
      const uploadedImageUrls = [];
      const totalImages = step6SelectedImages.length;

      for (let i = 0; i < totalImages; i++) {
        progressBar.style.width = (5 + (i / totalImages) * 20) + '%';
        progressText.textContent = `[자동화] 이미지 업로드 중... (${i + 1}/${totalImages})`;

        try {
          const uploadedUrl = await uploadImageToServer(step6SelectedImages[i]);
          uploadedImageUrls.push(uploadedUrl);
        } catch (uploadErr) {
          console.error(`[AUTO] 이미지 ${i + 1} 업로드 실패:`, uploadErr);
          throw new Error(`이미지 ${i + 1} 업로드 실패: ${uploadErr.message}`);
        }
      }

      console.log(`[AUTO] ${uploadedImageUrls.length}개 이미지 업로드 완료`);

      progressBar.style.width = '25%';
      progressText.textContent = '[자동화] 영상 생성 작업 시작 중...';

      // 2. 영상 생성 작업 시작 (즉시 job_id 반환)
      const response = await fetch('/api/drama/generate-video', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          images: uploadedImageUrls,
          audioUrl: step5AudioUrl,
          subtitleData: includeSubtitle ? step5SubtitleData : null,
          burnSubtitle: burnSubtitle,
          resolution: resolution,
          fps: parseInt(fps),
          transition: transition
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`서버 오류 (${response.status}): ${errorText || '응답 없음'}`);
      }

      const data = await response.json();

      if (!data.ok || !data.jobId) {
        throw new Error(data.error || '작업 시작 실패');
      }

      const jobId = data.jobId;
      console.log(`[AUTO] 영상 생성 작업 시작됨: ${jobId}`);

      progressBar.style.width = '30%';
      progressText.textContent = '[자동화] 백그라운드에서 영상 생성 중...';
      showStatus('🎬 자동화: 영상 생성 중... (백그라운드)');

      // 3. Polling으로 상태 체크
      const startTime = Date.now();
      const maxWaitTime = 600000; // 10분
      let lastProgress = 30;

      while (Date.now() - startTime < maxWaitTime) {
        await new Promise(resolve => setTimeout(resolve, 2000)); // 2초마다 체크

        try {
          const statusResponse = await fetch(`/api/drama/video-status/${jobId}`);

          if (!statusResponse.ok) {
            console.error('[AUTO] 상태 조회 실패:', statusResponse.status);
            continue;
          }

          const statusData = await statusResponse.json();

          if (!statusData.ok) {
            throw new Error(statusData.error || '상태 조회 실패');
          }

          // 진행률 업데이트
          const serverProgress = statusData.progress || 0;
          const displayProgress = Math.max(lastProgress, 30 + serverProgress * 0.7);
          lastProgress = displayProgress;
          progressBar.style.width = displayProgress + '%';
          progressText.textContent = `[자동화] ${statusData.message || '영상 생성 중...'}`;

          console.log(`[AUTO] 상태: ${statusData.status}, 진행률: ${serverProgress}%`);

          // 완료 확인
          if (statusData.status === 'completed' && statusData.result) {
            progressBar.style.width = '100%';
            progressText.textContent = '🎉 자동화 완료!';

            const result = statusData.result;

            const videoSection = document.getElementById('step6-video-section');
            const videoPlayer = document.getElementById('step6-video-player');

            if (videoPlayer && result.videoUrl) {
              step6VideoUrl = result.videoUrl;
              step6VideoFileUrl = result.videoFileUrl || result.videoUrl;
              videoPlayer.src = result.videoUrl;
              videoSection.style.display = 'block';
            }

            showStatus('🎉 자동화 완료! 영상이 생성되었습니다. YouTube 업로드를 진행하세요.');
            updateProgressIndicator('step6');
            updateStep7Status();

            // 브라우저 알림
            if (Notification.permission === 'granted') {
              new Notification('🎉 자동화 완료!', {
                body: '드라마 영상이 성공적으로 생성되었습니다.',
                icon: '/static/favicon.ico'
              });
            }

            setTimeout(() => {
              progressDiv.style.display = 'none';
            }, 3000);

            break;

          } else if (statusData.status === 'failed') {
            throw new Error(statusData.error || '영상 생성 실패');
          }

        } catch (pollErr) {
          console.error('[AUTO] Polling 오류:', pollErr);
          // 계속 재시도
        }
      }

      // 타임아웃 체크
      if (Date.now() - startTime >= maxWaitTime) {
        throw new Error('영상 생성 시간 초과 (10분)');
      }

    } catch (err) {
      console.error('[AUTO] 영상 생성 오류:', err);
      progressDiv.style.display = 'none';
      showStatus(`❌ 자동화 영상 생성 오류: ${err.message}`);

      // 실패 알림
      if (Notification.permission === 'granted') {
        new Notification('❌ 자동화 실패', {
          body: `영상 생성 오류: ${err.message}`,
          icon: '/static/favicon.ico'
        });
      }
    }
  }

  // 전체 자동 생성 버튼 이벤트
  document.getElementById('btn-generate-all-auto')?.addEventListener('click', generateAllAuto);

  // Step4 저장된 데이터 복원
  function restoreStep4Data() {
    renderCharactersList();
    updateCharacterSelect();
    updateSceneSelect();
    updateSceneCharacterCheckboxes();
    renderCharacterImages();

    // 이미지 복원
    if (step4GeneratedImages.length === 0) return;

    const imageGrid = document.getElementById('step4-image-grid');
    const placeholder = document.getElementById('step4-image-placeholder');

    if (imageGrid && placeholder) {
      placeholder.style.display = 'none';
      imageGrid.style.display = 'grid';

      step4GeneratedImages.forEach(img => {
        const imageItem = document.createElement('div');
        imageItem.className = 'step4-image-item';
        imageItem.innerHTML = `
          <img src="${img.url}" alt="Generated scene" loading="lazy" onclick="window.open('${img.url}', '_blank')">
          <div class="image-caption">
            ${new Date(img.createdAt).toLocaleString('ko-KR')} | ${img.size}
            <button onclick="downloadImage('${img.url}')" style="margin-left: .5rem; padding: .2rem .4rem; font-size: .7rem; cursor: pointer;">💾 저장</button>
          </div>
        `;
        imageGrid.appendChild(imageItem);
      });
    }
  }

  // 페이지 로드 시 Step4 데이터 복원
  setTimeout(restoreStep4Data, 500);

  // ===== Step5: TTS 음성 합성 및 자막 생성 기능 =====
  let step5TtsProvider = 'google';  // 기본: Google Cloud TTS
  let step5SelectedVoice = 'ko-KR-Wavenet-A';  // Google 기본 음성
  let step5AudioUrl = null;
  let step5SubtitleData = null;
  let step5PreviewAudio = null;  // 미리듣기용 오디오

  // 음성 미리듣기 함수
  async function previewVoice(voice, provider) {
    const sampleText = "안녕하세요. 이 목소리로 드라마 나레이션을 진행합니다. 감동적인 이야기를 전해드릴게요.";

    // 기존 재생 중인 오디오 중지
    if (step5PreviewAudio) {
      step5PreviewAudio.pause();
      step5PreviewAudio = null;
    }

    // 버튼 로딩 상태
    const btn = event.target;
    const originalText = btn.textContent;
    btn.textContent = '⏳';
    btn.classList.add('loading');

    try {
      const response = await fetch('/api/drama/generate-tts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          text: sampleText,
          speaker: voice,
          speed: 0,
          pitch: 0,
          volume: 0,
          ttsProvider: provider
        })
      });

      const data = await response.json();

      if (data.ok && data.audioUrl) {
        step5PreviewAudio = new Audio(data.audioUrl);
        step5PreviewAudio.play();

        // 재생 중 버튼 표시
        btn.textContent = '⏸️';

        // 재생 완료 시 버튼 복원
        step5PreviewAudio.onended = () => {
          btn.textContent = '▶️';
          btn.classList.remove('loading');
        };

        // 클릭하면 정지
        btn.onclick = (e) => {
          e.stopPropagation();
          if (step5PreviewAudio) {
            step5PreviewAudio.pause();
            step5PreviewAudio = null;
          }
          btn.textContent = '▶️';
          btn.classList.remove('loading');
          btn.onclick = (e) => {
            e.stopPropagation();
            previewVoice(voice, provider);
          };
        };
      } else {
        alert(`미리듣기 실패: ${data.error || '알 수 없는 오류'}`);
        btn.textContent = '▶️';
        btn.classList.remove('loading');
      }
    } catch (err) {
      alert(`미리듣기 오류: ${err.message}`);
      btn.textContent = '▶️';
      btn.classList.remove('loading');
    }
  }

  // Step3 결과가 있으면 Step5 컨테이너 표시
  function updateStep5Visibility() {
    const step5Container = document.getElementById('step5-container');
    const step3Result = document.getElementById('step3-result')?.value || '';
    if (step5Container) {
      step5Container.style.display = step3Result.trim() ? 'block' : 'none';
    }
  }

  // Step5 가시성 체크 (Step3 결과 변경 감지)
  setInterval(updateStep5Visibility, 1000);

  // TTS 제공자 선택 이벤트
  document.querySelectorAll('.step5-tts-provider').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.step5-tts-provider').forEach(b => {
        b.classList.remove('selected');
        b.style.border = '2px solid #ddd';
        b.style.background = 'white';
      });
      btn.classList.add('selected');
      btn.style.border = '2px solid #10b981';
      btn.style.background = 'rgba(16,185,129,0.2)';

      step5TtsProvider = btn.dataset.provider;

      // 음성 선택 영역 전환
      const googleVoices = document.getElementById('step5-voice-google');
      const naverVoices = document.getElementById('step5-voice-naver');
      const voiceLabel = document.getElementById('step5-voice-label');

      if (step5TtsProvider === 'google') {
        googleVoices.style.display = 'grid';
        naverVoices.style.display = 'none';
        voiceLabel.textContent = '🎤 음성 선택 (Google Cloud)';
        // Google 기본 음성으로 설정
        step5SelectedVoice = 'ko-KR-Wavenet-A';
        googleVoices.querySelectorAll('.step5-voice-option').forEach((o, i) => {
          o.classList.toggle('selected', i === 0);
        });
      } else {
        googleVoices.style.display = 'none';
        naverVoices.style.display = 'grid';
        voiceLabel.textContent = '🎤 음성 선택 (네이버 클로바)';
        // 네이버 기본 음성으로 설정
        step5SelectedVoice = 'nara';
        naverVoices.querySelectorAll('.step5-voice-option').forEach((o, i) => {
          o.classList.toggle('selected', i === 0);
        });
      }
    });
  });

  // 음성 선택 이벤트
  document.querySelectorAll('.step5-voice-option').forEach(option => {
    option.addEventListener('click', () => {
      const provider = option.dataset.provider;
      const container = provider === 'google' ? document.getElementById('step5-voice-google') : document.getElementById('step5-voice-naver');
      container.querySelectorAll('.step5-voice-option').forEach(o => o.classList.remove('selected'));
      option.classList.add('selected');
      step5SelectedVoice = option.dataset.voice;
    });
  });

  // 지문만 추출 함수 (대사 제외) - JSON 파싱 지원 (개선 버전)
  function extractNarration() {
    const step3Result = document.getElementById('step3-result')?.value || '';
    if (!step3Result.trim()) {
      alert('먼저 Step1 대본 완성을 실행해주세요.');
      return;
    }

    // 1. JSON 형태인지 확인하고 파싱 시도
    try {
      let jsonStr = step3Result;
      const jsonMatch = step3Result.match(/```json\s*([\s\S]*?)\s*```/);
      if (jsonMatch) {
        jsonStr = jsonMatch[1];
      }

      const data = JSON.parse(jsonStr);
      const narrations = [];

      // 다양한 JSON 구조 지원
      let scenes = null;
      if (data.script && data.script.scenes && Array.isArray(data.script.scenes)) {
        scenes = data.script.scenes;
        console.log('[extractNarration] data.script.scenes 구조 사용');
      } else if (data.scenes && Array.isArray(data.scenes)) {
        scenes = data.scenes;
        console.log('[extractNarration] data.scenes 구조 사용');
      }

      if (scenes && scenes.length > 0) {
        scenes.forEach((scene) => {
          if (scene.narration) {
            narrations.push(scene.narration);
          }
          if (scene.scene_narration) {
            narrations.push(scene.scene_narration);
          }
        });

        if (narrations.length > 0) {
          document.getElementById('step5-script-text').value = narrations.join('\n\n');
          showStatus(`📝 JSON에서 ${narrations.length}개의 나레이션이 추출되었습니다.`);
          setTimeout(hideStatus, 2000);
          console.log('[extractNarration] JSON에서 나레이션 추출 성공:', narrations.length + '개');
          return;
        }
      }

      console.log('[extractNarration] JSON 파싱 성공했으나 narration 없음, 구조:', Object.keys(data));
    } catch (e) {
      console.log('[extractNarration] JSON 파싱 실패, 기존 방식으로 처리:', e.message);
    }

    // 2. 기존 텍스트 기반 추출 방식 (fallback)
    let narration = step3Result;

    // "인물명: 대사" 패턴 제거
    narration = narration.replace(/^[가-힣a-zA-Z]+\s*[:：]\s*.+$/gm, '');

    // (감정/행동) 형식의 지시문은 유지하되 괄호 제거
    narration = narration.replace(/\(([^)]+)\)/g, '$1');

    // 빈 줄 정리
    narration = narration.replace(/\n{3,}/g, '\n\n').trim();

    document.getElementById('step5-script-text').value = narration;
    showStatus('📝 지문이 추출되었습니다. (텍스트 기반)');
    setTimeout(hideStatus, 2000);
  }

  // TTS 생성 함수
  async function generateTTS() {
    const scriptText = document.getElementById('step5-script-text')?.value || '';
    if (!scriptText.trim()) {
      alert('TTS용 대본 텍스트를 입력해주세요.');
      return;
    }

    const speed = document.getElementById('step5-speed')?.value || 0;
    const pitch = document.getElementById('step5-pitch')?.value || 0;
    const volume = document.getElementById('step5-volume')?.value || 0;

    const btnGenerateTTS = document.getElementById('btn-generate-tts');
    if (btnGenerateTTS) {
      btnGenerateTTS.disabled = true;
      btnGenerateTTS.classList.add('generating');
      btnGenerateTTS.textContent = '⏳ 음성 생성 중...';
    }

    const providerName = step5TtsProvider === 'google' ? 'Google Cloud' : '네이버 클로바';
    showStatus(`🎙️ Step3: ${providerName} TTS 음성 생성 중...`);
    showLoadingOverlay();

    try {
      const response = await fetch('/api/drama/generate-tts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          text: scriptText,
          speaker: step5SelectedVoice,
          speed: parseInt(speed),
          pitch: parseInt(pitch),
          volume: parseInt(volume),
          ttsProvider: step5TtsProvider
        })
      });

      const data = await response.json();

      if (data.ok) {
        // 오디오 플레이어 표시
        const audioSection = document.getElementById('step5-audio-section');
        const audioPlayer = document.getElementById('step5-audio-player');
        const costInfo = document.getElementById('step5-cost-info');

        if (audioPlayer && data.audioUrl) {
          step5AudioUrl = data.audioUrl;
          audioPlayer.src = data.audioUrl;
          audioSection.style.display = 'block';

          // 🎬 오디오 로드 후 길이를 구해서 자막 생성
          audioPlayer.onloadedmetadata = async function() {
            const audioDuration = audioPlayer.duration;
            console.log('[TTS] 오디오 길이:', audioDuration, '초');

            // 비용 정보 표시
            if (costInfo && data.cost) {
              document.getElementById('step5-tts-cost').textContent = '₩' + data.cost.toLocaleString();
              document.getElementById('step5-char-count').textContent = data.charCount?.toLocaleString() || '0';
              costInfo.style.display = 'block';
            }

            showStatus('✅ TTS 음성 생성 완료! SRT 자막 생성 중...');
            updateProgressIndicator('step5');
            updateStep6Visibility();

            // 🎬 TTS 완료 후 SRT 자막 자동 생성 (오디오 길이 전달)
            await generateSubtitleAuto(audioDuration);
          };

          // onloadedmetadata가 이미 발생한 경우 대비
          if (audioPlayer.readyState >= 1) {
            audioPlayer.onloadedmetadata();
          }
        } else {
          // 비용 정보 표시
          if (costInfo && data.cost) {
            document.getElementById('step5-tts-cost').textContent = '₩' + data.cost.toLocaleString();
            document.getElementById('step5-char-count').textContent = data.charCount?.toLocaleString() || '0';
            costInfo.style.display = 'block';
          }

          showStatus('✅ TTS 음성 생성 완료! SRT 자막 생성 중...');
          updateProgressIndicator('step5');
          updateStep6Visibility();

          // 🎬 TTS 완료 후 SRT 자막 자동 생성 (오디오 길이 없음)
          await generateSubtitleAuto(0);
        }
      } else {
        alert(`오류: ${data.error}`);
        showStatus('❌ TTS 생성 실패');
      }
    } catch (err) {
      alert(`네트워크 오류: ${err.message}`);
      showStatus('❌ TTS 생성 오류');
    } finally {
      hideLoadingOverlay();
      setTimeout(hideStatus, 3000);
      if (btnGenerateTTS) {
        btnGenerateTTS.disabled = false;
        btnGenerateTTS.classList.remove('generating');
        btnGenerateTTS.textContent = '음성 생성 (TTS)';
      }
    }
  }

  // 🎬 SRT 자막 자동 생성 (TTS 완료 후 호출)
  async function generateSubtitleAuto(audioDuration = 0) {
    const scriptText = document.getElementById('step5-script-text')?.value || '';
    if (!scriptText.trim()) return;

    try {
      const response = await fetch('/api/drama/generate-subtitle', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          text: scriptText,
          speed: parseInt(document.getElementById('step5-speed')?.value || 0),
          audioDuration: audioDuration || 0  // 실제 TTS 오디오 길이 전달
        })
      });

      const data = await response.json();

      if (data.ok) {
        // 자막 미리보기 표시
        const subtitleSection = document.getElementById('step5-subtitle-section');
        const subtitlePreview = document.getElementById('step5-subtitle-preview');

        if (subtitlePreview && data.srt) {
          step5SubtitleData = data;
          subtitlePreview.textContent = data.srt;
          subtitleSection.style.display = 'block';
        }

        // 자막 정보 표시
        const subtitleInfo = document.getElementById('step5-subtitle-info');
        if (subtitleInfo && data.sentenceCount) {
          document.getElementById('step5-sentence-count').textContent = data.sentenceCount;
          document.getElementById('step5-total-duration').textContent = formatDuration(data.totalDuration);
          subtitleInfo.style.display = 'block';
        }

        showStatus('✅ TTS + SRT 자막 생성 완료!');
        console.log('[TTS+SRT] 자동 생성 완료');
      }
    } catch (err) {
      console.error('[SRT 자동생성 오류]', err);
      // SRT 실패해도 TTS는 성공했으므로 경고만 표시
      showStatus('⚠️ TTS 완료, SRT 자막 생성 실패');
    }
  }

  // 자막 생성 함수
  async function generateSubtitle() {
    const scriptText = document.getElementById('step5-script-text')?.value || '';
    if (!scriptText.trim()) {
      alert('TTS용 대본 텍스트를 입력해주세요.');
      return;
    }

    const btnGenerateSubtitle = document.getElementById('btn-generate-subtitle');
    if (btnGenerateSubtitle) {
      btnGenerateSubtitle.disabled = true;
      btnGenerateSubtitle.classList.add('generating');
      btnGenerateSubtitle.textContent = '⏳ 자막 생성 중...';
    }

    showStatus('📝 Step5: 자막 생성 중...');
    showLoadingOverlay();

    try {
      // 오디오 길이 가져오기 (있으면)
      const audioPlayer = document.getElementById('step5-audio-player');
      const audioDuration = audioPlayer?.duration || 0;

      const response = await fetch('/api/drama/generate-subtitle', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          text: scriptText,
          speed: parseInt(document.getElementById('step5-speed')?.value || 0),
          audioDuration: audioDuration || 0  // 실제 TTS 오디오 길이 전달
        })
      });

      const data = await response.json();

      if (data.ok) {
        // 자막 미리보기 표시
        const subtitleSection = document.getElementById('step5-subtitle-section');
        const subtitlePreview = document.getElementById('step5-subtitle-preview');

        if (subtitlePreview && data.srt) {
          step5SubtitleData = data;
          subtitlePreview.textContent = data.srt;
          subtitleSection.style.display = 'block';
        }

        showStatus('✅ 자막 생성 완료!');
      } else {
        alert(`오류: ${data.error}`);
        showStatus('❌ 자막 생성 실패');
      }
    } catch (err) {
      alert(`네트워크 오류: ${err.message}`);
      showStatus('❌ 자막 생성 오류');
    } finally {
      hideLoadingOverlay();
      setTimeout(hideStatus, 3000);
      if (btnGenerateSubtitle) {
        btnGenerateSubtitle.disabled = false;
        btnGenerateSubtitle.classList.remove('generating');
        btnGenerateSubtitle.textContent = '📝 자막 생성 (SRT)';
      }
    }
  }

  // 오디오 다운로드
  function downloadAudio() {
    if (!step5AudioUrl) {
      alert('먼저 음성을 생성해주세요.');
      return;
    }
    const a = document.createElement('a');
    a.href = step5AudioUrl;
    a.download = `drama-tts-${Date.now()}.mp3`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }

  // SRT 다운로드
  function downloadSRT() {
    if (!step5SubtitleData?.srt) {
      alert('먼저 자막을 생성해주세요.');
      return;
    }
    const blob = new Blob([step5SubtitleData.srt], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `drama-subtitle-${Date.now()}.srt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // VTT 다운로드
  function downloadVTT() {
    if (!step5SubtitleData?.vtt) {
      alert('먼저 자막을 생성해주세요.');
      return;
    }
    const blob = new Blob([step5SubtitleData.vtt], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `drama-subtitle-${Date.now()}.vtt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Step5 초기화
  function clearStep5() {
    if (!confirm('Step5의 모든 내용을 초기화하시겠습니까?')) return;

    document.getElementById('step5-script-text').value = '';
    document.getElementById('step5-audio-section').style.display = 'none';
    document.getElementById('step5-subtitle-section').style.display = 'none';
    document.getElementById('step5-cost-info').style.display = 'none';

    const audioPlayer = document.getElementById('step5-audio-player');
    if (audioPlayer) audioPlayer.src = '';

    step5AudioUrl = null;
    step5SubtitleData = null;

    showStatus('🗑️ Step5가 초기화되었습니다.');
    setTimeout(hideStatus, 2000);
  }

  // Step5 버튼 이벤트 바인딩
  document.getElementById('btn-extract-narration')?.addEventListener('click', extractNarration);
  document.getElementById('btn-generate-tts')?.addEventListener('click', generateTTS);
  document.getElementById('btn-generate-subtitle')?.addEventListener('click', generateSubtitle);
  document.getElementById('btn-download-audio')?.addEventListener('click', downloadAudio);
  document.getElementById('btn-download-srt')?.addEventListener('click', downloadSRT);
  document.getElementById('btn-download-vtt')?.addEventListener('click', downloadVTT);
  document.getElementById('btn-clear-step5')?.addEventListener('click', clearStep5);

  // ===== Step6: 영상 제작 기능 =====
  let step6SelectedImages = [];
  let step6VideoUrl = null;
  let step6VideoFileUrl = null; // 파일 URL (다운로드용)

  // Step6 컨테이너 업데이트 (이미지/오디오 상태 갱신)
  function updateStep6Visibility() {
    // 이미지 그리드 업데이트
    updateStep6ImageGrid();
    // 오디오 상태 업데이트
    updateStep6AudioStatus();
  }

  // 썸네일 자동 생성 (AI)
  let generatedThumbnailUrl = null;

  // 페이지 로드 시 저장된 썸네일 복원
  function restoreThumbnail() {
    const savedThumbnail = localStorage.getItem('_drama-thumbnail');
    if (!savedThumbnail) return;

    try {
      const thumbnailData = JSON.parse(savedThumbnail);
      const thumbnailPreview = document.getElementById('step4-thumbnail-preview');
      const thumbnailImage = document.getElementById('step4-thumbnail-image');
      const thumbnailTextOverlay = document.getElementById('step4-thumbnail-text-overlay');
      const thumbnailPrompt = document.getElementById('step4-thumbnail-prompt');

      if (thumbnailImage && thumbnailData.url) {
        generatedThumbnailUrl = thumbnailData.url;
        thumbnailImage.src = thumbnailData.url;
        thumbnailTextOverlay.textContent = thumbnailData.text || '드라마';
        thumbnailPrompt.textContent = thumbnailData.prompt || '-';
        thumbnailPreview.style.display = 'block';
        console.log('[THUMBNAIL] 저장된 썸네일 복원:', thumbnailData.url);
      }
    } catch (e) {
      console.error('[THUMBNAIL] 복원 실패:', e);
    }
  }

  async function generateYouTubeThumbnail() {
    const btn = document.getElementById('btn-generate-thumbnail');
    const thumbnailPreview = document.getElementById('step4-thumbnail-preview');
    const thumbnailImage = document.getElementById('step4-thumbnail-image');
    const thumbnailTextOverlay = document.getElementById('step4-thumbnail-text-overlay');
    const thumbnailPrompt = document.getElementById('step4-thumbnail-prompt');

    if (!step3Result || !step3Result.trim()) {
      alert('먼저 Step1에서 대본을 작성해주세요.');
      return;
    }

    btn.disabled = true;
    btn.textContent = '생성 중...';
    showStatus('🎨 썸네일 생성 중... (약 15초 소요)');

    try {
      // Step7의 제목 가져오기 (있으면)
      const titleInput = document.getElementById('step7-title');
      const title = titleInput ? titleInput.value : '';

      const response = await fetch('/api/drama/generate-thumbnail', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          script: step3Result,
          title: title,
          provider: step4ImageProvider  // gemini, dalle
        })
      });

      const data = await response.json();

      if (data.ok && data.thumbnailUrl) {
        generatedThumbnailUrl = data.thumbnailUrl;
        thumbnailImage.src = data.thumbnailUrl;
        thumbnailTextOverlay.textContent = data.thumbnailText || title || '드라마';
        thumbnailPrompt.textContent = data.imagePrompt || '-';
        thumbnailPreview.style.display = 'block';

        // 썸네일 데이터 localStorage에 저장
        const thumbnailData = {
          url: data.thumbnailUrl,
          text: data.thumbnailText || title || '드라마',
          prompt: data.imagePrompt || '-',
          createdAt: new Date().toISOString()
        };
        localStorage.setItem('_drama-thumbnail', JSON.stringify(thumbnailData));
        // Firebase에도 백업
        saveToFirebase('_drama-thumbnail', JSON.stringify(thumbnailData));

        showStatus('✅ 썸네일 생성 완료!');
        console.log('[THUMBNAIL] 생성 완료:', data.thumbnailUrl);
      } else {
        throw new Error(data.error || '썸네일 생성 실패');
      }
    } catch (error) {
      console.error('Thumbnail generation error:', error);
      showStatus(`❌ 썸네일 생성 실패: ${error.message}`);
      alert(`썸네일 생성 실패: ${error.message}`);
    } finally {
      btn.disabled = false;
      btn.textContent = '📸 썸네일 생성';
    }
  }

  // 썸네일 재생성
  async function regenerateThumbnail() {
    await generateYouTubeThumbnail();
  }

  // 썸네일 버튼 이벤트
  document.getElementById('btn-generate-thumbnail')?.addEventListener('click', generateYouTubeThumbnail);
  document.getElementById('btn-regenerate-thumbnail')?.addEventListener('click', regenerateThumbnail);

  // Step6 이미지 그리드 업데이트
  function updateStep6ImageGrid() {
    const grid = document.getElementById('step6-image-grid');
    if (!grid) return;

    if (!step4GeneratedImages || step4GeneratedImages.length === 0) {
      grid.innerHTML = '<div style="color: #999; text-align: center; padding: 1rem; grid-column: 1/-1;">Step2에서 이미지를 생성하면 여기에 표시됩니다</div>';
      return;
    }

    grid.innerHTML = step4GeneratedImages.map((img, idx) => `
      <div class="step6-preview-item ${step6SelectedImages.includes(img.url) ? 'selected' : ''}" data-url="${img.url}" onclick="toggleStep6Image('${img.url}')">
        <img src="${img.url}" alt="Scene ${idx + 1}">
      </div>
    `).join('');
  }

  // 이미지 선택 토글
  function toggleStep6Image(url) {
    const idx = step6SelectedImages.indexOf(url);
    if (idx > -1) {
      step6SelectedImages.splice(idx, 1);
    } else {
      step6SelectedImages.push(url);
    }
    updateStep6ImageGrid();
  }

  // Step6 오디오 상태 업데이트
  function updateStep6AudioStatus() {
    const statusDiv = document.getElementById('step6-audio-status');
    const audioPreview = document.getElementById('step6-audio-preview');

    if (step5AudioUrl) {
      statusDiv.innerHTML = '✅ 음성이 연결되었습니다';
      statusDiv.style.color = '#27ae60';
      audioPreview.src = step5AudioUrl;
      audioPreview.style.display = 'block';
    } else {
      statusDiv.innerHTML = 'Step3에서 음성을 생성하면 자동으로 연결됩니다';
      statusDiv.style.color = '#666';
      audioPreview.style.display = 'none';
    }
  }

  // Step6 가시성 체크 (주기적)
  setInterval(updateStep6Visibility, 2000);

  // 이미지 업로드 함수 (base64 -> 서버 URL)
  async function uploadImageToServer(imageData) {
    // 이미 HTTP URL인 경우 그대로 반환
    if (imageData.startsWith('http://') || imageData.startsWith('https://') || imageData.startsWith('/')) {
      return imageData;
    }

    // Base64 이미지인 경우 서버에 업로드 (502/503/504 재시도 포함)
    const maxRetries = 3;
    let lastError;

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        const response = await fetch('/api/drama/upload-image', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ imageData: imageData })
        });

        // 502, 503, 504 서버 오류는 재시도
        if ([502, 503, 504].includes(response.status)) {
          const retryDelay = Math.pow(2, attempt + 1) * 1000;
          console.log(`[UPLOAD] 서버 오류 (${response.status}), ${retryDelay/1000}초 후 재시도... (${attempt + 1}/${maxRetries})`);
          lastError = `서버 오류 (${response.status})`;
          await new Promise(resolve => setTimeout(resolve, retryDelay));
          continue;
        }

        if (!response.ok) {
          throw new Error(`이미지 업로드 실패 (${response.status})`);
        }

        const data = await response.json();
        if (!data.ok) {
          throw new Error(data.error || '이미지 업로드 실패');
        }

        return data.imageUrl;
      } catch (err) {
        lastError = err.message;
        if (attempt < maxRetries - 1 && !err.message.includes('업로드 실패')) {
          const retryDelay = Math.pow(2, attempt + 1) * 1000;
          console.log(`[UPLOAD] 네트워크 오류, ${retryDelay/1000}초 후 재시도... (${attempt + 1}/${maxRetries})`);
          await new Promise(resolve => setTimeout(resolve, retryDelay));
        } else {
          throw err;
        }
      }
    }

    throw new Error(lastError || '이미지 업로드 실패');
  }

  // 사이드바 진행 상태 업데이트 함수
  function updateSidebarStepProgress(stepName, status, message) {
    const stepEl = document.querySelector(`.progress-step-sidebar[data-step="${stepName}"]`);
    if (!stepEl) return;

    const substatus = stepEl.querySelector('.step-substatus');
    const statusIcon = stepEl.querySelector('.step-status-icon');
    const container = stepEl.querySelector('div');
    const indicator = stepEl.querySelector('.step-indicator');

    if (status === 'processing') {
      substatus.textContent = message || '진행 중...';
      substatus.style.color = 'rgba(255, 193, 7, 0.9)';
      statusIcon.textContent = '⏳';
      statusIcon.style.color = '#ffc107';
      container.style.borderLeftColor = '#ffc107';
      container.style.background = 'rgba(255, 193, 7, 0.2)';
      indicator.style.background = '#ffc107';
    } else if (status === 'completed') {
      substatus.textContent = '완료';
      substatus.style.color = 'rgba(16, 185, 129, 0.9)';
      statusIcon.textContent = '✓';
      statusIcon.style.color = '#10b981';
      container.style.borderLeftColor = '#10b981';
      container.style.background = 'rgba(16, 185, 129, 0.2)';
      indicator.style.background = '#10b981';
    } else if (status === 'error') {
      substatus.textContent = message || '오류';
      substatus.style.color = 'rgba(239, 68, 68, 0.9)';
      statusIcon.textContent = '✗';
      statusIcon.style.color = '#ef4444';
      container.style.borderLeftColor = '#ef4444';
      container.style.background = 'rgba(239, 68, 68, 0.2)';
    }
  }

  // 영상 생성 함수
  async function generateVideo() {
    // 유효성 검사
    if (step6SelectedImages.length === 0) {
      alert('최소 1개 이상의 이미지를 선택해주세요.');
      return;
    }

    if (!step5AudioUrl) {
      alert('Step3에서 음성을 먼저 생성해주세요.');
      return;
    }

    // 브라우저 알림 권한 요청
    if (Notification.permission === 'default') {
      await Notification.requestPermission();
    }

    const resolution = document.getElementById('step6-resolution')?.value || '1920x1080';
    const fps = document.getElementById('step6-fps')?.value || '30';
    const transition = document.getElementById('step6-transition')?.value || 'fade';
    const includeSubtitle = document.getElementById('step6-include-subtitle')?.checked || false;
    const burnSubtitle = document.getElementById('step6-burn-subtitle')?.checked || false;

    const btnGenerateVideo = document.getElementById('btn-generate-video');
    const progressDiv = document.getElementById('step6-progress');
    const progressBar = document.getElementById('step6-progress-bar');
    const progressText = document.getElementById('step6-progress-text');

    if (btnGenerateVideo) {
      btnGenerateVideo.disabled = true;
      btnGenerateVideo.classList.add('generating');
      btnGenerateVideo.textContent = '⏳ 영상 생성 중...';
    }

    progressDiv.style.display = 'block';
    progressBar.style.width = '5%';
    progressText.textContent = '이미지 업로드 준비 중...';

    showStatus('🎬 Step4: 영상 생성 시작...');

    // 사이드바 진행 상태 업데이트
    updateSidebarStepProgress('step6', 'processing', '준비 중...');

    try {
      // 1. Base64 이미지를 서버에 먼저 업로드 (요청 크기 줄이기)
      const uploadedImageUrls = [];
      const totalImages = step6SelectedImages.length;

      for (let i = 0; i < totalImages; i++) {
        progressBar.style.width = (5 + (i / totalImages) * 20) + '%';
        progressText.textContent = `이미지 업로드 중... (${i + 1}/${totalImages})`;
        updateSidebarStepProgress('step6', 'processing', `업로드 ${i + 1}/${totalImages}`);

        try {
          const uploadedUrl = await uploadImageToServer(step6SelectedImages[i]);
          uploadedImageUrls.push(uploadedUrl);
        } catch (uploadErr) {
          console.error(`이미지 ${i + 1} 업로드 실패:`, uploadErr);
          throw new Error(`이미지 ${i + 1} 업로드 실패: ${uploadErr.message}`);
        }
      }

      console.log(`[VIDEO] ${uploadedImageUrls.length}개 이미지 업로드 완료`);

      progressBar.style.width = '25%';
      progressText.textContent = '영상 생성 작업 시작 중...';
      updateSidebarStepProgress('step6', 'processing', '영상 생성 중...');

      // 2. 영상 생성 작업 시작 (즉시 job_id 반환)
      const response = await fetch('/api/drama/generate-video', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          images: uploadedImageUrls,
          audioUrl: step5AudioUrl,
          subtitleData: includeSubtitle ? step5SubtitleData : null,
          burnSubtitle: burnSubtitle,
          resolution: resolution,
          fps: parseInt(fps),
          transition: transition
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`서버 오류 (${response.status}): ${errorText || '응답 없음'}`);
      }

      const data = await response.json();

      if (!data.ok || !data.jobId) {
        throw new Error(data.error || '작업 시작 실패');
      }

      const jobId = data.jobId;
      console.log(`[VIDEO] 작업 시작됨: ${jobId}`);

      progressBar.style.width = '30%';
      progressText.textContent = '백그라운드에서 영상 생성 중... (다른 작업 가능)';
      showStatus('🎬 영상 생성 중... (백그라운드 작업)');

      // 3. Polling으로 상태 체크
      const startTime = Date.now();
      const maxWaitTime = 600000; // 10분
      let lastProgress = 30;

      while (Date.now() - startTime < maxWaitTime) {
        await new Promise(resolve => setTimeout(resolve, 2000)); // 2초마다 체크

        try {
          const statusResponse = await fetch(`/api/drama/video-status/${jobId}`);

          if (!statusResponse.ok) {
            console.error('상태 조회 실패:', statusResponse.status);
            continue;
          }

          const statusData = await statusResponse.json();

          if (!statusData.ok) {
            throw new Error(statusData.error || '상태 조회 실패');
          }

          // 진행률 업데이트
          const serverProgress = statusData.progress || 0;
          const displayProgress = Math.max(lastProgress, 30 + serverProgress * 0.7); // 30~100%
          lastProgress = displayProgress;
          progressBar.style.width = displayProgress + '%';
          progressText.textContent = statusData.message || '영상 생성 중...';

          // 사이드바 진행 상황 업데이트
          updateSidebarStepProgress('step6', 'processing', `${Math.round(displayProgress)}%`);

          console.log(`[VIDEO] 상태: ${statusData.status}, 진행률: ${serverProgress}%`);

          // 완료 확인
          if (statusData.status === 'completed' && statusData.result) {
            // 성공!
            progressBar.style.width = '100%';
            progressText.textContent = '완료!';

            const result = statusData.result;

            // 영상 플레이어 표시
            const videoSection = document.getElementById('step6-video-section');
            const videoPlayer = document.getElementById('step6-video-player');

            if (videoPlayer && result.videoUrl) {
              step6VideoUrl = result.videoUrl;
              step6VideoFileUrl = result.videoFileUrl || result.videoUrl;
              videoPlayer.src = result.videoUrl;
              videoSection.style.display = 'block';
            }

            showStatus('✅ 영상 생성 완료! Step5에서 YouTube 업로드가 가능합니다.');
            updateProgressIndicator('step6');
            updateStep7Status();

            // 브라우저 알림
            if (Notification.permission === 'granted') {
              new Notification('✅ 영상 생성 완료!', {
                body: '드라마 영상이 성공적으로 생성되었습니다.',
                icon: '/static/favicon.ico'
              });
            }

            setTimeout(() => {
              progressDiv.style.display = 'none';
            }, 1500);

            break;

          } else if (statusData.status === 'failed') {
            // 실패
            throw new Error(statusData.error || '영상 생성 실패');
          }

          // pending 또는 processing 상태 - 계속 대기

        } catch (pollErr) {
          console.error('Polling 오류:', pollErr);
          // 계속 재시도
        }
      }

      // 타임아웃 체크
      if (Date.now() - startTime >= maxWaitTime) {
        throw new Error('영상 생성 시간 초과 (10분). 작업은 백그라운드에서 계속 진행될 수 있습니다.');
      }

    } catch (err) {
      progressDiv.style.display = 'none';
      alert(`오류: ${err.message}`);
      showStatus('❌ 영상 생성 실패');

      // 사이드바에 오류 표시
      updateSidebarStepProgress('step6', 'error', '오류 발생');

      // 실패 알림
      if (Notification.permission === 'granted') {
        new Notification('❌ 영상 생성 실패', {
          body: err.message,
          icon: '/static/favicon.ico'
        });
      }
    } finally {
      setTimeout(hideStatus, 3000);
      if (btnGenerateVideo) {
        btnGenerateVideo.disabled = false;
        btnGenerateVideo.classList.remove('generating');
        btnGenerateVideo.textContent = '🎬 영상 생성';
      }
    }
  }

  // 영상 다운로드
  function downloadVideo() {
    if (!step6VideoUrl && !step6VideoFileUrl) {
      alert('먼저 영상을 생성해주세요.');
      return;
    }
    const a = document.createElement('a');
    // 파일 URL이 있으면 우선 사용 (더 안정적)
    a.href = step6VideoFileUrl || step6VideoUrl;
    a.download = `drama-video-${Date.now()}.mp4`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }

  // Step6 초기화
  function clearStep6() {
    if (!confirm('Step6의 모든 내용을 초기화하시겠습니까?')) return;

    step6SelectedImages = [];
    step6VideoUrl = null;
    step6VideoFileUrl = null;

    document.getElementById('step6-video-section').style.display = 'none';
    document.getElementById('step6-progress').style.display = 'none';

    const videoPlayer = document.getElementById('step6-video-player');
    if (videoPlayer) videoPlayer.src = '';

    updateStep6ImageGrid();

    showStatus('🗑️ Step6가 초기화되었습니다.');
    setTimeout(hideStatus, 2000);
  }

  // Step6 버튼 이벤트 바인딩
  document.getElementById('btn-generate-video')?.addEventListener('click', generateVideo);
  document.getElementById('btn-download-video')?.addEventListener('click', downloadVideo);
  document.getElementById('btn-clear-step6')?.addEventListener('click', clearStep6);

  // ===== Step7: 유튜브 업로드 =====
  let youtubeAuthenticated = false;

  // Step7 업로드 상태 메시지 업데이트
  function updateStep7Status() {
    const statusEl = document.getElementById('step7-upload-status');
    const uploadBtn = document.getElementById('btn-upload-youtube');
    const videoSrc = getStep6Video();

    if (!statusEl) return;

    if (!youtubeAuthenticated) {
      statusEl.style.background = '#fff3cd';
      statusEl.style.color = '#856404';
      statusEl.textContent = 'YouTube 인증을 먼저 진행해주세요';
      if (uploadBtn) uploadBtn.disabled = true;
    } else if (!videoSrc) {
      statusEl.style.background = '#fff3cd';
      statusEl.style.color = '#856404';
      statusEl.textContent = 'Step4에서 영상을 먼저 생성해주세요';
      if (uploadBtn) uploadBtn.disabled = true;
    } else {
      statusEl.style.background = '#d4edda';
      statusEl.style.color = '#155724';
      statusEl.textContent = '영상이 준비되었습니다. 업로드할 수 있습니다!';
      if (uploadBtn) uploadBtn.disabled = false;
    }
  }

  // 주기적으로 Step7 상태 업데이트
  setInterval(updateStep7Status, 3000);

  // 개인정보 옵션 선택
  function selectStep7Privacy(value) {
    document.querySelectorAll('.step7-privacy-option').forEach(opt => {
      opt.classList.remove('selected');
      const input = opt.querySelector('input[type="radio"]');
      if (input) input.checked = false;
      if (opt.dataset.privacy === value) {
        opt.classList.add('selected');
        if (input) input.checked = true;
      }
    });
  }

  // 개인정보 옵션 이벤트
  document.querySelectorAll('.step7-privacy-option').forEach(opt => {
    opt.addEventListener('click', () => selectStep7Privacy(opt.dataset.privacy));
  });

  // 대본 기반 자동 메타데이터 생성
  async function generateAutoMetadata() {
    const btn = document.getElementById('btn-auto-metadata');
    const step3Result = document.getElementById('step3-result')?.value || '';

    if (!step3Result.trim()) {
      showStatus('Step1 대본 결과가 없습니다. 먼저 대본을 작성해주세요.');
      return;
    }

    btn.disabled = true;
    btn.textContent = '생성 중...';
    showStatus('대본을 분석하여 제목, 설명, 태그를 생성 중...');

    try {
      const response = await fetch('/api/drama/generate-metadata', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ script: step3Result })
      });

      const data = await response.json();

      if (data.ok && data.metadata) {
        document.getElementById('step7-title').value = data.metadata.title || '';
        document.getElementById('step7-description').value = data.metadata.description || '';
        document.getElementById('step7-tags').value = data.metadata.tags || '';
        showStatus('메타데이터가 자동으로 입력되었습니다!');
      } else {
        throw new Error(data.error || '메타데이터 생성 실패');
      }
    } catch (error) {
      console.error('Auto metadata error:', error);
      showStatus(`메타데이터 생성 실패: ${error.message}`);
    } finally {
      btn.disabled = false;
      btn.textContent = '대본 기반 자동 입력';
    }
  }

  // 자동 메타데이터 버튼 이벤트
  document.getElementById('btn-auto-metadata')?.addEventListener('click', generateAutoMetadata);

  // 유튜브 인증
  async function authenticateYouTube() {
    const authBtn = document.getElementById('btn-youtube-auth');
    const authStatus = document.getElementById('youtube-auth-status');

    authBtn.disabled = true;
    authBtn.textContent = '🔄 인증 중...';
    authStatus.innerHTML = '<span style="color: #f39c12;">⏳ YouTube 인증을 진행 중입니다...</span>';

    try {
      const response = await fetch('/api/drama/youtube-auth', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });

      const data = await response.json();
      console.log('[YOUTUBE-AUTH] 응답 데이터:', data);

      if (data.success) {
        youtubeAuthenticated = true;
        authBtn.textContent = '✅ 인증 완료';
        authBtn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
        authStatus.innerHTML = '<span style="color: #27ae60;">✅ YouTube 인증이 완료되었습니다.</span>';
        updateStep7Status();
        // 채널 목록 로드
        await loadYouTubeChannels();
      } else if (data.auth_url) {
        // OAuth URL이 제공되면 새 창에서 열기
        console.log('[YOUTUBE-AUTH] OAuth URL:', data.auth_url);
        const popup = window.open(data.auth_url, '_blank', 'width=600,height=700');

        if (!popup) {
          authBtn.disabled = false;
          authBtn.textContent = '🔑 YouTube 연결';
          authStatus.innerHTML = '<span style="color: #e74c3c;">❌ 팝업이 차단되었습니다. 브라우저 설정에서 팝업을 허용해주세요.</span>';
          return;
        }

        authBtn.textContent = '🔗 인증 대기 중';
        authStatus.innerHTML = '<span style="color: #f39c12;">⏳ 새 창에서 YouTube 인증을 완료해주세요.</span>';

        // postMessage 리스너 등록 (콜백 창에서 인증 완료 메시지 수신)
        window.youtubeAuthPollActive = true;
        const messageHandler = async (event) => {
          if (event.data && event.data.type === 'youtube-auth-success') {
            console.log('[YOUTUBE-AUTH] postMessage로 인증 완료 수신');
            window.youtubeAuthPollActive = false; // 폴링 중단
            window.removeEventListener('message', messageHandler);
            await handleYouTubeAuthSuccess();
          }
        };
        window.addEventListener('message', messageHandler);

        // 인증 상태 폴링 (백업)
        pollYouTubeAuth();
      } else {
        // 에러 메시지를 더 명확하게 표시
        const errorMsg = data.error || '인증 실패 (알 수 없는 오류)';
        console.error('[YOUTUBE-AUTH] 에러:', errorMsg);
        throw new Error(errorMsg);
      }
    } catch (error) {
      console.error('YouTube auth error:', error);
      authBtn.disabled = false;
      authBtn.textContent = '🔗 YouTube 인증';
      authStatus.innerHTML = `<span style="color: #e74c3c;">❌ 인증 실패: ${error.message}</span>`;
    }
  }

  // YouTube 채널 목록 로드
  async function loadYouTubeChannels() {
    try {
      const response = await fetch('/api/drama/youtube-channels');
      const data = await response.json();

      if (data.success && data.channels && data.channels.length > 0) {
        const channelSelect = document.getElementById('step7-channel-select');
        const channelSection = document.getElementById('youtube-channel-section');

        // 기존 옵션 제거 (첫 번째 제외)
        channelSelect.innerHTML = '<option value="">채널을 선택하세요</option>';

        // 채널 추가
        data.channels.forEach(channel => {
          const option = document.createElement('option');
          option.value = channel.id;
          option.textContent = channel.title;
          channelSelect.appendChild(option);
        });

        // 채널이 하나면 자동 선택
        if (data.channels.length === 1) {
          channelSelect.value = data.channels[0].id;
        }

        // 채널 선택 섹션 표시
        channelSection.style.display = 'block';

        // 사용자에게 채널 선택 안내 표시
        showStatus(`✅ YouTube 채널이 로드되었습니다! ${data.channels.length}개 채널 중 업로드할 채널을 선택해주세요.`);

        // 채널 섹션으로 스크롤
        setTimeout(() => {
          channelSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 500);
      }
    } catch (error) {
      console.error('채널 목록 로드 실패:', error);
    }
  }

  // YouTube 인증 성공 처리 (공통 함수)
  async function handleYouTubeAuthSuccess() {
    const authBtn = document.getElementById('btn-youtube-auth');
    const authStatus = document.getElementById('youtube-auth-status');

    youtubeAuthenticated = true;
    authBtn.textContent = '✅ 인증 완료';
    authBtn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
    authBtn.disabled = true;
    authStatus.innerHTML = '<span style="color: #27ae60;">✅ YouTube 인증이 완료되었습니다.</span>';
    updateStep7Status();
    // 채널 목록 로드
    await loadYouTubeChannels();
  }

  // 인증 상태 폴링 (postMessage 실패 시 백업)
  async function pollYouTubeAuth() {
    const authBtn = document.getElementById('btn-youtube-auth');
    const authStatus = document.getElementById('youtube-auth-status');

    for (let i = 0; i < 60; i++) {
      // postMessage로 이미 처리됐으면 폴링 중단
      if (!window.youtubeAuthPollActive) {
        console.log('[YOUTUBE-AUTH] 폴링 중단 (postMessage로 처리됨)');
        return;
      }

      await new Promise(resolve => setTimeout(resolve, 2000));

      try {
        const response = await fetch('/api/drama/youtube-auth-status');
        const data = await response.json();
        console.log('[YOUTUBE-AUTH] 폴링 상태:', data);

        if (data.authenticated) {
          window.youtubeAuthPollActive = false;
          await handleYouTubeAuthSuccess();
          return;
        }
      } catch (e) {
        console.error('Poll error:', e);
      }
    }

    window.youtubeAuthPollActive = false;
    authBtn.disabled = false;
    authBtn.textContent = '🔗 YouTube 인증';
    authStatus.innerHTML = '<span style="color: #e74c3c;">❌ 인증 시간이 초과되었습니다. 다시 시도해주세요.</span>';
  }

  // Step6 비디오 가져오기
  function getStep6Video() {
    const videoPlayer = document.getElementById('step6-video-player');
    if (videoPlayer && videoPlayer.src && videoPlayer.src !== window.location.href) {
      return videoPlayer.src;
    }
    return null;
  }

  // 유튜브 업로드
  async function uploadToYouTube() {
    const videoSrc = getStep6Video();
    if (!videoSrc) {
      showStatus('❌ 업로드할 비디오가 없습니다. Step6에서 먼저 비디오를 생성해주세요.');
      return;
    }

    const title = document.getElementById('step7-title').value.trim();
    if (!title) {
      showStatus('❌ 비디오 제목을 입력해주세요.');
      return;
    }

    // 선택된 채널 확인
    const channelSelect = document.getElementById('step7-channel-select');
    const selectedChannelId = channelSelect.value;
    if (!selectedChannelId) {
      showStatus('❌ 업로드할 채널을 선택해주세요.');
      return;
    }

    const description = document.getElementById('step7-description').value.trim();
    const tags = document.getElementById('step7-tags').value.trim();
    const category = document.getElementById('step7-category').value;
    const privacyOption = document.querySelector('.step7-privacy-option.selected');
    const privacyValue = privacyOption ? privacyOption.dataset.privacy : 'scheduled';

    // 예약 업로드인 경우 30분 후 공개 시간 계산
    let privacy = privacyValue;
    let publishAt = null;
    if (privacyValue === 'scheduled') {
      privacy = 'private';  // 예약 시 일단 비공개로 업로드
      const scheduledTime = new Date(Date.now() + 30 * 60 * 1000);  // 30분 후
      publishAt = scheduledTime.toISOString();
    }

    const uploadBtn = document.getElementById('btn-upload-youtube');
    const progressContainer = document.getElementById('step7-progress');
    const progressFill = document.getElementById('step7-progress-bar');
    const progressText = document.getElementById('step7-progress-text');
    const resultContainer = document.getElementById('step7-result');

    uploadBtn.disabled = true;
    uploadBtn.textContent = '⏳ 업로드 중...';
    progressContainer.style.display = 'block';
    resultContainer.style.display = 'none';

    try {
      // 비디오 데이터 가져오기
      progressText.textContent = '비디오 데이터 준비 중...';
      progressFill.style.width = '10%';

      const videoResponse = await fetch(videoSrc);
      const videoBlob = await videoResponse.blob();
      const videoBase64 = await blobToBase64(videoBlob);

      progressText.textContent = publishAt ? '유튜브에 예약 업로드 중...' : '유튜브에 업로드 중...';
      progressFill.style.width = '30%';

      const response = await fetch('/api/drama/upload-youtube', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          video_data: videoBase64,
          title: title,
          description: description,
          tags: tags.split(',').map(t => t.trim()).filter(t => t),
          category_id: category,
          privacy_status: privacy,
          publish_at: publishAt,
          channel_id: selectedChannelId
        })
      });

      progressFill.style.width = '80%';

      const data = await response.json();

      if (data.success) {
        progressFill.style.width = '100%';
        progressText.textContent = publishAt ? '예약 업로드 완료!' : '업로드 완료!';

        resultContainer.style.display = 'block';
        document.getElementById('step7-video-link').href = data.video_url;
        document.getElementById('step7-video-link').textContent = data.video_url;
        document.getElementById('step7-video-id').textContent = data.video_id;

        const scheduledMsg = publishAt ? ` (${new Date(publishAt).toLocaleString('ko-KR')}에 공개 예정)` : '';
        showStatus(`🎉 YouTube 업로드가 완료되었습니다!${scheduledMsg}`);
        updateProgressIndicator('step7');
      } else {
        throw new Error(data.error || '업로드 실패');
      }
    } catch (error) {
      console.error('Upload error:', error);
      progressText.textContent = `업로드 실패: ${error.message}`;
      progressFill.style.background = '#e74c3c';
      showStatus(`❌ 업로드 실패: ${error.message}`);
    } finally {
      uploadBtn.disabled = false;
      uploadBtn.textContent = '📤 YouTube 업로드';
    }
  }

  // Blob을 Base64로 변환
  function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        const base64 = reader.result.split(',')[1];
        resolve(base64);
      };
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }

  // Step7 초기화
  function clearStep7() {
    document.getElementById('step7-title').value = '';
    document.getElementById('step7-description').value = '';
    document.getElementById('step7-tags').value = '';
    document.getElementById('step7-category').value = '22';
    selectStep7Privacy('scheduled');

    document.getElementById('step7-progress').style.display = 'none';
    document.getElementById('step7-progress-bar').style.width = '0%';
    document.getElementById('step7-progress-bar').style.background = 'linear-gradient(135deg, #ff0000, #cc0000)';
    document.getElementById('step7-result').style.display = 'none';

    showStatus('Step7이 초기화되었습니다.');
    setTimeout(hideStatus, 2000);
  }

  // Step7 버튼 이벤트 바인딩
  document.getElementById('btn-youtube-auth')?.addEventListener('click', authenticateYouTube);
  document.getElementById('btn-upload-youtube')?.addEventListener('click', uploadToYouTube);
  document.getElementById('btn-clear-step7')?.addEventListener('click', clearStep7);

  // Step7 초기화 - 기본 공개 설정은 예약 (30분 후 공개)
  selectStep7Privacy('scheduled');

  // ===== 렌더링 함수 =====
  function renderCategories() {
    const select = document.getElementById('drama-category');
    if (!select) return;

    const current = select.value;
    select.innerHTML = config.categories.map(c =>
      `<option value="${c.value}">${c.label}</option>`
    ).join('');

    if (current && config.categories.find(c => c.value === current)) {
      select.value = current;
    } else {
      select.value = config.categories[0].value;
    }
    currentCategory = select.value;
  }

  // Styles are no longer used - main character is a text input field

  function renderProcessingSteps() {
    const steps = getCurrentSteps();
    const container = document.getElementById('processing-steps');

    if (!container) return;

    if (steps.length === 0) {
      container.innerHTML = '<p style="color: #999; font-size: .85rem; text-align: center;">단계를 추가하세요.</p>';
      return;
    }

    container.innerHTML = steps.map(step =>
      `<button class="step-btn primary" data-step="${step.id}">${step.order}. ${step.name}</button>`
    ).join('');

    container.querySelectorAll('.step-btn').forEach(btn => {
      btn.addEventListener('click', () => executeStep(btn.dataset.step));
    });
  }

  function renderResultBoxes() {
    const steps = getCurrentSteps();
    const container = document.getElementById('result-boxes');

    if (!container) return;

    container.innerHTML = steps.map(step => `
      <div class="box">
        <label class="label">${step.name}</label>
        <textarea id="result-${step.id}" class="autosize" style="min-height: 140px;" placeholder="${step.name} 결과가 표시됩니다."></textarea>
      </div>
    `).join('');

    // 결과 복원 및 자동 높이
    steps.forEach(step => {
      if (stepResults[step.id]) {
        const textarea = document.getElementById(`result-${step.id}`);
        if (textarea) {
          textarea.value = stepResults[step.id];
          autoResize(textarea);
        }
      }
    });

    // 입력 이벤트로 자동 높이 + 결과 저장
    container.querySelectorAll('textarea').forEach(textarea => {
      textarea.addEventListener('input', () => {
        autoResize(textarea);
        // 사용자가 편집한 내용을 stepResults에 저장
        const stepId = textarea.id.replace('result-', '');
        stepResults[stepId] = textarea.value;
        // ⭐ 세션에도 저장
        saveStep2ResultToSession(stepId, textarea.value);
      });
    });
  }

  function renderGuideTabs() {
    const steps = getCurrentSteps();
    const container = document.getElementById('guide-tabs');

    if (!container) return;

    container.innerHTML = steps.map(step =>
      `<button class="${step.id === currentGuideStep ? 'primary' : ''}"
        data-step="${step.id}">${step.name}</button>`
    ).join('');

    container.querySelectorAll('button').forEach(btn => {
      btn.addEventListener('click', () => {
        currentGuideStep = btn.dataset.step;
        renderGuideTabs();
        loadGuide(currentCategory, currentGuideStep);
      });
    });
  }

  // ===== 처리 단계 실행 =====
  async function executeStep(stepId) {
    const benchmarkScript = document.getElementById('benchmark-script').value;
    const mainCharacter = document.getElementById('main-character').value;
    const guideKey = getGuideKey(currentCategory, stepId);
    const guide = localStorage.getItem(guideKey) || '';

    // 총괄 지침 가져오기
    const settings = config.categorySettings[currentCategory];
    const masterGuide = settings ? settings.masterGuide : '';

    const steps = getCurrentSteps();
    const currentStepIndex = steps.findIndex(s => s.id === stepId);
    const previousResults = {};
    for (let i = 0; i < currentStepIndex; i++) {
      const prevStep = steps[i];
      if (stepResults[prevStep.id]) {
        previousResults[prevStep.id] = {
          name: prevStep.name,
          result: stepResults[prevStep.id]
        };
      }
    }

    showStatus(`🤖 ${getStepName(stepId)} 처리 중...`);

    try {
      const response = await fetch('/api/drama/process', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          category: currentCategory,
          stepId: stepId,
          stepName: getStepName(stepId),
          text: benchmarkScript,
          mainCharacter: mainCharacter,
          guide: guide,
          masterGuide: masterGuide,
          previousResults: previousResults
        })
      });

      const data = await response.json();

      if (data.ok) {
        stepResults[stepId] = data.result;
        // ⭐ 세션에도 저장
        saveStep2ResultToSession(stepId, data.result);

        const textarea = document.getElementById(`result-${stepId}`);
        if (textarea) {
          textarea.value = data.result;
          autoResize(textarea);
        }

        showStatus('✅ 완료!');
      } else {
        alert(`오류: ${data.error}`);
        showStatus('❌ 실패');
      }
    } catch (err) {
      alert(`네트워크 오류: ${err.message}`);
      showStatus('❌ 오류');
    } finally {
      setTimeout(hideStatus, 2000);
    }
  }

  // ===== 카테고리 변경 =====
  const categorySelect = document.getElementById('drama-category');
  if (categorySelect) {
    categorySelect.addEventListener('change', (e) => {
      currentCategory = e.target.value;
      stepResults = {};
      const gptProContainer = document.getElementById('gpt-pro-result-container');
      if (gptProContainer) gptProContainer.style.display = 'none';

      loadMasterGuide(currentCategory);
      renderProcessingSteps();
      renderResultBoxes();
      renderGuideTabs();
    });
  }

  // ===== 패스워드 =====
  const toggleGuidesBtn = document.getElementById('toggle-guides');
  if (toggleGuidesBtn) {
    toggleGuidesBtn.addEventListener('click', () => {
      const content = document.getElementById('guide-content');
      const btn = document.getElementById('toggle-guides');

      if (!content || !btn) return;

      if (content.style.display === 'none') {
        if (!guideUnlocked) {
          const modal = document.getElementById('modal-password');
          if (modal) modal.classList.add('show');
          const input = document.getElementById('password-input');
          if (input) {
            input.value = '';
            input.focus();
          }
        } else {
          content.style.display = 'block';
          btn.textContent = '닫기';
        }
      } else {
        content.style.display = 'none';
        btn.textContent = '열기';
      }
    });
  }

  const btnSubmitPassword = document.getElementById('btn-submit-password');
  if (btnSubmitPassword) {
    btnSubmitPassword.addEventListener('click', () => {
      const input = document.getElementById('password-input');
      if (input && input.value === GUIDE_PASSWORD) {
        guideUnlocked = true;
        const modal = document.getElementById('modal-password');
        if (modal) modal.classList.remove('show');
        const content = document.getElementById('guide-content');
        if (content) content.style.display = 'block';
        const btn = document.getElementById('toggle-guides');
        if (btn) btn.textContent = '닫기';

        const steps = getCurrentSteps();
        if (steps.length > 0) {
          currentGuideStep = steps[0].id;
          renderGuideTabs();
          loadGuide(currentCategory, currentGuideStep);
        }
      } else {
        alert('❌ 패스워드가 틀렸습니다.');
        if (input) input.value = '';
      }
    });
  }

  const btnCancelPassword = document.getElementById('btn-cancel-password');
  if (btnCancelPassword) {
    btnCancelPassword.addEventListener('click', () => {
      const modal = document.getElementById('modal-password');
      if (modal) modal.classList.remove('show');
    });
  }

  const passwordInput = document.getElementById('password-input');
  if (passwordInput) {
    passwordInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const btn = document.getElementById('btn-submit-password');
        if (btn) btn.click();
      }
    });
  }

  const saveGuideBtn = document.getElementById('save-guide');
  if (saveGuideBtn) {
    saveGuideBtn.addEventListener('click', saveGuide);
  }

  // ===== GPT PRO 패스워드 =====
  const btnSubmitGptProPassword = document.getElementById('btn-submit-gpt-pro-password');
  if (btnSubmitGptProPassword) {
    btnSubmitGptProPassword.addEventListener('click', () => {
      const input = document.getElementById('gpt-pro-password-input');
      if (input && input.value === GPT_PRO_PASSWORD) {
        gptProUnlocked = true;
        const modal = document.getElementById('modal-gpt-pro-password');
        if (modal) modal.classList.remove('show');

        // 패스워드 확인 후 GPT PRO 실행
        executeGptPro();
      } else {
        alert('❌ 패스워드가 틀렸습니다.');
        if (input) input.value = '';
      }
    });
  }

  const btnCancelGptProPassword = document.getElementById('btn-cancel-gpt-pro-password');
  if (btnCancelGptProPassword) {
    btnCancelGptProPassword.addEventListener('click', () => {
      const modal = document.getElementById('modal-gpt-pro-password');
      if (modal) modal.classList.remove('show');
    });
  }

  const gptProPasswordInput = document.getElementById('gpt-pro-password-input');
  if (gptProPasswordInput) {
    gptProPasswordInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const btn = document.getElementById('btn-submit-gpt-pro-password');
        if (btn) btn.click();
      }
    });
  }

  // ===== 카테고리 관리 =====
  function renderCategoryManageList() {
    const list = document.getElementById('categories-list');
    if (!list) return;

    if (config.categories.length === 0) {
      list.innerHTML = '<p style="color: #999; font-size: .8rem; text-align: center; padding: .5rem;">카테고리를 추가하세요.</p>';
      return;
    }

    list.innerHTML = config.categories.map((cat, idx) => `
      <div class="storage-item">
        <div>
          <div style="font-weight: 600;">${cat.label}</div>
          <div style="font-size: .75rem; color: #666;">${cat.value}</div>
        </div>
        <div>
          <button onclick="editCategory(${idx})" style="margin-right: .3rem;">이름 수정</button>
          ${config.categories.length > 1 ? `<button class="danger" onclick="deleteCategory(${idx})">삭제</button>` : ''}
        </div>
      </div>
    `).join('');
  }

  const btnManageCategories = document.getElementById('btn-manage-categories');
  if (btnManageCategories) {
    btnManageCategories.addEventListener('click', () => {
      renderCategoryManageList();
      const modal = document.getElementById('modal-categories');
      if (modal) modal.classList.add('show');
    });
  }

  const btnCloseCategories = document.getElementById('btn-close-categories');
  if (btnCloseCategories) {
    btnCloseCategories.addEventListener('click', () => {
      const modal = document.getElementById('modal-categories');
      if (modal) modal.classList.remove('show');
    });
  }

  const btnAddCategory = document.getElementById('btn-add-category');
  if (btnAddCategory) {
    btnAddCategory.addEventListener('click', async () => {
      const input = document.getElementById('new-cat-label');
      if (!input) return;

      const label = input.value.trim();

      if (!label) {
        alert('표시 이름을 입력하세요.');
        return;
      }

      const value = koreanToId(label);

      if (config.categories.find(c => c.value === value)) {
        alert('이미 존재하는 카테고리입니다.');
        return;
      }

      config.categories.push({value, label});
      config.categorySettings[value] = {
        masterGuide: "",
        styles: []
      };

      await saveConfig();
      renderCategories();
      renderCategoryManageList();
      input.value = '';
    });
  }

  window.editCategory = async function(idx) {
    const current = config.categories[idx];
    if (!current) return;

    const newLabel = prompt('새 영상 시간 이름을 입력하세요.', current.label);
    if (newLabel === null) return;

    const trimmed = newLabel.trim();
    if (!trimmed) {
      alert('표시 이름을 입력하세요.');
      return;
    }

    current.label = trimmed;
    await saveConfig();
    renderCategories();
    renderCategoryManageList();
    if (current.value === currentCategory) {
      loadMasterGuide(currentCategory);
      renderProcessingSteps();
      renderResultBoxes();
      renderGuideTabs();
    }
  };

  window.deleteCategory = async function(idx) {
    if (!confirm(`"${config.categories[idx].label}" 삭제?`)) return;
    const value = config.categories[idx].value;
    config.categories.splice(idx, 1);
    delete config.categorySettings[value];
    await saveConfig();
    renderCategories();
    renderCategoryManageList();
    loadMasterGuide(currentCategory);
    renderProcessingSteps();
    renderResultBoxes();
    renderGuideTabs();
  };

  // ===== 처리 단계 관리 버튼 =====
  const btnManageSteps = document.getElementById('btn-manage-steps');
  if (btnManageSteps) {
    btnManageSteps.addEventListener('click', () => {
      const styleLabel = document.getElementById('modal-steps-style');
      if (styleLabel) styleLabel.textContent = '통합 처리 단계';

      renderStepsManageList();

      const stepsModal = document.getElementById('modal-steps');
      if (stepsModal) stepsModal.classList.add('show');
    });
  }

  // Style management removed - using main character text input instead

  function renderStepsManageList() {
    const list = document.getElementById('steps-list');
    if (!list) return;

    if (!config.unifiedSteps) config.unifiedSteps = [];
    config.unifiedSteps.sort((a, b) => a.order - b.order);

    if (config.unifiedSteps.length === 0) {
      list.innerHTML = '<p style="color: #999; font-size: .8rem; text-align: center; padding: .5rem;">단계를 추가하세요.</p>';
      return;
    }

    list.innerHTML = config.unifiedSteps.map((step, idx) => `
      <div class="storage-item">
        <span>${step.order}. ${step.name}</span>
        <div>
          ${idx > 0 ? `<button onclick="moveStep(${idx}, -1)" style="margin-right: .3rem;">↑</button>` : ''}
          ${idx < config.unifiedSteps.length - 1 ? `<button onclick="moveStep(${idx}, 1)" style="margin-right: .3rem;">↓</button>` : ''}
          <button onclick="renameStep(${idx})" style="margin-right: .3rem;">이름 수정</button>
          <button class="danger" onclick="deleteStep(${idx})">삭제</button>
        </div>
      </div>
    `).join('');
  }

  const btnCloseSteps = document.getElementById('btn-close-steps');
  if (btnCloseSteps) {
    btnCloseSteps.addEventListener('click', () => {
      const modal = document.getElementById('modal-steps');
      if (modal) modal.classList.remove('show');
    });
  }

  const btnAddStep = document.getElementById('btn-add-step');
  if (btnAddStep) {
    btnAddStep.addEventListener('click', async () => {
      const input = document.getElementById('new-step-name');
      if (!input) return;

      const name = input.value.trim();

      if (!name) {
        alert('단계 이름을 입력하세요.');
        return;
      }

      if (!config.unifiedSteps) config.unifiedSteps = [];

      const id = koreanToId(name);
      const maxOrder = config.unifiedSteps.length > 0 ? Math.max(...config.unifiedSteps.map(s => s.order)) : 0;

      config.unifiedSteps.push({
        id: id,
        name: name,
        order: maxOrder + 1
      });

      await saveConfig();
      renderProcessingSteps();
      renderResultBoxes();
      renderGuideTabs();
      renderStepsManageList();
      input.value = '';
    });
  }

  window.moveStep = async function(idx, direction) {
    if (!config.unifiedSteps) return;

    const steps = config.unifiedSteps;
    const targetIdx = idx + direction;

    if (targetIdx < 0 || targetIdx >= steps.length) return;

    [steps[idx].order, steps[targetIdx].order] = [steps[targetIdx].order, steps[idx].order];

    await saveConfig();
    renderProcessingSteps();
    renderResultBoxes();
    renderGuideTabs();
    renderStepsManageList();
  };

  window.deleteStep = async function(idx) {
    if (!config.unifiedSteps) return;

    if (!confirm(`"${config.unifiedSteps[idx].name}" 삭제?`)) return;

    config.unifiedSteps.splice(idx, 1);
    await saveConfig();
    renderProcessingSteps();
    renderResultBoxes();
    renderGuideTabs();
    renderStepsManageList();
  };

  window.renameStep = async function(idx) {
    if (!config.unifiedSteps) return;

    const step = config.unifiedSteps[idx];
    if (!step) return;

    const newName = prompt('새 단계 이름을 입력하세요.', step.name);
    if (newName === null) return;

    const trimmed = newName.trim();
    if (!trimmed) {
      alert('단계 이름을 입력하세요.');
      return;
    }

    step.name = trimmed;
    await saveConfig();
    renderProcessingSteps();
    renderResultBoxes();
    renderGuideTabs();
    renderStepsManageList();
  };

  // ===== 저장/불러오기 =====
  const btnSave = document.getElementById('btn-save');
  if (btnSave) {
    btnSave.addEventListener('click', () => {
      const saved = JSON.parse(localStorage.getItem('drama-saved') || '[]');
      const mainCharacter = document.getElementById('main-character').value.trim();

      saved.push({
        date: document.getElementById('drama-date').value,
        category: currentCategory,
        mainCharacter: mainCharacter,
        benchmarkScript: document.getElementById('benchmark-script').value,
        results: stepResults,
        savedAt: new Date().toISOString()
      });

      localStorage.setItem('drama-saved', JSON.stringify(saved));
      renderSavedList();
      alert('✅ 저장되었습니다!');
    });
  }

  function renderSavedList() {
    const saved = JSON.parse(localStorage.getItem('drama-saved') || '[]');
    const list = document.getElementById('saved-list');

    if (!list) return;

    if (saved.length === 0) {
      list.innerHTML = '<p style="color: #999; font-size: .8rem; text-align: center; padding: .5rem;">저장된 자료가 없습니다.</p>';
      return;
    }

    list.innerHTML = saved.map((item, idx) => {
      const catLabel = getCategoryLabel(item.category);
      const mainChar = item.mainCharacter || '주인공 미지정';
      const display = `${item.date} - ${catLabel} - ${mainChar}`;

      return `
        <div class="storage-item">
          <span style="font-size: .85rem;">${display}</span>
          <div>
            <button onclick="loadSaved(${idx})" style="margin-right: .3rem;">불러오기</button>
            <button onclick="deleteSaved(${idx})">삭제</button>
          </div>
        </div>
      `;
    }).join('');
  }

  window.loadSaved = function(idx) {
    const saved = JSON.parse(localStorage.getItem('drama-saved') || '[]');
    const item = saved[idx];

    document.getElementById('drama-date').value = item.date || '';
    document.getElementById('drama-category').value = item.category || '10min';
    document.getElementById('benchmark-script').value = item.benchmarkScript || '';
    document.getElementById('main-character').value = item.mainCharacter || '';

    currentCategory = item.category || '10min';
    stepResults = item.results || {};

    renderProcessingSteps();
    renderResultBoxes();
    renderGuideTabs();

    document.querySelectorAll('textarea').forEach(autoResize);
  };

  window.deleteSaved = function(idx) {
    if (!confirm('삭제하시겠습니까?')) return;
    const saved = JSON.parse(localStorage.getItem('drama-saved') || '[]');
    saved.splice(idx, 1);
    localStorage.setItem('drama-saved', JSON.stringify(saved));
    renderSavedList();
  };

  // ===== textarea 자동 높이 =====
  document.querySelectorAll('textarea.autosize').forEach(textarea => {
    textarea.addEventListener('input', () => autoResize(textarea));
  });

  // ===== 랜덤 주인공 생성 =====
  const btnRandomCharacter = document.getElementById('btn-random-character');
  if (btnRandomCharacter) {
    btnRandomCharacter.addEventListener('click', () => {
      const characters = [
        '30대 남성 목사',
        '20대 여성 대학생',
        '40대 남성 사업가',
        '50대 여성 주부',
        '청년 전도사',
        '중년 남성 교사',
        '20대 남성 청년',
        '30대 여성 직장인',
        '고등학생 남자',
        '고등학생 여자',
        '60대 노부부',
        '젊은 부부',
        '이혼한 중년 여성',
        '홀어머니와 아들',
        '아버지와 딸'
      ];
      const random = characters[Math.floor(Math.random() * characters.length)];
      document.getElementById('main-character').value = random;
    });
  }

  // ===== 벤치마킹 분석 기능 =====
  const btnAnalyzeBenchmark = document.getElementById('btn-analyze-benchmark');
  if (btnAnalyzeBenchmark) {
    btnAnalyzeBenchmark.addEventListener('click', async () => {
      const benchmarkScript = document.getElementById('benchmark-script').value.trim();
      const uploadDate = document.getElementById('benchmark-upload-date').value.trim();
      const viewCount = document.getElementById('benchmark-view-count').value.trim();
      const analysisResult = document.getElementById('analysis-result');

      if (!benchmarkScript) {
        alert('벤치마킹 대본을 먼저 입력해주세요.');
        return;
      }

      if (!uploadDate || !viewCount) {
        alert('업로드 날짜와 조회수를 입력해주세요.');
        return;
      }

      // 간단한 해시 생성 함수 (중복 체크용)
      const generateSimpleHash = (text) => {
        let hash = 0;
        for (let i = 0; i < text.length; i++) {
          const char = text.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash;
        }
        return hash.toString(36);
      };

      // 중복 자료 체크박스 상태 확인 (체크 시 분석만 수행, 저장 안 함)
      const isDuplicateData = document.getElementById('check-duplicates')?.checked || false;
      const scriptHash = isDuplicateData ? '' : generateSimpleHash(benchmarkScript);

      // 로딩 오버레이 표시
      showLoadingOverlay('벤치마크 대본 분석 중', 'AI가 대본을 분석하고 있습니다...');
      analysisResult.innerHTML = '<p style="color: #e74c3c; text-align: center;">🔄 분석 중...</p>';

      try {
        const response = await fetch('/api/drama/analyze-benchmark', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            benchmarkScript: benchmarkScript,
            uploadDate: uploadDate,
            viewCount: viewCount,
            category: currentCategory,
            videoCategory: selectedCategory || '간증',  // 영상 카테고리 추가
            scriptHash: scriptHash
          })
        });

        const data = await response.json();

        if (data.ok) {
          const statusMessage = data.isDuplicate
            ? '<strong style="color: #f39c12;">⚠️ 중복 대본 - 분석만 수행됨 (저장 안 됨)</strong>'
            : '<strong style="color: #e74c3c;">✅ 분석 완료 및 DB 저장됨</strong>';

          analysisResult.innerHTML = `
            <div style="margin-bottom: .75rem;">
              ${statusMessage}
            </div>
            <div style="white-space: pre-wrap; line-height: 1.8;">${data.analysis}</div>
          `;
        } else {
          analysisResult.innerHTML = `<p style="color: #e74c3c;">❌ 오류: ${data.error}</p>`;
        }
      } catch (err) {
        analysisResult.innerHTML = `<p style="color: #e74c3c;">❌ 네트워크 오류: ${err.message}</p>`;
      } finally {
        hideLoadingOverlay();
      }
    });
  }

  // ===== 워크플로우 박스 시스템 =====

  // 워크플로우 박스 추가
  function addWorkflowBox(stepType = 'step1') {
    const stepLabel = stepType === 'step1' ? 'Step1' : 'Step2';
    const stepNumber = stepType === 'step1' ? nextStep1BoxNum : nextStep2BoxNum;

    const box = {
      id: `box_${nextBoxId}`,
      boxNumber: nextBoxId,
      stepNumber: stepNumber,
      stepType: stepType,
      name: `${stepLabel} 작업 ${stepNumber}`,
      inputs: {
        benchmarkScript: false,
        aiAnalysis: false
      },
      guide: '',
      result: ''
    };

    workflowBoxes.push(box);
    nextBoxId++;

    if (stepType === 'step1') {
      nextStep1BoxNum++;
    } else {
      nextStep2BoxNum++;
    }

    renderWorkflowBoxes();
    saveWorkflowBoxes();
  }

  // 워크플로우 박스 삭제
  function deleteWorkflowBox(boxId) {
    const index = workflowBoxes.findIndex(b => b.id === boxId);
    if (index !== -1) {
      if (confirm(`"${workflowBoxes[index].name}" 박스를 삭제하시겠습니까?`)) {
        workflowBoxes.splice(index, 1);

        // Step별 박스 번호 재정렬
        const step1Boxes = workflowBoxes.filter(b => b.stepType === 'step1');
        const step2Boxes = workflowBoxes.filter(b => b.stepType === 'step2');

        step1Boxes.forEach((box, idx) => {
          box.stepNumber = idx + 1;
          box.name = `Step1 작업 ${idx + 1}`;
        });

        step2Boxes.forEach((box, idx) => {
          box.stepNumber = idx + 1;
          box.name = `Step2 작업 ${idx + 1}`;
        });

        // 다음 번호 업데이트
        nextStep1BoxNum = step1Boxes.length + 1;
        nextStep2BoxNum = step2Boxes.length + 1;

        renderWorkflowBoxes();
        saveWorkflowBoxes();
      }
    }
  }

  // 워크플로우 박스 렌더링
  function renderWorkflowBoxes() {
    const container = document.getElementById('workflow-boxes-container');
    if (!container) return;

    if (workflowBoxes.length === 0) {
      container.innerHTML = `
        <div class="box" style="padding: .75rem;">
          <div style="display: flex; gap: 1rem; align-items: flex-start;">
            <!-- 왼쪽: 시간 지정 -->
            <div style="flex: 0 0 140px;">
              <div style="font-weight: 700; font-size: .85rem; color: #4b5563; margin-bottom: .35rem; display: flex; align-items: center; gap: .3rem;">
                <span style="font-size: 1rem;">⏱️</span> 시간
              </div>
              <input
                type="text"
                id="custom-duration-input"
                value="${customDurationText}"
                placeholder="예: 2분"
                style="width: 100%; padding: .5rem .55rem; font-size: .85rem; border-radius: 8px; border: 1px solid #e5e7eb; background: #f9fafb;"
              />
            </div>
            <!-- 오른쪽: 카테고리 선택 -->
            <div style="flex: 1;">
              <div style="font-weight: 700; font-size: .85rem; color: #4b5563; margin-bottom: .35rem; display: flex; align-items: center; gap: .3rem;">
                <span style="font-size: 1rem;">🎬</span> 카테고리
              </div>
              <div id="category-toggle-container" style="display: flex; flex-wrap: wrap; gap: .4rem;">
                ${videoCategories.map(cat => `
                  <button
                    class="category-toggle-btn ${selectedCategory === cat ? 'active' : ''}"
                    data-category="${cat}"
                    style="padding: .45rem .7rem; font-size: .8rem; border-radius: 20px; border: 2px solid ${selectedCategory === cat ? '#6366f1' : '#e5e7eb'}; background: ${selectedCategory === cat ? 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)' : '#fff'}; color: ${selectedCategory === cat ? '#fff' : '#6b7280'}; cursor: pointer; font-weight: ${selectedCategory === cat ? '600' : '500'}; transition: all 0.2s ease; box-shadow: ${selectedCategory === cat ? '0 2px 8px rgba(99, 102, 241, 0.3)' : 'none'};"
                  >${cat}</button>
                `).join('')}
              </div>
            </div>
          </div>
          <!-- 사용자 지침 입력 (선택사항) -->
          <div style="margin-top: .75rem;">
            <div style="font-weight: 700; font-size: .85rem; color: #4b5563; margin-bottom: .35rem; display: flex; align-items: center; gap: .3rem;">
              <span style="font-size: 1rem;">📝</span> 지침 <span style="font-weight: 400; font-size: .75rem; color: #9ca3af;">(선택)</span>
            </div>
            <input
              type="text"
              id="custom-directive-input"
              value="${customDirective}"
              placeholder="예: 쇼팬하우어 명언, 부모님과의 갈등 이야기, 직장 스트레스 주제..."
              style="width: 100%; padding: .5rem .65rem; font-size: .85rem; border-radius: 8px; border: 1px solid #e5e7eb; background: #f9fafb;"
            />
            <div style="font-size: .7rem; color: #9ca3af; margin-top: .3rem;">
              구체적인 주제나 방향을 지시하면 해당 내용이 최우선으로 반영됩니다.
            </div>
          </div>
        </div>
      `;

      const durationInput = document.getElementById('custom-duration-input');
      if (durationInput) {
        durationInput.addEventListener('input', (e) => {
          customDurationText = e.target.value.trim();
          localStorage.setItem('_drama-duration-text', customDurationText);
          saveToFirebase('_drama-duration-text', customDurationText);
        });
      }

      // 사용자 지침 입력 이벤트
      const directiveInput = document.getElementById('custom-directive-input');
      if (directiveInput) {
        directiveInput.addEventListener('input', (e) => {
          customDirective = e.target.value.trim();
          localStorage.setItem('_drama-custom-directive', customDirective);
          saveToFirebase('_drama-custom-directive', customDirective);
        });
      }

      // 카테고리 토글 버튼 이벤트
      const categoryButtons = document.querySelectorAll('.category-toggle-btn');
      categoryButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          const cat = e.target.dataset.category;
          selectedCategory = cat;
          localStorage.setItem('_drama-video-category', cat);
          saveToFirebase('_drama-video-category', cat);
          renderWorkflowBoxes(); // UI 갱신
        });
      });
      return;
    }

    container.innerHTML = workflowBoxes.map((box, index) => {
      const stepType = box.stepType || 'step1';  // 기본값 step1
      const stepBadgeClass = stepType === 'step1' ? 'step1' : 'step2';
      const stepBadgeColor = stepType === 'step1' ? '#ff6b6b' : '#4ecdc4';
      const stepBadgeGradient = stepType === 'step1' ? 'linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%)' : 'linear-gradient(135deg, #4ecdc4 0%, #44a3c2 100%)';
      const stepBgColor = stepType === 'step1' ? '#fff5f5' : '#f0fdfc';
      const stepLabel = stepType === 'step1' ? 'Step1' : 'Step2';

      return `
      <div class="box workflow-box ${stepType}" id="workflow-box-${box.id}" draggable="true" data-box-index="${index}" style="margin-bottom: .5rem; border-left: 4px solid ${stepBadgeColor}; cursor: move;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .5rem;">
          <div style="display: flex; align-items: center; gap: .4rem; flex: 1;">
            <span style="cursor: grab; font-size: 1rem; color: #999; user-select: none;">⋮⋮</span>
            <span style="background: ${stepBadgeGradient}; color: white; padding: .25rem .5rem; border-radius: 6px; font-weight: 600; font-size: .75rem; box-shadow: 0 2px 4px rgba(0,0,0,.1);">${stepLabel} ${box.stepNumber || box.boxNumber}</span>
            <input type="text" value="${box.name}" onchange="updateBoxName('${box.id}', this.value)" style="font-weight: 600; font-size: .85rem; border: none; padding: .2rem .4rem; border-radius: 4px; background: #f8f9fa; flex: 1;" onclick="(function(e){e.stopPropagation();})(event)">
          </div>
          <div style="display: flex; gap: .3rem; align-items: center;">
            <button onclick="(function(e){executeWorkflowBox('${box.id}'); e.stopPropagation();})(event)" style="padding: .25rem .5rem; font-size: .75rem; background: ${stepBadgeGradient}; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">▶️</button>
            <button onclick="(function(e){copyBoxResult('${box.id}'); e.stopPropagation();})(event)" style="padding: .25rem .5rem; font-size: .75rem; background: white; border: 2px solid ${stepBadgeColor}; color: ${stepBadgeColor}; border-radius: 6px; cursor: pointer; font-weight: 600;">📋</button>
            ${index > 0 ? `<button onclick="(function(e){moveBoxUp(${index}); e.stopPropagation();})(event)" style="padding: .25rem .4rem; font-size: .75rem; border-radius: 4px; background: #f8f9fa; border: none; cursor: pointer;">▲</button>` : ''}
            ${index < workflowBoxes.length - 1 ? `<button onclick="(function(e){moveBoxDown(${index}); e.stopPropagation();})(event)" style="padding: .25rem .4rem; font-size: .75rem; border-radius: 4px; background: #f8f9fa; border: none; cursor: pointer;">▼</button>` : ''}
            <button onclick="deleteWorkflowBox('${box.id}')" class="danger" style="padding: .25rem .5rem; font-size: .75rem; border-radius: 6px;">🗑️</button>
          </div>
        </div>

        <div class="box-content" id="content-${box.id}" style="display: ${(stepType === 'step1' && step1Collapsed) || (stepType === 'step2' && step2Collapsed) ? 'none' : 'block'}">
        <!-- 입력 소스 선택 -->
        <div style="background: ${stepBgColor}; padding: .5rem; border-radius: 8px; margin-bottom: .5rem; border: 1px solid ${stepBadgeColor}20;">
          <div style="font-size: .75rem; font-weight: 600; margin-bottom: .4rem; color: #555;">📥 입력 소스</div>
          <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: .3rem;">
            <label style="display: flex; align-items: center; gap: .25rem; cursor: pointer; padding: .2rem; border-radius: 4px; transition: background 0.2s;">
              <input type="checkbox" ${box.inputs.benchmarkScript ? 'checked' : ''} onchange="updateBoxInput('${box.id}', 'benchmarkScript', this.checked)">
              <span style="font-size: .75rem;">벤치마킹 대본</span>
            </label>
            <label style="display: flex; align-items: center; gap: .25rem; cursor: pointer; padding: .2rem; border-radius: 4px; transition: background 0.2s;">
              <input type="checkbox" ${box.inputs.aiAnalysis ? 'checked' : ''} onchange="updateBoxInput('${box.id}', 'aiAnalysis', this.checked)">
              <span style="font-size: .75rem;">AI 분석</span>
            </label>
            ${workflowBoxes.slice(0, index).filter(b => b.stepType === stepType).map(otherBox => `
              <label style="display: flex; align-items: center; gap: .25rem; cursor: pointer; padding: .2rem; border-radius: 4px; transition: background 0.2s;">
                <input type="checkbox" ${box.inputs[`box_${otherBox.boxNumber}`] ? 'checked' : ''} onchange="updateBoxInput('${box.id}', 'box_${otherBox.boxNumber}', this.checked)">
                <span style="font-size: .75rem;">[${otherBox.stepNumber || otherBox.boxNumber}] ${otherBox.name}</span>
              </label>
            `).join('')}
          </div>
        </div>

        <!-- 결과 표시 -->
        <div style="background: ${stepBgColor}; padding: .5rem; border-radius: 8px; border: 1px solid ${stepBadgeColor}30;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: .3rem;">
            <div style="font-size: .75rem; font-weight: 600; color: ${stepBadgeColor};">📊 결과</div>
            <div id="token-info-${box.id}" style="font-size: .65rem; color: #888; display: ${box.usage ? 'flex' : 'none'}; gap: .5rem; align-items: center;">
              ${box.usage ? `
                <span>📥 ${box.usage.input_tokens?.toLocaleString() || 0}</span>
                <span>📤 ${box.usage.output_tokens?.toLocaleString() || 0}</span>
                <span style="color: ${stepBadgeColor}; font-weight: 600;">💰 ${(() => {
                  const cost = calculateCost(box.usage.model, box.usage.input_tokens || 0, box.usage.output_tokens || 0);
                  return cost ? '₩' + cost.totalCostKRW : '-';
                })()}</span>
              ` : ''}
            </div>
          </div>
          <textarea id="result-${box.id}" readonly style="width: 100%; min-height: 80px; font-size: .75rem; padding: .4rem; border: none; border-radius: 6px; background: white; box-shadow: inset 0 1px 3px rgba(0,0,0,.05); resize: vertical;" placeholder="실행 결과가 여기에 표시됩니다...">${box.result}</textarea>
        </div>
        </div>
      </div>
      `;
    }).join('');

    // 지침 관리 패널도 업데이트
    renderGuideManagement();

    // 드래그 앤 드롭 재설정
    setupDragAndDrop();
  }

  // Step별 지침 저장용 변수
  let step3Guide = localStorage.getItem('_drama-step3-guide') || '';
  let step4Guide = localStorage.getItem('_drama-step4-guide') || '';
  let step5Guide = localStorage.getItem('_drama-step5-guide') || '';
  let step6Guide = localStorage.getItem('_drama-step6-guide') || '';
  let step7Guide = localStorage.getItem('_drama-step7-guide') || '';

  // JSON 지침 (drama.json 스타일 가이드)
  let dramaJsonGuide = localStorage.getItem('_drama-json-guide') || '';

  // Step3 결과 저장용 변수
  let step3Result = localStorage.getItem('_drama-step3-result') || '';

  // AI 모델 설정 (기본값)
  let aiModelSettings = JSON.parse(localStorage.getItem('_drama-ai-models') || 'null') || {
    step1: 'gpt-4o-mini',
    step2: 'gpt-4o-mini',
    step3: 'anthropic/claude-sonnet-4.5',
    benchmarkAnalysis: 'gpt-4o-mini'
  };

  // 모델별 가격 정보 (1M 토큰당 USD) - 기준: gpt-4o (평균)
  const modelPricing = {
    // OpenAI 모델 (기준: gpt-4o = 0%)
    'gpt-4o-mini': { input: 0.15, output: 0.60, diff: -94 },      // 매우 저렴
    'gpt-4o': { input: 2.50, output: 10.00, diff: 0 },            // 기준 (평균)
    'gpt-4.5-preview': { input: 75.00, output: 150.00, diff: +2900 }, // 프리미엄
    'gpt-5': { input: 5.00, output: 20.00, diff: +100 },          // 고품질
    'gpt-5.1': { input: 7.50, output: 30.00, diff: +200 },        // 최신
    // OpenRouter 모델 (기준: claude-sonnet-4.5 = 0%)
    'anthropic/claude-sonnet-4.5': { input: 3.00, output: 15.00, diff: 0 },  // Sonnet 4.5 (기준)
    'anthropic/claude-sonnet-4': { input: 3.00, output: 15.00, diff: 0 },       // Sonnet 4
    'anthropic/claude-3.5-sonnet': { input: 3.00, output: 15.00, diff: 0 },     // 3.5 Sonnet
    'anthropic/claude-3-opus': { input: 15.00, output: 75.00, diff: +400 },     // 최고 품질
    'anthropic/claude-3-haiku': { input: 0.25, output: 1.25, diff: -92 },       // 저렴
    'google/gemini-pro-1.5': { input: 1.25, output: 5.00, diff: -58 },          // 중저가
    'meta-llama/llama-3.1-70b-instruct': { input: 0.52, output: 0.75, diff: -83 } // 저렴
  };

  // 비용 계산 함수
  function calculateCost(modelId, inputTokens, outputTokens) {
    const pricing = modelPricing[modelId];
    if (!pricing) return null;
    const inputCost = (inputTokens / 1000000) * pricing.input;
    const outputCost = (outputTokens / 1000000) * pricing.output;
    return {
      inputCost: inputCost.toFixed(6),
      outputCost: outputCost.toFixed(6),
      totalCost: (inputCost + outputCost).toFixed(6),
      totalCostKRW: ((inputCost + outputCost) * 1400).toFixed(2) // 원화 환산 (대략)
    };
  }

  // 사용 가능한 모델 목록 - 가격 차이 % 포함
  const availableModels = {
    openai: [
      { id: 'gpt-4o-mini', name: 'GPT-4o Mini (-94% 저렴)' },
      { id: 'gpt-4o', name: 'GPT-4o (기준, 평균)' },
      { id: 'gpt-5', name: 'GPT-5 (+100% 고품질)' },
      { id: 'gpt-5.1', name: 'GPT-5.1 (+200% 최신)' },
      { id: 'gpt-4.5-preview', name: 'GPT-4.5 Preview (+2900% 프리미엄)' }
    ],
    openrouter: [
      { id: 'anthropic/claude-sonnet-4.5', name: 'Claude Sonnet 4.5 (기준, 추천)' },
      { id: 'anthropic/claude-sonnet-4', name: 'Claude Sonnet 4 (동일가격)' },
      { id: 'anthropic/claude-3.5-sonnet', name: 'Claude 3.5 Sonnet (동일가격)' },
      { id: 'anthropic/claude-3-opus', name: 'Claude 3 Opus (+400% 최고품질)' },
      { id: 'anthropic/claude-3-haiku', name: 'Claude 3 Haiku (-92% 저렴)' },
      { id: 'google/gemini-pro-1.5', name: 'Gemini Pro 1.5 (-58%)' },
      { id: 'meta-llama/llama-3.1-70b-instruct', name: 'Llama 3.1 70B (-83% 저렴)' }
    ]
  };

  // 지침 관리 모달 렌더링 (Step1, Step2, Step3 + AI 모델 설정)
  function renderGuideManagement() {
    const container = document.getElementById('modal-guide-container');
    if (!container) return;

    let html = '';

    // ===== AI 모델 설정 섹션 =====
    html += `<div style="margin-bottom: 1.5rem;">
      <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: .5rem 1rem; border-radius: 8px 8px 0 0; font-weight: 700; font-size: 1rem;">🤖 AI 모델 설정</div>
      <div style="background: #f8f5ff; padding: 1rem; border-radius: 0 0 8px 8px; border: 2px solid #667eea; border-top: none;">
        <div style="font-size: .85rem; color: #666; margin-bottom: 1rem;">
          각 기능에서 사용할 AI 모델을 선택하세요. 변경 후 저장 버튼을 눌러주세요.
        </div>
        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 1rem;">

          <!-- 벤치마킹 분석 모델 (첫 번째) -->
          <div style="background: white; padding: .75rem; border-radius: 8px; border: 1px solid #e0e0e0;">
            <label style="font-weight: 600; font-size: .85rem; color: #667eea; display: block; margin-bottom: .4rem;">📊 벤치마킹 분석</label>
            <select id="model-benchmark" style="width: 100%; padding: .4rem; border-radius: 4px; border: 1px solid #ddd; font-size: .85rem;">
              ${availableModels.openai.map(m => `<option value="${m.id}" ${aiModelSettings.benchmarkAnalysis === m.id ? 'selected' : ''}>${m.name}</option>`).join('')}
            </select>
          </div>

          <!-- Step1 모델 -->
          <div style="background: white; padding: .75rem; border-radius: 8px; border: 1px solid #e0e0e0;">
            <label style="font-weight: 600; font-size: .85rem; color: #ff6b6b; display: block; margin-bottom: .4rem;">Step1 (벤치마킹 대본 분석)</label>
            <select id="model-step1" style="width: 100%; padding: .4rem; border-radius: 4px; border: 1px solid #ddd; font-size: .85rem;">
              ${availableModels.openai.map(m => `<option value="${m.id}" ${aiModelSettings.step1 === m.id ? 'selected' : ''}>${m.name}</option>`).join('')}
            </select>
          </div>

          <!-- Step2 모델 -->
          <div style="background: white; padding: .75rem; border-radius: 8px; border: 1px solid #e0e0e0;">
            <label style="font-weight: 600; font-size: .85rem; color: #4ecdc4; display: block; margin-bottom: .4rem;">Step2 (새 대본 제작)</label>
            <select id="model-step2" style="width: 100%; padding: .4rem; border-radius: 4px; border: 1px solid #ddd; font-size: .85rem;">
              ${availableModels.openai.map(m => `<option value="${m.id}" ${aiModelSettings.step2 === m.id ? 'selected' : ''}>${m.name}</option>`).join('')}
            </select>
          </div>

          <!-- Step3 모델 (OpenRouter) -->
          <div style="background: white; padding: .75rem; border-radius: 8px; border: 1px solid #e0e0e0;">
            <label style="font-weight: 600; font-size: .85rem; color: #f39c12; display: block; margin-bottom: .4rem;">Step3 (OpenRouter 최종 대본)</label>
            <select id="model-step3" style="width: 100%; padding: .4rem; border-radius: 4px; border: 1px solid #ddd; font-size: .85rem;">
              ${availableModels.openrouter.map(m => `<option value="${m.id}" ${aiModelSettings.step3 === m.id ? 'selected' : ''}>${m.name}</option>`).join('')}
            </select>
          </div>

        </div>
      </div>
    </div>`;

    // Step1 박스들
    const step1Boxes = workflowBoxes.filter(b => (b.stepType || 'step1') === 'step1');
    if (step1Boxes.length > 0) {
      html += `<div style="margin-bottom: 1.5rem;">
        <div style="background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%); color: white; padding: .5rem 1rem; border-radius: 8px 8px 0 0; font-weight: 700; font-size: 1rem;">📋 Step1 지침 (벤치마킹 분석)</div>
        <div style="background: #fff5f5; padding: 1rem; border-radius: 0 0 8px 8px; border: 2px solid #ff6b6b; border-top: none;">`;

      step1Boxes.forEach(box => {
        html += `
          <div style="margin-bottom: 1rem;">
            <div style="font-weight: 600; font-size: .9rem; color: #333; margin-bottom: .4rem;">${box.stepNumber || box.boxNumber}. ${box.name}</div>
            <textarea
              id="modal-guide-${box.id}"
              onchange="updateBoxGuide('${box.id}', this.value)"
              style="width: 100%; min-height: 80px; font-size: .85rem; padding: .6rem; border: 1px solid #ffcdd2; border-radius: 6px; font-family: inherit; resize: vertical;"
              placeholder="이 작업의 구체적인 지침을 입력하세요...">${box.guide || ''}</textarea>
          </div>`;
      });
      html += `</div></div>`;
    }

    // Step2 박스들
    const step2Boxes = workflowBoxes.filter(b => b.stepType === 'step2');
    if (step2Boxes.length > 0) {
      html += `<div style="margin-bottom: 1.5rem;">
        <div style="background: linear-gradient(135deg, #4ecdc4 0%, #44a3c2 100%); color: white; padding: .5rem 1rem; border-radius: 8px 8px 0 0; font-weight: 700; font-size: 1rem;">📋 Step2 지침 (새 대본 제작)</div>
        <div style="background: #f0fdfc; padding: 1rem; border-radius: 0 0 8px 8px; border: 2px solid #4ecdc4; border-top: none;">`;

      step2Boxes.forEach(box => {
        html += `
          <div style="margin-bottom: 1rem;">
            <div style="font-weight: 600; font-size: .9rem; color: #333; margin-bottom: .4rem;">${box.stepNumber || box.boxNumber}. ${box.name}</div>
            <textarea
              id="modal-guide-${box.id}"
              onchange="updateBoxGuide('${box.id}', this.value)"
              style="width: 100%; min-height: 80px; font-size: .85rem; padding: .6rem; border: 1px solid #b2dfdb; border-radius: 6px; font-family: inherit; resize: vertical;"
              placeholder="이 작업의 구체적인 지침을 입력하세요...">${box.guide || ''}</textarea>
          </div>`;
      });
      html += `</div></div>`;
    }

    // Step3 지침 (OpenRouter 대본 완성)
    html += `<div style="margin-bottom: 1rem;">
      <div style="background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: white; padding: .5rem 1rem; border-radius: 8px 8px 0 0; font-weight: 700; font-size: 1rem;">🎬 Step3 지침 (OpenRouter 대본 완성)</div>
      <div style="background: #fffbf0; padding: 1rem; border-radius: 0 0 8px 8px; border: 2px solid #f39c12; border-top: none;">
        <div style="font-size: .85rem; color: #666; margin-bottom: .5rem;">
          OpenRouter AI가 최종 대본을 작성할 때 참고할 지침입니다.
        </div>
        <textarea
          id="modal-guide-step3"
          style="width: 100%; min-height: 120px; font-size: .85rem; padding: .6rem; border: 1px solid #ffe0b2; border-radius: 6px; font-family: inherit; resize: vertical;"
          placeholder="예: 대사는 자연스럽게, 장면 전환은 부드럽게, 감정선을 강조해서 작성해주세요...">${step3Guide}</textarea>
      </div>
    </div>`;

    // Step4 지침 (이미지 생성)
    html += `<div style="margin-bottom: 1rem;">
      <div style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); color: white; padding: .5rem 1rem; border-radius: 8px 8px 0 0; font-weight: 700; font-size: 1rem;">🖼️ Step4 지침 (이미지 생성)</div>
      <div style="background: #faf5ff; padding: 1rem; border-radius: 0 0 8px 8px; border: 2px solid #9b59b6; border-top: none;">
        <div style="font-size: .85rem; color: #666; margin-bottom: .5rem;">
          이미지 생성 시 참고할 스타일, 분위기, 구도 등의 지침입니다.
        </div>
        <textarea
          id="modal-guide-step4"
          style="width: 100%; min-height: 100px; font-size: .85rem; padding: .6rem; border: 1px solid #d4a8e8; border-radius: 6px; font-family: inherit; resize: vertical;"
          placeholder="예: 따뜻한 색감, 한국적 분위기, 인물 중심 구도, 실사 스타일...">${step4Guide}</textarea>
      </div>
    </div>`;

    // Step5 지침 (음성 합성)
    html += `<div style="margin-bottom: 1rem;">
      <div style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; padding: .5rem 1rem; border-radius: 8px 8px 0 0; font-weight: 700; font-size: 1rem;">🔊 Step5 지침 (음성 합성)</div>
      <div style="background: #f0f8ff; padding: 1rem; border-radius: 0 0 8px 8px; border: 2px solid #3498db; border-top: none;">
        <div style="font-size: .85rem; color: #666; margin-bottom: .5rem;">
          TTS 음성 생성 시 참고할 톤, 속도, 감정 표현 등의 지침입니다.
        </div>
        <textarea
          id="modal-guide-step5"
          style="width: 100%; min-height: 100px; font-size: .85rem; padding: .6rem; border: 1px solid #a8d4f0; border-radius: 6px; font-family: inherit; resize: vertical;"
          placeholder="예: 차분하고 따뜻한 톤, 감정 부분은 천천히, 대화는 자연스럽게...">${step5Guide}</textarea>
      </div>
    </div>`;

    // Step6 지침 (영상 편집)
    html += `<div style="margin-bottom: 1rem;">
      <div style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white; padding: .5rem 1rem; border-radius: 8px 8px 0 0; font-weight: 700; font-size: 1rem;">🎥 Step6 지침 (영상 편집)</div>
      <div style="background: #fff5f5; padding: 1rem; border-radius: 0 0 8px 8px; border: 2px solid #e74c3c; border-top: none;">
        <div style="font-size: .85rem; color: #666; margin-bottom: .5rem;">
          영상 편집 시 참고할 전환 효과, 자막 스타일, BGM 등의 지침입니다.
        </div>
        <textarea
          id="modal-guide-step6"
          style="width: 100%; min-height: 100px; font-size: .85rem; padding: .6rem; border: 1px solid #f0a8a8; border-radius: 6px; font-family: inherit; resize: vertical;"
          placeholder="예: 부드러운 페이드 전환, 자막은 하단 중앙, 잔잔한 피아노 BGM...">${step6Guide}</textarea>
      </div>
    </div>`;

    // Step7 지침 (업로드)
    html += `<div style="margin-bottom: 1rem;">
      <div style="background: linear-gradient(135deg, #1abc9c 0%, #16a085 100%); color: white; padding: .5rem 1rem; border-radius: 8px 8px 0 0; font-weight: 700; font-size: 1rem;">📤 Step7 지침 (업로드)</div>
      <div style="background: #f0fffc; padding: 1rem; border-radius: 0 0 8px 8px; border: 2px solid #1abc9c; border-top: none;">
        <div style="font-size: .85rem; color: #666; margin-bottom: .5rem;">
          YouTube 업로드 시 참고할 제목 형식, 설명, 태그 등의 지침입니다.
        </div>
        <textarea
          id="modal-guide-step7"
          style="width: 100%; min-height: 100px; font-size: .85rem; padding: .6rem; border: 1px solid #a8e8d8; border-radius: 6px; font-family: inherit; resize: vertical;"
          placeholder="예: 제목에 '감동 실화' 포함, 설명에 타임스탬프 추가, 기독교/간증 태그...">${step7Guide}</textarea>
      </div>
    </div>`;

    // JSON 지침 편집기 (drama.json 스타일 가이드)
    html += `<div style="margin-bottom: 1rem;">
      <div style="background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%); color: white; padding: .5rem 1rem; border-radius: 8px 8px 0 0; font-weight: 700; font-size: 1rem; display: flex; justify-content: space-between; align-items: center;">
        <span>📋 JSON 지침 (스타일 가이드)</span>
        <div style="display: flex; gap: .5rem;">
          <button onclick="loadDefaultJsonGuide()" style="padding: .25rem .5rem; font-size: .75rem; background: rgba(255,255,255,0.2); color: white; border: none; border-radius: 4px; cursor: pointer;">기본값 불러오기</button>
          <button onclick="validateJsonGuide()" style="padding: .25rem .5rem; font-size: .75rem; background: rgba(39,174,96,0.8); color: white; border: none; border-radius: 4px; cursor: pointer;">JSON 검증</button>
        </div>
      </div>
      <div style="background: #f8f9fa; padding: 1rem; border-radius: 0 0 8px 8px; border: 2px solid #2c3e50; border-top: none;">
        <div style="font-size: .85rem; color: #666; margin-bottom: .5rem;">
          대본 생성에 사용할 JSON 형식의 상세 스타일 가이드입니다. 구조, 대화 비율, 필수 요소 등을 정의합니다.
        </div>
        <textarea
          id="modal-guide-json"
          style="width: 100%; min-height: 300px; font-size: .8rem; padding: .6rem; border: 1px solid #bdc3c7; border-radius: 6px; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; resize: vertical; line-height: 1.4;"
          placeholder='{"version": "2.0", "script_style": {...}, "structure": {...}}'>${escapeHtml(dramaJsonGuide)}</textarea>
        <div id="json-validation-result" style="margin-top: .5rem; font-size: .8rem; display: none;"></div>
      </div>
    </div>`;

    if (workflowBoxes.length === 0) {
      html = `<p style="color: #999; text-align: center; padding: 1rem;">작업 박스를 추가하면 Step1/Step2 지침이 표시됩니다.</p>` + html;
    }

    container.innerHTML = html;
  }

  // HTML 이스케이프 함수
  function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // 기본 JSON 가이드 불러오기
  async function loadDefaultJsonGuide() {
    try {
      const response = await fetch('/api/drama/guidelines');
      if (response.ok) {
        const data = await response.json();
        if (data.ok && data.guidelines) {
          const jsonStr = JSON.stringify(data.guidelines, null, 2);
          document.getElementById('modal-guide-json').value = jsonStr;
          showStatus('✅ 기본 JSON 지침을 불러왔습니다.');
        }
      }
    } catch (err) {
      alert('기본 지침 불러오기 실패: ' + err.message);
    }
  }

  // JSON 유효성 검증
  function validateJsonGuide() {
    const textarea = document.getElementById('modal-guide-json');
    const resultDiv = document.getElementById('json-validation-result');
    if (!textarea || !resultDiv) return;

    const jsonText = textarea.value.trim();
    resultDiv.style.display = 'block';

    if (!jsonText) {
      resultDiv.innerHTML = '<span style="color: #666;">JSON 내용이 비어있습니다.</span>';
      return;
    }

    try {
      const parsed = JSON.parse(jsonText);
      const hasVersion = parsed.version ? '✓' : '✗';
      const hasStructure = parsed.structure ? '✓' : '✗';
      const hasScriptStyle = parsed.script_style ? '✓' : '✗';
      resultDiv.innerHTML = `<span style="color: #27ae60;">✅ 유효한 JSON입니다.</span> <span style="color: #666; font-size: .75rem;">(version: ${hasVersion}, structure: ${hasStructure}, script_style: ${hasScriptStyle})</span>`;
    } catch (err) {
      resultDiv.innerHTML = `<span style="color: #e74c3c;">❌ JSON 오류: ${err.message}</span>`;
    }
  }

  // 박스 이름 업데이트
  window.updateBoxName = function(boxId, newName) {
    const box = workflowBoxes.find(b => b.id === boxId);
    if (box) {
      box.name = newName;
      saveWorkflowBoxes();
      renderWorkflowBoxes();
    }
  };

  // 입력 소스 업데이트
  window.updateBoxInput = function(boxId, inputKey, checked) {
    const box = workflowBoxes.find(b => b.id === boxId);
    if (box) {
      box.inputs[inputKey] = checked;
      saveWorkflowBoxes();
    }
  };

  // 지침 업데이트 (onChange는 메모리에만 저장, 실제 저장은 저장 버튼 클릭 시)
  window.updateBoxGuide = function(boxId, guide) {
    const box = workflowBoxes.find(b => b.id === boxId);
    if (box) {
      box.guide = guide;
      // 다른 텍스트영역도 동기화 (패널과 박스 양쪽)
      const panelTextarea = document.getElementById(`guide-panel-${boxId}`);
      if (panelTextarea && panelTextarea.value !== guide) {
        panelTextarea.value = guide;
      }
    }
  };

  // 워크플로우 박스 실행
  window.executeWorkflowBox = async function(boxId) {
    const box = workflowBoxes.find(b => b.id === boxId);
    if (!box) return;

    // 로딩 오버레이 표시
    showLoadingOverlay(`[${box.boxNumber}] ${box.name} 처리 중`, 'AI가 작업을 수행하고 있습니다...');

    // 입력 데이터 수집
    let inputData = {};

    if (box.inputs.benchmarkScript) {
      inputData.benchmarkScript = document.getElementById('benchmark-script').value;
    }

    if (box.inputs.aiAnalysis) {
      inputData.aiAnalysis = document.getElementById('analysis-result').innerText;
    }

    // 다른 박스의 결과 수집
    for (const [key, value] of Object.entries(box.inputs)) {
      if (key.startsWith('box_') && value) {
        const boxNumber = parseInt(key.replace('box_', ''));
        const sourceBox = workflowBoxes.find(b => b.boxNumber === boxNumber);
        if (sourceBox && sourceBox.result) {
          inputData[`box${boxNumber}Result`] = sourceBox.result;
        }
      }
    }

    // 주인공 정보 수집
    const mainCharacter = document.getElementById('main-character')?.value.trim() || '';

    // stepType에 따라 적절한 모델 선택
    const stepType = box.stepType || 'step1';
    const modelToUse = stepType === 'step1' ? aiModelSettings.step1 : aiModelSettings.step2;

    try {
      const response = await fetch('/api/drama/workflow-execute', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          boxId: box.id,
          boxName: box.name,
          boxNumber: box.boxNumber,
          stepType: stepType,
          guide: box.guide,
          inputs: inputData,
          category: currentCategory,
          mainCharacter: mainCharacter,
          model: modelToUse
        })
      });

      const data = await response.json();

      if (data.ok) {
        box.result = data.result;
        box.usage = data.usage;  // 토큰 사용량 저장
        document.getElementById(`result-${box.id}`).value = data.result;

        // 토큰 정보 업데이트
        const tokenInfoDiv = document.getElementById(`token-info-${box.id}`);
        if (tokenInfoDiv && data.usage) {
          const cost = calculateCost(data.usage.model, data.usage.input_tokens || 0, data.usage.output_tokens || 0);
          tokenInfoDiv.innerHTML = `
            <span>📥 ${(data.usage.input_tokens || 0).toLocaleString()}</span>
            <span>📤 ${(data.usage.output_tokens || 0).toLocaleString()}</span>
            <span style="color: inherit; font-weight: 600;">💰 ${cost ? '₩' + cost.totalCostKRW : '-'}</span>
          `;
          tokenInfoDiv.style.display = 'flex';
        }

        saveWorkflowBoxes();
        showStatus('✅ 완료!');
        setTimeout(hideStatus, 2000);
      } else {
        alert(`오류: ${data.error}`);
      }
    } catch (err) {
      alert(`네트워크 오류: ${err.message}`);
    } finally {
      hideLoadingOverlay();
    }
  };

  // 박스 결과 복사
  window.copyBoxResult = function(boxId) {
    const textarea = document.getElementById(`result-${boxId}`);
    if (textarea && textarea.value) {
      textarea.select();
      document.execCommand('copy');
      showStatus('✅ 복사 완료!');
      setTimeout(hideStatus, 1500);
    }
  };

  // 박스 순서 이동 (위로)
  window.moveBoxUp = function(index) {
    if (index > 0) {
      [workflowBoxes[index], workflowBoxes[index - 1]] = [workflowBoxes[index - 1], workflowBoxes[index]];
      renderWorkflowBoxes();
      saveWorkflowBoxes();
    }
  };

  // 박스 순서 이동 (아래로)
  window.moveBoxDown = function(index) {
    if (index < workflowBoxes.length - 1) {
      [workflowBoxes[index], workflowBoxes[index + 1]] = [workflowBoxes[index + 1], workflowBoxes[index]];
      renderWorkflowBoxes();
      saveWorkflowBoxes();
    }
  };

  // 드래그 앤 드롭 설정
  let draggedBoxIndex = null;

  function setupDragAndDrop() {
    const container = document.getElementById('workflow-boxes-container');
    if (!container) return;

    container.addEventListener('dragstart', (e) => {
      if (e.target.classList.contains('workflow-box')) {
        draggedBoxIndex = parseInt(e.target.dataset.boxIndex);
        e.target.style.opacity = '0.4';
      }
    });

    container.addEventListener('dragend', (e) => {
      if (e.target.classList.contains('workflow-box')) {
        e.target.style.opacity = '1';
        draggedBoxIndex = null;
      }
    });

    container.addEventListener('dragover', (e) => {
      e.preventDefault();
      const targetBox = e.target.closest('.workflow-box');
      if (targetBox && draggedBoxIndex !== null) {
        const targetIndex = parseInt(targetBox.dataset.boxIndex);
        if (draggedBoxIndex !== targetIndex) {
          const rect = targetBox.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          if (e.clientY < midpoint) {
            targetBox.style.borderTop = '3px solid #667eea';
            targetBox.style.borderBottom = '';
          } else {
            targetBox.style.borderTop = '';
            targetBox.style.borderBottom = '3px solid #667eea';
          }
        }
      }
    });

    container.addEventListener('dragleave', (e) => {
      const targetBox = e.target.closest('.workflow-box');
      if (targetBox) {
        targetBox.style.borderTop = '';
        targetBox.style.borderBottom = '';
      }
    });

    container.addEventListener('drop', (e) => {
      e.preventDefault();
      const targetBox = e.target.closest('.workflow-box');
      if (targetBox && draggedBoxIndex !== null) {
        const targetIndex = parseInt(targetBox.dataset.boxIndex);

        if (draggedBoxIndex !== targetIndex) {
          const draggedBox = workflowBoxes[draggedBoxIndex];
          workflowBoxes.splice(draggedBoxIndex, 1);

          const rect = targetBox.getBoundingClientRect();
          const midpoint = rect.top + rect.height / 2;
          const insertIndex = e.clientY < midpoint ? targetIndex : targetIndex + 1;
          const finalIndex = draggedBoxIndex < targetIndex ? insertIndex - 1 : insertIndex;

          workflowBoxes.splice(finalIndex, 0, draggedBox);
          renderWorkflowBoxes();
          saveWorkflowBoxes();
          setupDragAndDrop(); // 재설정
        }

        targetBox.style.borderTop = '';
        targetBox.style.borderBottom = '';
      }
    });
  }

  // 워크플로우 박스 저장
  async function saveWorkflowBoxes() {
    localStorage.setItem('_drama-workflow-boxes', JSON.stringify(workflowBoxes));
    localStorage.setItem('_drama-next-box-id', nextBoxId.toString());
    localStorage.setItem('_drama-next-step1-num', nextStep1BoxNum.toString());
    localStorage.setItem('_drama-next-step2-num', nextStep2BoxNum.toString());
    await saveToFirebase('_drama-workflow-boxes', JSON.stringify(workflowBoxes));
    await saveToFirebase('_drama-next-box-id', nextBoxId.toString());
    await saveToFirebase('_drama-next-step1-num', nextStep1BoxNum.toString());
    await saveToFirebase('_drama-next-step2-num', nextStep2BoxNum.toString());
  }

  // 워크플로우 박스 불러오기
  function loadWorkflowBoxes() {
    const saved = localStorage.getItem('_drama-workflow-boxes');
    const savedNextId = localStorage.getItem('_drama-next-box-id');
    const savedStep1Num = localStorage.getItem('_drama-next-step1-num');
    const savedStep2Num = localStorage.getItem('_drama-next-step2-num');
    const savedStep1Collapsed = localStorage.getItem('_drama-step1-collapsed');
    const savedStep2Collapsed = localStorage.getItem('_drama-step2-collapsed');

    if (saved) {
      workflowBoxes = JSON.parse(saved);
    }
    if (savedNextId) {
      nextBoxId = parseInt(savedNextId);
    }
    if (savedStep1Num) {
      nextStep1BoxNum = parseInt(savedStep1Num);
    }
    if (savedStep2Num) {
      nextStep2BoxNum = parseInt(savedStep2Num);
    }
    // Reset collapsed state to false to ensure boxes are visible
    step1Collapsed = false;
    step2Collapsed = false;
    localStorage.removeItem('_drama-step1-collapsed');
    localStorage.removeItem('_drama-step2-collapsed');
  }

  // 워크플로우 박스 추가 버튼
  const btnAddStep1Box = document.getElementById('btn-add-step1-box');
  const btnAddStep2Box = document.getElementById('btn-add-step2-box');

  if (btnAddStep1Box) {
    btnAddStep1Box.addEventListener('click', () => addWorkflowBox('step1'));
  }
  if (btnAddStep2Box) {
    btnAddStep2Box.addEventListener('click', () => addWorkflowBox('step2'));
  }

  // Step1 결과 복사 버튼
  const btnCopyStep1Results = document.getElementById('btn-copy-step1-results');
  if (btnCopyStep1Results) {
    btnCopyStep1Results.addEventListener('click', () => {
      const step1Boxes = workflowBoxes.filter(box => (box.stepType || 'step1') === 'step1');
      let allResults = '';

      step1Boxes.forEach(box => {
        if (box.result) {
          allResults += `\n\n${'='.repeat(50)}\n`;
          allResults += `[${box.boxNumber}] ${box.name}\n`;
          allResults += `${'='.repeat(50)}\n\n`;
          allResults += box.result;
        }
      });

      if (!allResults) {
        alert('복사할 Step1 결과가 없습니다.');
        return;
      }

      const textarea = document.createElement('textarea');
      textarea.value = allResults.trim();
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);

      showStatus('✅ Step1 결과 복사 완료!');
      setTimeout(hideStatus, 2000);
    });
  }

  // Step2 결과 복사 버튼 (안내 문구 포함)
  const btnCopyStep2Results = document.getElementById('btn-copy-step2-results');
  if (btnCopyStep2Results) {
    btnCopyStep2Results.addEventListener('click', () => {
      const step2Boxes = workflowBoxes.filter(box => box.stepType === 'step2');
      let allResults = '';

      // 안내 문구 추가
      allResults += '━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n';
      allResults += '                  드라마 대본 작성 자료\n';
      allResults += '━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n';
      allResults += '아래는 새로운 드라마 대본을 작성하기 위해 준비된 기획 자료입니다.\n';
      allResults += '각 단계별로 정리된 내용을 참고하여, 완성도 높은 드라마 대본을 작성해주세요.\n\n';
      allResults += '이 자료는 캐릭터 설정, 스토리 구조, 장면 구성 등 드라마 제작에 필요한\n';
      allResults += '핵심 요소들을 포함하고 있습니다. 각 섹션의 내용을 토대로 자연스럽고\n';
      allResults += '생동감 있는 대본으로 발전시켜 주시기 바랍니다.\n\n';

      step2Boxes.forEach(box => {
        if (box.result) {
          allResults += `\n\n${'='.repeat(50)}\n`;
          allResults += `[${box.boxNumber}] ${box.name}\n`;
          allResults += `${'='.repeat(50)}\n\n`;
          allResults += box.result;
        }
      });

      if (!step2Boxes.some(box => box.result)) {
        alert('복사할 Step2 결과가 없습니다.');
        return;
      }

      const textarea = document.createElement('textarea');
      textarea.value = allResults.trim();
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);

      showStatus('✅ Step2 결과 (안내문구 포함) 복사 완료!');
      setTimeout(hideStatus, 2000);
    });
  }

  // 순차 실행 함수 (공통)
  async function autoExecuteBoxes(boxes, title) {
    if (boxes.length === 0) {
      alert(`실행할 ${title} 박스가 없습니다.`);
      return;
    }

    if (!confirm(`${boxes.length}개의 ${title} 박스를 순서대로 실행하시겠습니까?\n\n실행 시간이 오래 걸릴 수 있습니다.`)) {
      return;
    }

    showLoadingOverlay(`${title} 순차 실행 중`, `${title} ${boxes.length}개 박스 실행 중...`);

    for (let i = 0; i < boxes.length; i++) {
      const box = boxes[i];

      // 로딩 메시지 업데이트
      const overlay = document.getElementById('loading-overlay');
      if (overlay) {
        const subtextEl = overlay.querySelector('.loading-subtext');
        if (subtextEl) {
          subtextEl.textContent = `[${i + 1}/${boxes.length}] ${box.name} 실행 중...`;
        }
      }

      // 박스 실행 (executeWorkflowBox 함수 내용을 직접 실행)
      await executeWorkflowBoxDirect(box);

      // 잠시 대기 (API 부하 방지)
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    hideLoadingOverlay();
    showStatus(`✅ ${title} 순차 실행 완료!`);
    setTimeout(hideStatus, 2000);
    renderWorkflowBoxes();

    // ⭐ Step1 완료 시 자동으로 메타데이터 생성 및 대본 뷰어 표시
    if (title === 'Step1') {
      const step1Results = boxes.filter(b => b.result).map(b => b.result);
      if (step1Results.length > 0) {
        // 마지막 Step1 결과에서 대본 추출
        const lastResult = step1Results[step1Results.length - 1];

        // 대본 뷰어에 표시
        displayStep1ScriptViewer(lastResult);

        // 대본 텍스트 추출 (나레이션만)
        const scriptText = extractNarrationFromResult(lastResult);
        if (scriptText) {
          const contentType = document.getElementById('content-type')?.value || 'testimony';
          console.log('[Step1] 대본 완료, 메타데이터 자동 생성 시작...');
          generateMetadataFromScript(scriptText, contentType);
        }
      }
    }
  }

  // 순차 실행 버튼 이벤트 리스너
  const btnAutoExecuteStep1 = document.getElementById('btn-auto-execute-step1');
  const btnAutoExecuteStep2 = document.getElementById('btn-auto-execute-step2');
  const btnAutoExecuteAll = document.getElementById('btn-auto-execute-all');

  if (btnAutoExecuteStep1) {
    btnAutoExecuteStep1.addEventListener('click', async () => {
      const step1Boxes = workflowBoxes.filter(box => (box.stepType || 'step1') === 'step1');
      await autoExecuteBoxes(step1Boxes, 'Step1');
    });
  }

  if (btnAutoExecuteStep2) {
    btnAutoExecuteStep2.addEventListener('click', async () => {
      const step2Boxes = workflowBoxes.filter(box => box.stepType === 'step2');
      await autoExecuteBoxes(step2Boxes, 'Step2');
    });
  }

  if (btnAutoExecuteAll) {
    btnAutoExecuteAll.addEventListener('click', async () => {
      await autoExecuteBoxes(workflowBoxes, '전체');
    });
  }

  // 접기/펼치기 버튼
  const btnToggleStep1 = document.getElementById('btn-toggle-step1');
  const btnToggleStep2 = document.getElementById('btn-toggle-step2');

  if (btnToggleStep1) {
    btnToggleStep1.addEventListener('click', () => {
      step1Collapsed = !step1Collapsed;
      localStorage.setItem('_drama-step1-collapsed', step1Collapsed.toString());
      renderWorkflowBoxes();
    });
  }

  if (btnToggleStep2) {
    btnToggleStep2.addEventListener('click', () => {
      step2Collapsed = !step2Collapsed;
      localStorage.setItem('_drama-step2-collapsed', step2Collapsed.toString());
      renderWorkflowBoxes();
    });
  }

  // 순차 실행용 직접 실행 함수
  async function executeWorkflowBoxDirect(box) {
    // 입력 데이터 수집
    let inputData = {};

    if (box.inputs.benchmarkScript) {
      inputData.benchmarkScript = document.getElementById('benchmark-script').value;
    }

    if (box.inputs.aiAnalysis) {
      inputData.aiAnalysis = document.getElementById('analysis-result').innerText;
    }

    // 다른 박스의 결과 수집
    for (const [key, value] of Object.entries(box.inputs)) {
      if (key.startsWith('box_') && value) {
        const boxNumber = parseInt(key.replace('box_', ''));
        const sourceBox = workflowBoxes.find(b => b.boxNumber === boxNumber);
        if (sourceBox && sourceBox.result) {
          inputData[`box${boxNumber}Result`] = sourceBox.result;
        }
      }
    }

    // 주인공 정보 수집
    const mainCharacter = document.getElementById('main-character')?.value.trim() || '';

    // stepType에 따라 적절한 모델 선택
    const stepType = box.stepType || 'step1';
    const modelToUse = stepType === 'step1' ? aiModelSettings.step1 : aiModelSettings.step2;

    try {
      const response = await fetch('/api/drama/workflow-execute', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          boxId: box.id,
          boxName: box.name,
          boxNumber: box.boxNumber,
          stepType: stepType,
          guide: box.guide,
          inputs: inputData,
          category: currentCategory,
          mainCharacter: mainCharacter,
          model: modelToUse
        })
      });

      const data = await response.json();

      if (data.ok) {
        box.result = data.result;
        const resultEl = document.getElementById(`result-${box.id}`);
        if (resultEl) {
          resultEl.value = data.result;
        }
        await saveWorkflowBoxes();
      } else {
        console.error(`Box ${box.boxNumber} failed:`, data.error);
      }
    } catch (err) {
      console.error(`Box ${box.boxNumber} error:`, err.message);
    }
  }

  // 지침 관리 모달 열기
  const btnOpenGuideModal = document.getElementById('btn-open-guide-modal');
  const btnOpenGuideModalPanel = document.getElementById('btn-open-guide-modal-panel');
  const modalGuideManagement = document.getElementById('modal-guide-management');
  const btnCloseGuideModal = document.getElementById('btn-close-guide-modal');
  const btnModalSaveGuides = document.getElementById('btn-modal-save-guides');

  if (btnOpenGuideModal && modalGuideManagement) {
    btnOpenGuideModal.addEventListener('click', () => {
      renderGuideManagement(); // 열 때 최신 상태로 렌더링
      modalGuideManagement.classList.add('show');
    });
  }

  if (btnOpenGuideModalPanel && modalGuideManagement) {
    btnOpenGuideModalPanel.addEventListener('click', () => {
      renderGuideManagement();
      modalGuideManagement.classList.add('show');
    });
  }

  // 지침 관리 모달 닫기
  if (btnCloseGuideModal && modalGuideManagement) {
    btnCloseGuideModal.addEventListener('click', () => {
      modalGuideManagement.classList.remove('show');
    });
  }

  // 모달 배경 클릭 시 닫기
  if (modalGuideManagement) {
    modalGuideManagement.addEventListener('click', (e) => {
      if (e.target === modalGuideManagement) {
        modalGuideManagement.classList.remove('show');
      }
    });
  }

  // 지침 저장 버튼 (모달)
  if (btnModalSaveGuides) {
    btnModalSaveGuides.addEventListener('click', async () => {
      showStatus('💾 지침 저장 중...');

      // 모든 텍스트영역의 값을 workflowBoxes에 동기화
      workflowBoxes.forEach(box => {
        const textarea = document.getElementById(`modal-guide-${box.id}`);
        if (textarea) {
          box.guide = textarea.value;
        }
      });

      // Step3~Step7 지침 저장
      const step3Textarea = document.getElementById('modal-guide-step3');
      if (step3Textarea) {
        step3Guide = step3Textarea.value;
        localStorage.setItem('_drama-step3-guide', step3Guide);
        await saveToFirebase('_drama-step3-guide', step3Guide);
      }

      const step4Textarea = document.getElementById('modal-guide-step4');
      if (step4Textarea) {
        step4Guide = step4Textarea.value;
        localStorage.setItem('_drama-step4-guide', step4Guide);
        await saveToFirebase('_drama-step4-guide', step4Guide);
      }

      const step5Textarea = document.getElementById('modal-guide-step5');
      if (step5Textarea) {
        step5Guide = step5Textarea.value;
        localStorage.setItem('_drama-step5-guide', step5Guide);
        await saveToFirebase('_drama-step5-guide', step5Guide);
      }

      const step6Textarea = document.getElementById('modal-guide-step6');
      if (step6Textarea) {
        step6Guide = step6Textarea.value;
        localStorage.setItem('_drama-step6-guide', step6Guide);
        await saveToFirebase('_drama-step6-guide', step6Guide);
      }

      const step7Textarea = document.getElementById('modal-guide-step7');
      if (step7Textarea) {
        step7Guide = step7Textarea.value;
        localStorage.setItem('_drama-step7-guide', step7Guide);
        await saveToFirebase('_drama-step7-guide', step7Guide);
      }

      // JSON 지침 저장
      const jsonTextarea = document.getElementById('modal-guide-json');
      if (jsonTextarea) {
        dramaJsonGuide = jsonTextarea.value;
        localStorage.setItem('_drama-json-guide', dramaJsonGuide);
        await saveToFirebase('_drama-json-guide', dramaJsonGuide);
      }

      // AI 모델 설정 저장
      aiModelSettings = {
        step1: document.getElementById('model-step1')?.value || 'gpt-4o-mini',
        step2: document.getElementById('model-step2')?.value || 'gpt-4o-mini',
        step3: document.getElementById('model-step3')?.value || 'anthropic/claude-sonnet-4.5',
        benchmarkAnalysis: document.getElementById('model-benchmark')?.value || 'gpt-4o-mini'
      };
      localStorage.setItem('_drama-ai-models', JSON.stringify(aiModelSettings));
      await saveToFirebase('_drama-ai-models', JSON.stringify(aiModelSettings));

      // Firebase와 localStorage에 저장
      await saveWorkflowBoxes();

      showStatus('✅ 지침 및 모델 설정 저장 완료!');
      setTimeout(hideStatus, 2000);
    });
  }

  // ===== 초기화 =====
  document.addEventListener('DOMContentLoaded', async () => {
    const dateInput = document.getElementById('drama-date');
    if (dateInput) {
      dateInput.value = new Date().toISOString().split('T')[0];
    }

    // ⭐ 워크플로우 세션 로드 또는 새로 생성
    if (!loadSessionFromStorage()) {
      initWorkflowSession();
    }
    // Step7에 메타데이터 동기화
    syncMetadataToStep7();

    // ⭐ JSON 지침 로드 (비동기, 실패해도 계속 진행)
    loadDramaGuidelines().then(loaded => {
      if (loaded) {
        console.log('[INIT] 서버 지침 로드 완료');
      }
    });

    showStatus('☁️ 클라우드 동기화 중...');
    await loadFromFirebase();

    // ⭐ Step3~Step7 지침 불러오기 (Firebase 동기화 후)
    step3Guide = localStorage.getItem('_drama-step3-guide') || '';
    step4Guide = localStorage.getItem('_drama-step4-guide') || '';
    step5Guide = localStorage.getItem('_drama-step5-guide') || '';
    step6Guide = localStorage.getItem('_drama-step6-guide') || '';
    step7Guide = localStorage.getItem('_drama-step7-guide') || '';

    // ⭐ JSON 지침 불러오기
    dramaJsonGuide = localStorage.getItem('_drama-json-guide') || '';

    // ⭐ Step3 결과 불러오기 (Firebase 동기화 후)
    step3Result = localStorage.getItem('_drama-step3-result') || '';
    if (step3Result) {
      const resultTextarea = document.getElementById('step3-result');
      const resultContainer = document.getElementById('step3-result-container');
      if (resultTextarea && resultContainer) {
        resultTextarea.value = step3Result;
        resultContainer.style.display = 'block';
        // 잠시 후 autoResize 호출 (DOM 렌더링 후)
        setTimeout(() => autoResize(resultTextarea), 100);
      }
    }

    // ⭐ AI 모델 설정 불러오기
    const savedModels = localStorage.getItem('_drama-ai-models');
    if (savedModels) {
      aiModelSettings = JSON.parse(savedModels);
    }

    // ⭐ 워크플로우 박스 불러오기 및 렌더링
    loadWorkflowBoxes();
    renderWorkflowBoxes();

    hideStatus();

    renderCategories();
    loadMasterGuide(currentCategory);
    renderProcessingSteps();
    renderResultBoxes();
    renderGuideTabs();
    renderSavedList();

    document.querySelectorAll('textarea').forEach(autoResize);

    // ⭐ 저장된 썸네일 및 인물 이미지 복원
    restoreThumbnail();
    renderCharacterImages();

    // ⭐ Step1 입력 필드 변경 시 세션 자동 저장
    setupStep1SessionSync();

    // ⭐ YouTube 인증 상태 확인 및 채널 목록 로드
    try {
      const authResponse = await fetch('/api/drama/youtube-auth-status');
      const authData = await authResponse.json();
      if (authData.authenticated) {
        youtubeAuthenticated = true;
        const authBtn = document.getElementById('btn-youtube-auth');
        const authStatus = document.getElementById('youtube-auth-status');
        if (authBtn) {
          authBtn.textContent = '✅ 인증 완료';
          authBtn.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)';
          authBtn.disabled = true;
        }
        if (authStatus) {
          authStatus.innerHTML = '<span style="color: #27ae60;">✅ YouTube 인증이 완료되었습니다.</span>';
        }
        updateStep7Status();
        // 채널 목록 로드
        await loadYouTubeChannels();
      }
    } catch (e) {
      console.log('YouTube 인증 상태 확인 실패:', e);
    }
  });

  // ===== 지침 보기 모달 =====
  function openGuidelinesModal() {
    const modal = document.getElementById('guidelines-modal');
    const content = document.getElementById('guidelines-modal-content');

    // 지침 내용 구성
    let guidelineText = '';

    // 대본 구조 (7단계) 표시
    if (dramaGuidelines?.structure?.sections) {
      guidelineText += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🏗️ 대본 구조 (7단계) - 총 ${dramaGuidelines.structure.total_length}자
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

`;
      dramaGuidelines.structure.sections.forEach(section => {
        const charCount = Math.round(dramaGuidelines.structure.total_length * section.length_ratio);
        guidelineText += `【 ${section.id}. ${section.korean_name} 】 (${(section.length_ratio * 100).toFixed(0)}% ≈ ${charCount}자)
목적: ${section.purpose}
필수 요소: ${section.must_include.join(', ')}
예시: "${section.example?.substring(0, 50)}..."

`;
      });
    }

    // 대사 비율
    if (dramaGuidelines?.dialogue_ratio) {
      guidelineText += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
💬 대사 비율
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• 서술/나레이션: ${dramaGuidelines.dialogue_ratio.narration}%
• 내면 독백: ${dramaGuidelines.dialogue_ratio.inner_monologue}%
• 직접 대화: ${dramaGuidelines.dialogue_ratio.direct_dialogue}%

`;
    }

    // 디테일 요구사항
    if (dramaGuidelines?.detail_requirements) {
      const dr = dramaGuidelines.detail_requirements;
      guidelineText += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 필수 디테일 요구사항
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• 이름: ${dr.naming?.min_count}개 이상 (예: ${dr.naming?.examples?.join(', ')})
• 나이: ${dr.ages?.min_count}개 이상 (예: ${dr.ages?.examples?.join(', ')})
• 장소: ${dr.locations?.min_count}개 이상 (예: ${dr.locations?.examples?.join(', ')})
• 숫자: ${dr.amounts?.min_count}개 이상 (예: ${dr.amounts?.examples?.join(', ')})
• 시간: ${dr.time_periods?.min_count}개 이상 (예: ${dr.time_periods?.examples?.join(', ')})

`;
    }

    // 감정 표현
    if (dramaGuidelines?.emotional_expressions) {
      guidelineText += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
❤️ 감정 표현 가이드
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
신체 반응:
${dramaGuidelines.emotional_expressions.physical_reactions?.map(p => `  • ${p}`).join('\n')}

감정 상태:
${dramaGuidelines.emotional_expressions.emotional_states?.map(p => `  • ${p}`).join('\n')}

`;
    }

    // 금지 패턴
    if (dramaGuidelines?.forbidden_patterns) {
      guidelineText += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🚫 금지 패턴
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
포맷팅:
${dramaGuidelines.forbidden_patterns.formatting?.map(p => `  ✗ ${p}`).join('\n')}

콘텐츠:
${dramaGuidelines.forbidden_patterns.content?.map(p => `  ✗ ${p}`).join('\n')}

스타일:
${dramaGuidelines.forbidden_patterns.style?.map(p => `  ✗ ${p}`).join('\n')}

`;
    }

    // 품질 체크리스트
    if (dramaGuidelines?.quality_checklist) {
      guidelineText += `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 품질 체크리스트
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
구조:
${dramaGuidelines.quality_checklist.structure?.map(q => `  ☐ ${q}`).join('\n')}

디테일:
${dramaGuidelines.quality_checklist.details?.map(q => `  ☐ ${q}`).join('\n')}

감정:
${dramaGuidelines.quality_checklist.emotion?.map(q => `  ☐ ${q}`).join('\n')}

대사:
${dramaGuidelines.quality_checklist.dialogue?.map(q => `  ☐ ${q}`).join('\n')}
`;
    }

    if (!guidelineText) {
      guidelineText = '지침이 로드되지 않았습니다. 새로고침 후 다시 시도해주세요.';
    }

    content.textContent = guidelineText;
    modal.classList.add('show');
  }

  function closeGuidelinesModal() {
    const modal = document.getElementById('guidelines-modal');
    modal.classList.remove('show');
  }

  // 지침 보기 버튼 이벤트
  document.getElementById('btn-view-guidelines')?.addEventListener('click', openGuidelinesModal);

  // 모달 외부 클릭 시 닫기
  document.getElementById('guidelines-modal')?.addEventListener('click', (e) => {
    if (e.target.id === 'guidelines-modal') {
      closeGuidelinesModal();
    }
  });

  // ===== JSON 뷰어 모달 =====
  let currentJsonTab = 'session';
  let currentJsonContent = '';

  function openJsonViewerModal() {
    const modal = document.getElementById('json-viewer-modal');
    modal.classList.add('show');
    showJsonTab('session');
  }

  function closeJsonViewerModal() {
    const modal = document.getElementById('json-viewer-modal');
    modal.classList.remove('show');
  }

  function showJsonTab(tabName) {
    currentJsonTab = tabName;

    // 탭 버튼 활성화 스타일
    document.querySelectorAll('.json-tab').forEach(btn => {
      btn.style.background = '#e0e0e0';
      btn.style.color = '#333';
    });
    document.getElementById(`json-tab-${tabName}`).style.background = '#6c5ce7';
    document.getElementById(`json-tab-${tabName}`).style.color = 'white';

    const content = document.getElementById('json-viewer-content');

    if (tabName === 'session') {
      currentJsonContent = JSON.stringify(workflowSession, null, 2);
      content.innerHTML = syntaxHighlight(currentJsonContent);
    } else if (tabName === 'guidelines') {
      currentJsonContent = dramaGuidelines ? JSON.stringify(dramaGuidelines, null, 2) : '// 지침이 로드되지 않았습니다.';
      content.innerHTML = syntaxHighlight(currentJsonContent);
    } else if (tabName === 'structure') {
      // 대본 구조만 표시
      if (dramaGuidelines?.structure) {
        const structureInfo = {
          total_length: dramaGuidelines.structure.total_length,
          sections: dramaGuidelines.structure.sections.map(s => ({
            id: s.id,
            name: s.korean_name,
            ratio: `${(s.length_ratio * 100).toFixed(0)}%`,
            purpose: s.purpose,
            must_include: s.must_include
          })),
          dialogue_ratio: dramaGuidelines.dialogue_ratio,
          mandatory_elements: dramaGuidelines.mandatory_elements
        };
        currentJsonContent = JSON.stringify(structureInfo, null, 2);
        content.innerHTML = syntaxHighlight(currentJsonContent);
      } else {
        content.textContent = '// 지침이 로드되지 않았습니다.';
      }
    }
  }

  function refreshJsonViewer() {
    showJsonTab(currentJsonTab);
    showStatus('🔄 JSON 새로고침 완료');
    setTimeout(hideStatus, 1500);
  }

  function copyJsonContent() {
    navigator.clipboard.writeText(currentJsonContent).then(() => {
      showStatus('📋 JSON 복사 완료!');
      setTimeout(hideStatus, 1500);
    });
  }

  // JSON 구문 강조
  function syntaxHighlight(json) {
    if (typeof json !== 'string') {
      json = JSON.stringify(json, null, 2);
    }
    json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
      let cls = 'number';
      if (/^"/.test(match)) {
        if (/:$/.test(match)) {
          cls = 'key';
        } else {
          cls = 'string';
        }
      } else if (/true|false/.test(match)) {
        cls = 'boolean';
      } else if (/null/.test(match)) {
        cls = 'null';
      }
      const colors = {
        key: '#9cdcfe',
        string: '#ce9178',
        number: '#b5cea8',
        boolean: '#569cd6',
        null: '#569cd6'
      };
      return `<span style="color: ${colors[cls]}">${match}</span>`;
    });
  }

  // JSON 뷰어 버튼 이벤트
  document.getElementById('btn-view-json')?.addEventListener('click', openJsonViewerModal);

  // JSON 뷰어 모달 외부 클릭 시 닫기
  document.getElementById('json-viewer-modal')?.addEventListener('click', (e) => {
    if (e.target.id === 'json-viewer-modal') {
      closeJsonViewerModal();
    }
  });

  // Step1 입력 필드들을 세션과 동기화
  function setupStep1SessionSync() {
    // 벤치마크 대본
    const benchmarkScript = document.getElementById('benchmark-script');
    if (benchmarkScript) {
      // 세션에서 불러오기
      if (workflowSession.step1.benchmark?.script) {
        benchmarkScript.value = workflowSession.step1.benchmark.script;
      }
      // 변경 시 저장
      benchmarkScript.addEventListener('change', () => {
        updateSession('step1.benchmark.script', benchmarkScript.value);
      });
    }

    // 주인공 정보
    const mainCharacter = document.getElementById('main-character');
    if (mainCharacter) {
      if (workflowSession.step1.mainCharacter) {
        mainCharacter.value = workflowSession.step1.mainCharacter;
      }
      mainCharacter.addEventListener('change', () => {
        updateSession('step1.mainCharacter', mainCharacter.value);
      });
    }

    // 카테고리 변경
    const categorySelect = document.getElementById('category-select');
    if (categorySelect) {
      categorySelect.addEventListener('change', () => {
        updateSession('category', categorySelect.value);
      });
    }

    // 콘텐츠 유형 변경
    const contentType = document.getElementById('content-type');
    if (contentType) {
      if (workflowSession.contentType) {
        contentType.value = workflowSession.contentType;
      }
      contentType.addEventListener('change', () => {
        updateSession('contentType', contentType.value);
      });
    }

    console.log('[SESSION] Step1 동기화 설정 완료');
  }

  // ===== 패널 내비게이션 및 데이터 뷰 =====
  function setActivePanel(panelId, scrollTarget) {
    document.querySelectorAll('.panel').forEach(panel => panel.classList.remove('active'));
    const targetPanel = document.getElementById(panelId);
    if (targetPanel) {
      targetPanel.classList.add('active');
    }

    document.querySelectorAll('.quick-nav .nav-btn').forEach(btn => {
      const isActive = btn.dataset.panelTarget === panelId;
      btn.classList.toggle('active', isActive);
    });

    if (panelId === 'workflow-panel' && scrollTarget) {
      setTimeout(() => scrollToStep(scrollTarget), 50);
    }
  }

  function refreshDatasetViews() {
    const textArea = document.getElementById('data-text-view');
    const jsonView = document.getElementById('data-json-view');

    const step3Text = document.getElementById('step3-result')?.value?.trim();
    if (textArea) {
      textArea.value = step3Text || '아직 불러온 대본이 없습니다. 워크플로우 Step3을 실행한 뒤 다시 새로고침하세요.';
    }

    if (jsonView) {
      const selectedVoice = document.querySelector('.step5-voice-option.selected')?.dataset.voice || '';
      const scenes = (workflowBoxes || []).map(box => ({
        name: box.name,
        guide: box.guide || '',
        result: box.result || ''
      }));
      const metadata = {
        title: document.getElementById('step7-title')?.value || '',
        tone: document.getElementById('content-type')?.value || '',
        scenes,
        voice: selectedVoice,
        lastUpdated: new Date().toISOString()
      };
      jsonView.textContent = JSON.stringify(metadata, null, 2);
    }
  }

  function copyTextFromElement(element) {
    if (!element) return;
    const value = element.value || element.textContent || '';
    navigator.clipboard?.writeText(value);
  }

  function analyzeBenchmarkText() {
    const input = document.getElementById('benchmark-analysis-input');
    const output = document.getElementById('benchmark-analysis-output');
    const tag = document.getElementById('benchmark-tag')?.value?.trim();
    if (!input || !output) return;

    const text = (input.value || '').trim();
    if (!text) {
      output.textContent = '분석할 대본을 입력해주세요.';
      return;
    }

    const sentences = text.split(/[.!?\n]+/).filter(Boolean);
    const words = text.replace(/[^가-힣a-zA-Z0-9\s]/g, '').split(/\s+/).filter(Boolean);
    const freq = {};
    words.forEach((w) => { freq[w] = (freq[w] || 0) + 1; });
    const keywords = Object.entries(freq)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([word, count]) => `${word}(${count})`)
      .join(', ');

    const toneHint = tag ? `${tag} 톤` : '서술 톤';

    output.innerHTML = `
      <div><strong>길이:</strong> 문장 ${sentences.length}개, 어절 ${words.length}개</div>
      <div><strong>주요 키워드:</strong> ${keywords || '추출된 키워드 없음'}</div>
      <div><strong>톤 제안:</strong> ${toneHint}</div>
      <div style="margin-top:.4rem; white-space: pre-wrap;">${text.slice(0, 300)}${text.length > 300 ? '... (생략)' : ''}</div>
    `;
  }

  document.querySelectorAll('[data-panel-target]').forEach((btn) => {
    btn.addEventListener('click', () => {
      setActivePanel(btn.dataset.panelTarget, btn.dataset.scrollTarget);
    });
  });

  document.getElementById('btn-refresh-dataset')?.addEventListener('click', refreshDatasetViews);
  document.getElementById('btn-copy-text-view')?.addEventListener('click', () => copyTextFromElement(document.getElementById('data-text-view')));
  document.getElementById('btn-copy-json')?.addEventListener('click', () => copyTextFromElement(document.getElementById('data-json-view')));
  document.getElementById('btn-run-benchmark-analysis')?.addEventListener('click', analyzeBenchmarkText);

  // 초기 패널 상태
  setActivePanel('guide-panel');

  // Step2 결과를 세션에 저장하는 함수 (기존 stepResults에 저장할 때 호출)
  function saveStep2ResultToSession(stepId, result) {
    const stepMap = {
      'character': 'character',
      'storyline': 'storyline',
      'scene': 'scene',
      'dialogue': 'dialogue'
    };

    const sessionKey = stepMap[stepId];
    if (sessionKey) {
      updateSession(`step2.${sessionKey}`, { result, completedAt: new Date().toISOString() });
    }
  }
  </script>
</body>
</html>